\set ECHO none
--Testcase 1:
CREATE EXTENSION influxdb_fdw;
--Testcase 2:
CREATE SERVER influxdb_svr FOREIGN DATA WRAPPER influxdb_fdw
  OPTIONS (dbname 'coredb', :SERVER);
--Testcase 3:
CREATE USER MAPPING FOR CURRENT_USER SERVER influxdb_svr OPTIONS (:AUTHENTICATION);
-- import time column as timestamp and text type
-- IMPORT FOREIGN SCHEMA influxdb_schema FROM SERVER influxdb_svr INTO public;
--
-- JOIN
-- Test JOIN clauses
--
--Testcase 4:
CREATE FOREIGN TABLE J1_TBL (
  fields jsonb OPTIONS (fields 'true')
) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 575:
CREATE FOREIGN TABLE j1_tbl_nsc (
  i integer,
  j integer,
  t text
) SERVER influxdb_svr OPTIONS (table 'j1_tbl');
--Testcase 5:
CREATE FOREIGN TABLE J2_TBL (
  fields jsonb OPTIONS (fields 'true')
) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 576:
CREATE FOREIGN TABLE j2_tbl_nsc (
  i integer,
  k integer
) SERVER influxdb_svr OPTIONS (table 'j2_tbl');
--Testcase 6:
INSERT INTO j1_tbl_nsc VALUES (1, 4, 'one');
--Testcase 7:
INSERT INTO j1_tbl_nsc VALUES (2, 3, 'two');
--Testcase 8:
INSERT INTO j1_tbl_nsc VALUES (3, 2, 'three');
--Testcase 9:
INSERT INTO j1_tbl_nsc VALUES (4, 1, 'four');
--Testcase 10:
INSERT INTO j1_tbl_nsc VALUES (5, 0, 'five');
--Testcase 11:
INSERT INTO j1_tbl_nsc VALUES (6, 6, 'six');
--Testcase 12:
INSERT INTO j1_tbl_nsc VALUES (7, 7, 'seven');
--Testcase 13:
INSERT INTO j1_tbl_nsc VALUES (8, 8, 'eight');
--Testcase 14:
INSERT INTO j1_tbl_nsc VALUES (0, NULL, 'zero');
--Testcase 15:
INSERT INTO j1_tbl_nsc VALUES (NULL, NULL, 'null');
--Testcase 16:
INSERT INTO j1_tbl_nsc VALUES (NULL, 0, 'zero');
--Testcase 17:
INSERT INTO j2_tbl_nsc VALUES (1, -1);
--Testcase 18:
INSERT INTO j2_tbl_nsc VALUES (2, 2);
--Testcase 19:
INSERT INTO j2_tbl_nsc VALUES (3, -3);
--Testcase 20:
INSERT INTO j2_tbl_nsc VALUES (2, 4);
--Testcase 21:
INSERT INTO j2_tbl_nsc VALUES (5, -5);
--Testcase 22:
INSERT INTO j2_tbl_nsc VALUES (5, -5);
--Testcase 23:
INSERT INTO j2_tbl_nsc VALUES (0, NULL);
--InfluxDB does not accept NULL value
--INSERT INTO J2_TBL VALUES (NULL, NULL);
--Testcase 24:
INSERT INTO j2_tbl_nsc VALUES (NULL, 0);
--Testcase 25:
CREATE FOREIGN TABLE tenk1 (
  fields jsonb OPTIONS (fields 'true')
) SERVER influxdb_svr OPTIONS (table 'tenk', schemaless 'true');
--Does not support on Postgres 12
--ALTER TABLE tenk1 SET WITH OIDS;
--Testcase 26:
CREATE FOREIGN TABLE tenk2 (
  fields jsonb OPTIONS (fields 'true')
) SERVER influxdb_svr OPTIONS (table 'tenk', schemaless 'true');
--Testcase 27:
CREATE FOREIGN TABLE INT4_TBL(fields jsonb OPTIONS (fields 'true')) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 28:
CREATE FOREIGN TABLE FLOAT8_TBL(fields jsonb OPTIONS (fields 'true')) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 29:
CREATE FOREIGN TABLE INT8_TBL(
  fields jsonb OPTIONS (fields 'true')
) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 30:
CREATE FOREIGN TABLE INT2_TBL(fields jsonb OPTIONS (fields 'true')) SERVER influxdb_svr OPTIONS(schemaless 'true');
-- useful in some tests below
--Testcase 31:
create temp table onerow();
--Testcase 32:
insert into onerow default values;
analyze onerow;
--
-- CORRELATION NAMES
-- Make sure that table/column aliases are supported
-- before diving into more complex join syntax.
--
--Testcase 33:
SELECT *
  FROM J1_TBL AS tx;
               fields                
-------------------------------------
 {"i": "1", "j": "4", "t": "one"}
 {"i": "2", "j": "3", "t": "two"}
 {"i": "3", "j": "2", "t": "three"}
 {"i": "4", "j": "1", "t": "four"}
 {"i": "5", "j": "0", "t": "five"}
 {"i": "6", "j": "6", "t": "six"}
 {"i": "7", "j": "7", "t": "seven"}
 {"i": "8", "j": "8", "t": "eight"}
 {"i": "0", "j": null, "t": "zero"}
 {"i": null, "j": null, "t": "null"}
 {"i": null, "j": "0", "t": "zero"}
(11 rows)

--Testcase 34:
SELECT *
  FROM J1_TBL tx;
               fields                
-------------------------------------
 {"i": "1", "j": "4", "t": "one"}
 {"i": "2", "j": "3", "t": "two"}
 {"i": "3", "j": "2", "t": "three"}
 {"i": "4", "j": "1", "t": "four"}
 {"i": "5", "j": "0", "t": "five"}
 {"i": "6", "j": "6", "t": "six"}
 {"i": "7", "j": "7", "t": "seven"}
 {"i": "8", "j": "8", "t": "eight"}
 {"i": "0", "j": null, "t": "zero"}
 {"i": null, "j": null, "t": "null"}
 {"i": null, "j": "0", "t": "zero"}
(11 rows)

--Testcase 35:
SELECT *
  FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) AS t1 (a, b, c);
 a | b |   c   
---+---+-------
 1 | 4 | one
 2 | 3 | two
 3 | 2 | three
 4 | 1 | four
 5 | 0 | five
 6 | 6 | six
 7 | 7 | seven
 8 | 8 | eight
 0 |   | zero
   |   | null
   | 0 | zero
(11 rows)

--Testcase 36:
SELECT *
  FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) t1 (a, b, c);
 a | b |   c   
---+---+-------
 1 | 4 | one
 2 | 3 | two
 3 | 2 | three
 4 | 1 | four
 5 | 0 | five
 6 | 6 | six
 7 | 7 | seven
 8 | 8 | eight
 0 |   | zero
   |   | null
   | 0 | zero
(11 rows)

--Testcase 37:
SELECT *
  FROM (SELECT (fields->>'i')::int, (fields->>'j')::int,fields->>'t' FROM J1_TBL) t1 (a, b, c), (SELECT (fields->>'i')::int ,(fields->>'k')::int FROM J2_TBL) t2 (d, e) ORDER BY t1.a, t1.b, t1.c, t2.d, t2.e;
 a | b |   c   | d | e  
---+---+-------+---+----
 0 |   | zero  | 0 |   
 0 |   | zero  | 1 | -1
 0 |   | zero  | 2 |  2
 0 |   | zero  | 2 |  4
 0 |   | zero  | 3 | -3
 0 |   | zero  | 5 | -5
 0 |   | zero  | 5 | -5
 0 |   | zero  |   |  0
 1 | 4 | one   | 0 |   
 1 | 4 | one   | 1 | -1
 1 | 4 | one   | 2 |  2
 1 | 4 | one   | 2 |  4
 1 | 4 | one   | 3 | -3
 1 | 4 | one   | 5 | -5
 1 | 4 | one   | 5 | -5
 1 | 4 | one   |   |  0
 2 | 3 | two   | 0 |   
 2 | 3 | two   | 1 | -1
 2 | 3 | two   | 2 |  2
 2 | 3 | two   | 2 |  4
 2 | 3 | two   | 3 | -3
 2 | 3 | two   | 5 | -5
 2 | 3 | two   | 5 | -5
 2 | 3 | two   |   |  0
 3 | 2 | three | 0 |   
 3 | 2 | three | 1 | -1
 3 | 2 | three | 2 |  2
 3 | 2 | three | 2 |  4
 3 | 2 | three | 3 | -3
 3 | 2 | three | 5 | -5
 3 | 2 | three | 5 | -5
 3 | 2 | three |   |  0
 4 | 1 | four  | 0 |   
 4 | 1 | four  | 1 | -1
 4 | 1 | four  | 2 |  2
 4 | 1 | four  | 2 |  4
 4 | 1 | four  | 3 | -3
 4 | 1 | four  | 5 | -5
 4 | 1 | four  | 5 | -5
 4 | 1 | four  |   |  0
 5 | 0 | five  | 0 |   
 5 | 0 | five  | 1 | -1
 5 | 0 | five  | 2 |  2
 5 | 0 | five  | 2 |  4
 5 | 0 | five  | 3 | -3
 5 | 0 | five  | 5 | -5
 5 | 0 | five  | 5 | -5
 5 | 0 | five  |   |  0
 6 | 6 | six   | 0 |   
 6 | 6 | six   | 1 | -1
 6 | 6 | six   | 2 |  2
 6 | 6 | six   | 2 |  4
 6 | 6 | six   | 3 | -3
 6 | 6 | six   | 5 | -5
 6 | 6 | six   | 5 | -5
 6 | 6 | six   |   |  0
 7 | 7 | seven | 0 |   
 7 | 7 | seven | 1 | -1
 7 | 7 | seven | 2 |  2
 7 | 7 | seven | 2 |  4
 7 | 7 | seven | 3 | -3
 7 | 7 | seven | 5 | -5
 7 | 7 | seven | 5 | -5
 7 | 7 | seven |   |  0
 8 | 8 | eight | 0 |   
 8 | 8 | eight | 1 | -1
 8 | 8 | eight | 2 |  2
 8 | 8 | eight | 2 |  4
 8 | 8 | eight | 3 | -3
 8 | 8 | eight | 5 | -5
 8 | 8 | eight | 5 | -5
 8 | 8 | eight |   |  0
   | 0 | zero  | 0 |   
   | 0 | zero  | 1 | -1
   | 0 | zero  | 2 |  2
   | 0 | zero  | 2 |  4
   | 0 | zero  | 3 | -3
   | 0 | zero  | 5 | -5
   | 0 | zero  | 5 | -5
   | 0 | zero  |   |  0
   |   | null  | 0 |   
   |   | null  | 1 | -1
   |   | null  | 2 |  2
   |   | null  | 2 |  4
   |   | null  | 3 | -3
   |   | null  | 5 | -5
   |   | null  | 5 | -5
   |   | null  |   |  0
(88 rows)

--Testcase 38:
SELECT t1.a, t2.e
  FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) t1 (a, b, c), (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) t2 (d, e)
  WHERE t1.a = t2.d;
 a | e  
---+----
 0 |   
 1 | -1
 2 |  2
 2 |  4
 3 | -3
 5 | -5
 5 | -5
(7 rows)

--
-- CROSS JOIN
-- Qualifications are not allowed on cross joins,
-- which degenerate into a standard unqualified inner join.
--
--Testcase 39:
SELECT *
  FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) J1_TBL CROSS JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) J2_TBL ORDER BY J1_TBL.i, J1_TBL.j, J1_TBL.t, J2_TBL.i, J2_TBL.k;
 i | j |   t   | i | k  
---+---+-------+---+----
 0 |   | zero  | 0 |   
 0 |   | zero  | 1 | -1
 0 |   | zero  | 2 |  2
 0 |   | zero  | 2 |  4
 0 |   | zero  | 3 | -3
 0 |   | zero  | 5 | -5
 0 |   | zero  | 5 | -5
 0 |   | zero  |   |  0
 1 | 4 | one   | 0 |   
 1 | 4 | one   | 1 | -1
 1 | 4 | one   | 2 |  2
 1 | 4 | one   | 2 |  4
 1 | 4 | one   | 3 | -3
 1 | 4 | one   | 5 | -5
 1 | 4 | one   | 5 | -5
 1 | 4 | one   |   |  0
 2 | 3 | two   | 0 |   
 2 | 3 | two   | 1 | -1
 2 | 3 | two   | 2 |  2
 2 | 3 | two   | 2 |  4
 2 | 3 | two   | 3 | -3
 2 | 3 | two   | 5 | -5
 2 | 3 | two   | 5 | -5
 2 | 3 | two   |   |  0
 3 | 2 | three | 0 |   
 3 | 2 | three | 1 | -1
 3 | 2 | three | 2 |  2
 3 | 2 | three | 2 |  4
 3 | 2 | three | 3 | -3
 3 | 2 | three | 5 | -5
 3 | 2 | three | 5 | -5
 3 | 2 | three |   |  0
 4 | 1 | four  | 0 |   
 4 | 1 | four  | 1 | -1
 4 | 1 | four  | 2 |  2
 4 | 1 | four  | 2 |  4
 4 | 1 | four  | 3 | -3
 4 | 1 | four  | 5 | -5
 4 | 1 | four  | 5 | -5
 4 | 1 | four  |   |  0
 5 | 0 | five  | 0 |   
 5 | 0 | five  | 1 | -1
 5 | 0 | five  | 2 |  2
 5 | 0 | five  | 2 |  4
 5 | 0 | five  | 3 | -3
 5 | 0 | five  | 5 | -5
 5 | 0 | five  | 5 | -5
 5 | 0 | five  |   |  0
 6 | 6 | six   | 0 |   
 6 | 6 | six   | 1 | -1
 6 | 6 | six   | 2 |  2
 6 | 6 | six   | 2 |  4
 6 | 6 | six   | 3 | -3
 6 | 6 | six   | 5 | -5
 6 | 6 | six   | 5 | -5
 6 | 6 | six   |   |  0
 7 | 7 | seven | 0 |   
 7 | 7 | seven | 1 | -1
 7 | 7 | seven | 2 |  2
 7 | 7 | seven | 2 |  4
 7 | 7 | seven | 3 | -3
 7 | 7 | seven | 5 | -5
 7 | 7 | seven | 5 | -5
 7 | 7 | seven |   |  0
 8 | 8 | eight | 0 |   
 8 | 8 | eight | 1 | -1
 8 | 8 | eight | 2 |  2
 8 | 8 | eight | 2 |  4
 8 | 8 | eight | 3 | -3
 8 | 8 | eight | 5 | -5
 8 | 8 | eight | 5 | -5
 8 | 8 | eight |   |  0
   | 0 | zero  | 0 |   
   | 0 | zero  | 1 | -1
   | 0 | zero  | 2 |  2
   | 0 | zero  | 2 |  4
   | 0 | zero  | 3 | -3
   | 0 | zero  | 5 | -5
   | 0 | zero  | 5 | -5
   | 0 | zero  |   |  0
   |   | null  | 0 |   
   |   | null  | 1 | -1
   |   | null  | 2 |  2
   |   | null  | 2 |  4
   |   | null  | 3 | -3
   |   | null  | 5 | -5
   |   | null  | 5 | -5
   |   | null  |   |  0
(88 rows)

-- ambiguous column
--Testcase 40:
SELECT i, k, t
  FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) J1_TBL CROSS JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) J2_TBL ORDER BY J1_TBL.i, J1_TBL.j, J1_TBL.t, J2_TBL.i, J2_TBL.k;
ERROR:  column reference "i" is ambiguous
LINE 1: SELECT i, k, t
               ^
-- resolve previous ambiguity by specifying the table name
--Testcase 41:
SELECT t1.i, k, t
  FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) t1 CROSS JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) t2  ORDER BY t1.i, t1.j, t1.t, t2.i, t2.k;
 i | k  |   t   
---+----+-------
 0 |    | zero
 0 | -1 | zero
 0 |  2 | zero
 0 |  4 | zero
 0 | -3 | zero
 0 | -5 | zero
 0 | -5 | zero
 0 |  0 | zero
 1 |    | one
 1 | -1 | one
 1 |  2 | one
 1 |  4 | one
 1 | -3 | one
 1 | -5 | one
 1 | -5 | one
 1 |  0 | one
 2 |    | two
 2 | -1 | two
 2 |  2 | two
 2 |  4 | two
 2 | -3 | two
 2 | -5 | two
 2 | -5 | two
 2 |  0 | two
 3 |    | three
 3 | -1 | three
 3 |  2 | three
 3 |  4 | three
 3 | -3 | three
 3 | -5 | three
 3 | -5 | three
 3 |  0 | three
 4 |    | four
 4 | -1 | four
 4 |  2 | four
 4 |  4 | four
 4 | -3 | four
 4 | -5 | four
 4 | -5 | four
 4 |  0 | four
 5 |    | five
 5 | -1 | five
 5 |  2 | five
 5 |  4 | five
 5 | -3 | five
 5 | -5 | five
 5 | -5 | five
 5 |  0 | five
 6 |    | six
 6 | -1 | six
 6 |  2 | six
 6 |  4 | six
 6 | -3 | six
 6 | -5 | six
 6 | -5 | six
 6 |  0 | six
 7 |    | seven
 7 | -1 | seven
 7 |  2 | seven
 7 |  4 | seven
 7 | -3 | seven
 7 | -5 | seven
 7 | -5 | seven
 7 |  0 | seven
 8 |    | eight
 8 | -1 | eight
 8 |  2 | eight
 8 |  4 | eight
 8 | -3 | eight
 8 | -5 | eight
 8 | -5 | eight
 8 |  0 | eight
   |    | zero
   | -1 | zero
   |  2 | zero
   |  4 | zero
   | -3 | zero
   | -5 | zero
   | -5 | zero
   |  0 | zero
   |    | null
   | -1 | null
   |  2 | null
   |  4 | null
   | -3 | null
   | -5 | null
   | -5 | null
   |  0 | null
(88 rows)

--Testcase 42:
SELECT ii, tt, kk
  FROM ((SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) J1_TBL CROSS JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) J2_TBL)
    AS tx (ii, jj, tt, ii2, kk) ORDER BY ii, tt, kk;
 ii |  tt   | kk 
----+-------+----
  0 | zero  | -5
  0 | zero  | -5
  0 | zero  | -3
  0 | zero  | -1
  0 | zero  |  0
  0 | zero  |  2
  0 | zero  |  4
  0 | zero  |   
  1 | one   | -5
  1 | one   | -5
  1 | one   | -3
  1 | one   | -1
  1 | one   |  0
  1 | one   |  2
  1 | one   |  4
  1 | one   |   
  2 | two   | -5
  2 | two   | -5
  2 | two   | -3
  2 | two   | -1
  2 | two   |  0
  2 | two   |  2
  2 | two   |  4
  2 | two   |   
  3 | three | -5
  3 | three | -5
  3 | three | -3
  3 | three | -1
  3 | three |  0
  3 | three |  2
  3 | three |  4
  3 | three |   
  4 | four  | -5
  4 | four  | -5
  4 | four  | -3
  4 | four  | -1
  4 | four  |  0
  4 | four  |  2
  4 | four  |  4
  4 | four  |   
  5 | five  | -5
  5 | five  | -5
  5 | five  | -3
  5 | five  | -1
  5 | five  |  0
  5 | five  |  2
  5 | five  |  4
  5 | five  |   
  6 | six   | -5
  6 | six   | -5
  6 | six   | -3
  6 | six   | -1
  6 | six   |  0
  6 | six   |  2
  6 | six   |  4
  6 | six   |   
  7 | seven | -5
  7 | seven | -5
  7 | seven | -3
  7 | seven | -1
  7 | seven |  0
  7 | seven |  2
  7 | seven |  4
  7 | seven |   
  8 | eight | -5
  8 | eight | -5
  8 | eight | -3
  8 | eight | -1
  8 | eight |  0
  8 | eight |  2
  8 | eight |  4
  8 | eight |   
    | null  | -5
    | null  | -5
    | null  | -3
    | null  | -1
    | null  |  0
    | null  |  2
    | null  |  4
    | null  |   
    | zero  | -5
    | zero  | -5
    | zero  | -3
    | zero  | -1
    | zero  |  0
    | zero  |  2
    | zero  |  4
    | zero  |   
(88 rows)

--Testcase 43:
SELECT tx.ii, tx.jj, tx.kk
  FROM ((SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) t1 (a, b, c) CROSS JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) t2 (d, e))
    AS tx (ii, jj, tt, ii2, kk) ORDER BY tx.ii, tx.jj, tx.kk;
 ii | jj | kk 
----+----+----
  0 |    | -5
  0 |    | -5
  0 |    | -3
  0 |    | -1
  0 |    |  0
  0 |    |  2
  0 |    |  4
  0 |    |   
  1 |  4 | -5
  1 |  4 | -5
  1 |  4 | -3
  1 |  4 | -1
  1 |  4 |  0
  1 |  4 |  2
  1 |  4 |  4
  1 |  4 |   
  2 |  3 | -5
  2 |  3 | -5
  2 |  3 | -3
  2 |  3 | -1
  2 |  3 |  0
  2 |  3 |  2
  2 |  3 |  4
  2 |  3 |   
  3 |  2 | -5
  3 |  2 | -5
  3 |  2 | -3
  3 |  2 | -1
  3 |  2 |  0
  3 |  2 |  2
  3 |  2 |  4
  3 |  2 |   
  4 |  1 | -5
  4 |  1 | -5
  4 |  1 | -3
  4 |  1 | -1
  4 |  1 |  0
  4 |  1 |  2
  4 |  1 |  4
  4 |  1 |   
  5 |  0 | -5
  5 |  0 | -5
  5 |  0 | -3
  5 |  0 | -1
  5 |  0 |  0
  5 |  0 |  2
  5 |  0 |  4
  5 |  0 |   
  6 |  6 | -5
  6 |  6 | -5
  6 |  6 | -3
  6 |  6 | -1
  6 |  6 |  0
  6 |  6 |  2
  6 |  6 |  4
  6 |  6 |   
  7 |  7 | -5
  7 |  7 | -5
  7 |  7 | -3
  7 |  7 | -1
  7 |  7 |  0
  7 |  7 |  2
  7 |  7 |  4
  7 |  7 |   
  8 |  8 | -5
  8 |  8 | -5
  8 |  8 | -3
  8 |  8 | -1
  8 |  8 |  0
  8 |  8 |  2
  8 |  8 |  4
  8 |  8 |   
    |  0 | -5
    |  0 | -5
    |  0 | -3
    |  0 | -1
    |  0 |  0
    |  0 |  2
    |  0 |  4
    |  0 |   
    |    | -5
    |    | -5
    |    | -3
    |    | -1
    |    |  0
    |    |  2
    |    |  4
    |    |   
(88 rows)

--Testcase 44:
SELECT *
  FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) J1_TBL CROSS JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) a CROSS JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) b ORDER BY J1_TBL.i, J1_TBL.j, J1_TBL.t, a.i, a.k, b.i, b.k;
 i | j |   t   | i | k  | i | k  
---+---+-------+---+----+---+----
 0 |   | zero  | 0 |    | 0 |   
 0 |   | zero  | 0 |    | 1 | -1
 0 |   | zero  | 0 |    | 2 |  2
 0 |   | zero  | 0 |    | 2 |  4
 0 |   | zero  | 0 |    | 3 | -3
 0 |   | zero  | 0 |    | 5 | -5
 0 |   | zero  | 0 |    | 5 | -5
 0 |   | zero  | 0 |    |   |  0
 0 |   | zero  | 1 | -1 | 0 |   
 0 |   | zero  | 1 | -1 | 1 | -1
 0 |   | zero  | 1 | -1 | 2 |  2
 0 |   | zero  | 1 | -1 | 2 |  4
 0 |   | zero  | 1 | -1 | 3 | -3
 0 |   | zero  | 1 | -1 | 5 | -5
 0 |   | zero  | 1 | -1 | 5 | -5
 0 |   | zero  | 1 | -1 |   |  0
 0 |   | zero  | 2 |  2 | 0 |   
 0 |   | zero  | 2 |  2 | 1 | -1
 0 |   | zero  | 2 |  2 | 2 |  2
 0 |   | zero  | 2 |  2 | 2 |  4
 0 |   | zero  | 2 |  2 | 3 | -3
 0 |   | zero  | 2 |  2 | 5 | -5
 0 |   | zero  | 2 |  2 | 5 | -5
 0 |   | zero  | 2 |  2 |   |  0
 0 |   | zero  | 2 |  4 | 0 |   
 0 |   | zero  | 2 |  4 | 1 | -1
 0 |   | zero  | 2 |  4 | 2 |  2
 0 |   | zero  | 2 |  4 | 2 |  4
 0 |   | zero  | 2 |  4 | 3 | -3
 0 |   | zero  | 2 |  4 | 5 | -5
 0 |   | zero  | 2 |  4 | 5 | -5
 0 |   | zero  | 2 |  4 |   |  0
 0 |   | zero  | 3 | -3 | 0 |   
 0 |   | zero  | 3 | -3 | 1 | -1
 0 |   | zero  | 3 | -3 | 2 |  2
 0 |   | zero  | 3 | -3 | 2 |  4
 0 |   | zero  | 3 | -3 | 3 | -3
 0 |   | zero  | 3 | -3 | 5 | -5
 0 |   | zero  | 3 | -3 | 5 | -5
 0 |   | zero  | 3 | -3 |   |  0
 0 |   | zero  | 5 | -5 | 0 |   
 0 |   | zero  | 5 | -5 | 0 |   
 0 |   | zero  | 5 | -5 | 1 | -1
 0 |   | zero  | 5 | -5 | 1 | -1
 0 |   | zero  | 5 | -5 | 2 |  2
 0 |   | zero  | 5 | -5 | 2 |  2
 0 |   | zero  | 5 | -5 | 2 |  4
 0 |   | zero  | 5 | -5 | 2 |  4
 0 |   | zero  | 5 | -5 | 3 | -3
 0 |   | zero  | 5 | -5 | 3 | -3
 0 |   | zero  | 5 | -5 | 5 | -5
 0 |   | zero  | 5 | -5 | 5 | -5
 0 |   | zero  | 5 | -5 | 5 | -5
 0 |   | zero  | 5 | -5 | 5 | -5
 0 |   | zero  | 5 | -5 |   |  0
 0 |   | zero  | 5 | -5 |   |  0
 0 |   | zero  |   |  0 | 0 |   
 0 |   | zero  |   |  0 | 1 | -1
 0 |   | zero  |   |  0 | 2 |  2
 0 |   | zero  |   |  0 | 2 |  4
 0 |   | zero  |   |  0 | 3 | -3
 0 |   | zero  |   |  0 | 5 | -5
 0 |   | zero  |   |  0 | 5 | -5
 0 |   | zero  |   |  0 |   |  0
 1 | 4 | one   | 0 |    | 0 |   
 1 | 4 | one   | 0 |    | 1 | -1
 1 | 4 | one   | 0 |    | 2 |  2
 1 | 4 | one   | 0 |    | 2 |  4
 1 | 4 | one   | 0 |    | 3 | -3
 1 | 4 | one   | 0 |    | 5 | -5
 1 | 4 | one   | 0 |    | 5 | -5
 1 | 4 | one   | 0 |    |   |  0
 1 | 4 | one   | 1 | -1 | 0 |   
 1 | 4 | one   | 1 | -1 | 1 | -1
 1 | 4 | one   | 1 | -1 | 2 |  2
 1 | 4 | one   | 1 | -1 | 2 |  4
 1 | 4 | one   | 1 | -1 | 3 | -3
 1 | 4 | one   | 1 | -1 | 5 | -5
 1 | 4 | one   | 1 | -1 | 5 | -5
 1 | 4 | one   | 1 | -1 |   |  0
 1 | 4 | one   | 2 |  2 | 0 |   
 1 | 4 | one   | 2 |  2 | 1 | -1
 1 | 4 | one   | 2 |  2 | 2 |  2
 1 | 4 | one   | 2 |  2 | 2 |  4
 1 | 4 | one   | 2 |  2 | 3 | -3
 1 | 4 | one   | 2 |  2 | 5 | -5
 1 | 4 | one   | 2 |  2 | 5 | -5
 1 | 4 | one   | 2 |  2 |   |  0
 1 | 4 | one   | 2 |  4 | 0 |   
 1 | 4 | one   | 2 |  4 | 1 | -1
 1 | 4 | one   | 2 |  4 | 2 |  2
 1 | 4 | one   | 2 |  4 | 2 |  4
 1 | 4 | one   | 2 |  4 | 3 | -3
 1 | 4 | one   | 2 |  4 | 5 | -5
 1 | 4 | one   | 2 |  4 | 5 | -5
 1 | 4 | one   | 2 |  4 |   |  0
 1 | 4 | one   | 3 | -3 | 0 |   
 1 | 4 | one   | 3 | -3 | 1 | -1
 1 | 4 | one   | 3 | -3 | 2 |  2
 1 | 4 | one   | 3 | -3 | 2 |  4
 1 | 4 | one   | 3 | -3 | 3 | -3
 1 | 4 | one   | 3 | -3 | 5 | -5
 1 | 4 | one   | 3 | -3 | 5 | -5
 1 | 4 | one   | 3 | -3 |   |  0
 1 | 4 | one   | 5 | -5 | 0 |   
 1 | 4 | one   | 5 | -5 | 0 |   
 1 | 4 | one   | 5 | -5 | 1 | -1
 1 | 4 | one   | 5 | -5 | 1 | -1
 1 | 4 | one   | 5 | -5 | 2 |  2
 1 | 4 | one   | 5 | -5 | 2 |  2
 1 | 4 | one   | 5 | -5 | 2 |  4
 1 | 4 | one   | 5 | -5 | 2 |  4
 1 | 4 | one   | 5 | -5 | 3 | -3
 1 | 4 | one   | 5 | -5 | 3 | -3
 1 | 4 | one   | 5 | -5 | 5 | -5
 1 | 4 | one   | 5 | -5 | 5 | -5
 1 | 4 | one   | 5 | -5 | 5 | -5
 1 | 4 | one   | 5 | -5 | 5 | -5
 1 | 4 | one   | 5 | -5 |   |  0
 1 | 4 | one   | 5 | -5 |   |  0
 1 | 4 | one   |   |  0 | 0 |   
 1 | 4 | one   |   |  0 | 1 | -1
 1 | 4 | one   |   |  0 | 2 |  2
 1 | 4 | one   |   |  0 | 2 |  4
 1 | 4 | one   |   |  0 | 3 | -3
 1 | 4 | one   |   |  0 | 5 | -5
 1 | 4 | one   |   |  0 | 5 | -5
 1 | 4 | one   |   |  0 |   |  0
 2 | 3 | two   | 0 |    | 0 |   
 2 | 3 | two   | 0 |    | 1 | -1
 2 | 3 | two   | 0 |    | 2 |  2
 2 | 3 | two   | 0 |    | 2 |  4
 2 | 3 | two   | 0 |    | 3 | -3
 2 | 3 | two   | 0 |    | 5 | -5
 2 | 3 | two   | 0 |    | 5 | -5
 2 | 3 | two   | 0 |    |   |  0
 2 | 3 | two   | 1 | -1 | 0 |   
 2 | 3 | two   | 1 | -1 | 1 | -1
 2 | 3 | two   | 1 | -1 | 2 |  2
 2 | 3 | two   | 1 | -1 | 2 |  4
 2 | 3 | two   | 1 | -1 | 3 | -3
 2 | 3 | two   | 1 | -1 | 5 | -5
 2 | 3 | two   | 1 | -1 | 5 | -5
 2 | 3 | two   | 1 | -1 |   |  0
 2 | 3 | two   | 2 |  2 | 0 |   
 2 | 3 | two   | 2 |  2 | 1 | -1
 2 | 3 | two   | 2 |  2 | 2 |  2
 2 | 3 | two   | 2 |  2 | 2 |  4
 2 | 3 | two   | 2 |  2 | 3 | -3
 2 | 3 | two   | 2 |  2 | 5 | -5
 2 | 3 | two   | 2 |  2 | 5 | -5
 2 | 3 | two   | 2 |  2 |   |  0
 2 | 3 | two   | 2 |  4 | 0 |   
 2 | 3 | two   | 2 |  4 | 1 | -1
 2 | 3 | two   | 2 |  4 | 2 |  2
 2 | 3 | two   | 2 |  4 | 2 |  4
 2 | 3 | two   | 2 |  4 | 3 | -3
 2 | 3 | two   | 2 |  4 | 5 | -5
 2 | 3 | two   | 2 |  4 | 5 | -5
 2 | 3 | two   | 2 |  4 |   |  0
 2 | 3 | two   | 3 | -3 | 0 |   
 2 | 3 | two   | 3 | -3 | 1 | -1
 2 | 3 | two   | 3 | -3 | 2 |  2
 2 | 3 | two   | 3 | -3 | 2 |  4
 2 | 3 | two   | 3 | -3 | 3 | -3
 2 | 3 | two   | 3 | -3 | 5 | -5
 2 | 3 | two   | 3 | -3 | 5 | -5
 2 | 3 | two   | 3 | -3 |   |  0
 2 | 3 | two   | 5 | -5 | 0 |   
 2 | 3 | two   | 5 | -5 | 0 |   
 2 | 3 | two   | 5 | -5 | 1 | -1
 2 | 3 | two   | 5 | -5 | 1 | -1
 2 | 3 | two   | 5 | -5 | 2 |  2
 2 | 3 | two   | 5 | -5 | 2 |  2
 2 | 3 | two   | 5 | -5 | 2 |  4
 2 | 3 | two   | 5 | -5 | 2 |  4
 2 | 3 | two   | 5 | -5 | 3 | -3
 2 | 3 | two   | 5 | -5 | 3 | -3
 2 | 3 | two   | 5 | -5 | 5 | -5
 2 | 3 | two   | 5 | -5 | 5 | -5
 2 | 3 | two   | 5 | -5 | 5 | -5
 2 | 3 | two   | 5 | -5 | 5 | -5
 2 | 3 | two   | 5 | -5 |   |  0
 2 | 3 | two   | 5 | -5 |   |  0
 2 | 3 | two   |   |  0 | 0 |   
 2 | 3 | two   |   |  0 | 1 | -1
 2 | 3 | two   |   |  0 | 2 |  2
 2 | 3 | two   |   |  0 | 2 |  4
 2 | 3 | two   |   |  0 | 3 | -3
 2 | 3 | two   |   |  0 | 5 | -5
 2 | 3 | two   |   |  0 | 5 | -5
 2 | 3 | two   |   |  0 |   |  0
 3 | 2 | three | 0 |    | 0 |   
 3 | 2 | three | 0 |    | 1 | -1
 3 | 2 | three | 0 |    | 2 |  2
 3 | 2 | three | 0 |    | 2 |  4
 3 | 2 | three | 0 |    | 3 | -3
 3 | 2 | three | 0 |    | 5 | -5
 3 | 2 | three | 0 |    | 5 | -5
 3 | 2 | three | 0 |    |   |  0
 3 | 2 | three | 1 | -1 | 0 |   
 3 | 2 | three | 1 | -1 | 1 | -1
 3 | 2 | three | 1 | -1 | 2 |  2
 3 | 2 | three | 1 | -1 | 2 |  4
 3 | 2 | three | 1 | -1 | 3 | -3
 3 | 2 | three | 1 | -1 | 5 | -5
 3 | 2 | three | 1 | -1 | 5 | -5
 3 | 2 | three | 1 | -1 |   |  0
 3 | 2 | three | 2 |  2 | 0 |   
 3 | 2 | three | 2 |  2 | 1 | -1
 3 | 2 | three | 2 |  2 | 2 |  2
 3 | 2 | three | 2 |  2 | 2 |  4
 3 | 2 | three | 2 |  2 | 3 | -3
 3 | 2 | three | 2 |  2 | 5 | -5
 3 | 2 | three | 2 |  2 | 5 | -5
 3 | 2 | three | 2 |  2 |   |  0
 3 | 2 | three | 2 |  4 | 0 |   
 3 | 2 | three | 2 |  4 | 1 | -1
 3 | 2 | three | 2 |  4 | 2 |  2
 3 | 2 | three | 2 |  4 | 2 |  4
 3 | 2 | three | 2 |  4 | 3 | -3
 3 | 2 | three | 2 |  4 | 5 | -5
 3 | 2 | three | 2 |  4 | 5 | -5
 3 | 2 | three | 2 |  4 |   |  0
 3 | 2 | three | 3 | -3 | 0 |   
 3 | 2 | three | 3 | -3 | 1 | -1
 3 | 2 | three | 3 | -3 | 2 |  2
 3 | 2 | three | 3 | -3 | 2 |  4
 3 | 2 | three | 3 | -3 | 3 | -3
 3 | 2 | three | 3 | -3 | 5 | -5
 3 | 2 | three | 3 | -3 | 5 | -5
 3 | 2 | three | 3 | -3 |   |  0
 3 | 2 | three | 5 | -5 | 0 |   
 3 | 2 | three | 5 | -5 | 0 |   
 3 | 2 | three | 5 | -5 | 1 | -1
 3 | 2 | three | 5 | -5 | 1 | -1
 3 | 2 | three | 5 | -5 | 2 |  2
 3 | 2 | three | 5 | -5 | 2 |  2
 3 | 2 | three | 5 | -5 | 2 |  4
 3 | 2 | three | 5 | -5 | 2 |  4
 3 | 2 | three | 5 | -5 | 3 | -3
 3 | 2 | three | 5 | -5 | 3 | -3
 3 | 2 | three | 5 | -5 | 5 | -5
 3 | 2 | three | 5 | -5 | 5 | -5
 3 | 2 | three | 5 | -5 | 5 | -5
 3 | 2 | three | 5 | -5 | 5 | -5
 3 | 2 | three | 5 | -5 |   |  0
 3 | 2 | three | 5 | -5 |   |  0
 3 | 2 | three |   |  0 | 0 |   
 3 | 2 | three |   |  0 | 1 | -1
 3 | 2 | three |   |  0 | 2 |  2
 3 | 2 | three |   |  0 | 2 |  4
 3 | 2 | three |   |  0 | 3 | -3
 3 | 2 | three |   |  0 | 5 | -5
 3 | 2 | three |   |  0 | 5 | -5
 3 | 2 | three |   |  0 |   |  0
 4 | 1 | four  | 0 |    | 0 |   
 4 | 1 | four  | 0 |    | 1 | -1
 4 | 1 | four  | 0 |    | 2 |  2
 4 | 1 | four  | 0 |    | 2 |  4
 4 | 1 | four  | 0 |    | 3 | -3
 4 | 1 | four  | 0 |    | 5 | -5
 4 | 1 | four  | 0 |    | 5 | -5
 4 | 1 | four  | 0 |    |   |  0
 4 | 1 | four  | 1 | -1 | 0 |   
 4 | 1 | four  | 1 | -1 | 1 | -1
 4 | 1 | four  | 1 | -1 | 2 |  2
 4 | 1 | four  | 1 | -1 | 2 |  4
 4 | 1 | four  | 1 | -1 | 3 | -3
 4 | 1 | four  | 1 | -1 | 5 | -5
 4 | 1 | four  | 1 | -1 | 5 | -5
 4 | 1 | four  | 1 | -1 |   |  0
 4 | 1 | four  | 2 |  2 | 0 |   
 4 | 1 | four  | 2 |  2 | 1 | -1
 4 | 1 | four  | 2 |  2 | 2 |  2
 4 | 1 | four  | 2 |  2 | 2 |  4
 4 | 1 | four  | 2 |  2 | 3 | -3
 4 | 1 | four  | 2 |  2 | 5 | -5
 4 | 1 | four  | 2 |  2 | 5 | -5
 4 | 1 | four  | 2 |  2 |   |  0
 4 | 1 | four  | 2 |  4 | 0 |   
 4 | 1 | four  | 2 |  4 | 1 | -1
 4 | 1 | four  | 2 |  4 | 2 |  2
 4 | 1 | four  | 2 |  4 | 2 |  4
 4 | 1 | four  | 2 |  4 | 3 | -3
 4 | 1 | four  | 2 |  4 | 5 | -5
 4 | 1 | four  | 2 |  4 | 5 | -5
 4 | 1 | four  | 2 |  4 |   |  0
 4 | 1 | four  | 3 | -3 | 0 |   
 4 | 1 | four  | 3 | -3 | 1 | -1
 4 | 1 | four  | 3 | -3 | 2 |  2
 4 | 1 | four  | 3 | -3 | 2 |  4
 4 | 1 | four  | 3 | -3 | 3 | -3
 4 | 1 | four  | 3 | -3 | 5 | -5
 4 | 1 | four  | 3 | -3 | 5 | -5
 4 | 1 | four  | 3 | -3 |   |  0
 4 | 1 | four  | 5 | -5 | 0 |   
 4 | 1 | four  | 5 | -5 | 0 |   
 4 | 1 | four  | 5 | -5 | 1 | -1
 4 | 1 | four  | 5 | -5 | 1 | -1
 4 | 1 | four  | 5 | -5 | 2 |  2
 4 | 1 | four  | 5 | -5 | 2 |  2
 4 | 1 | four  | 5 | -5 | 2 |  4
 4 | 1 | four  | 5 | -5 | 2 |  4
 4 | 1 | four  | 5 | -5 | 3 | -3
 4 | 1 | four  | 5 | -5 | 3 | -3
 4 | 1 | four  | 5 | -5 | 5 | -5
 4 | 1 | four  | 5 | -5 | 5 | -5
 4 | 1 | four  | 5 | -5 | 5 | -5
 4 | 1 | four  | 5 | -5 | 5 | -5
 4 | 1 | four  | 5 | -5 |   |  0
 4 | 1 | four  | 5 | -5 |   |  0
 4 | 1 | four  |   |  0 | 0 |   
 4 | 1 | four  |   |  0 | 1 | -1
 4 | 1 | four  |   |  0 | 2 |  2
 4 | 1 | four  |   |  0 | 2 |  4
 4 | 1 | four  |   |  0 | 3 | -3
 4 | 1 | four  |   |  0 | 5 | -5
 4 | 1 | four  |   |  0 | 5 | -5
 4 | 1 | four  |   |  0 |   |  0
 5 | 0 | five  | 0 |    | 0 |   
 5 | 0 | five  | 0 |    | 1 | -1
 5 | 0 | five  | 0 |    | 2 |  2
 5 | 0 | five  | 0 |    | 2 |  4
 5 | 0 | five  | 0 |    | 3 | -3
 5 | 0 | five  | 0 |    | 5 | -5
 5 | 0 | five  | 0 |    | 5 | -5
 5 | 0 | five  | 0 |    |   |  0
 5 | 0 | five  | 1 | -1 | 0 |   
 5 | 0 | five  | 1 | -1 | 1 | -1
 5 | 0 | five  | 1 | -1 | 2 |  2
 5 | 0 | five  | 1 | -1 | 2 |  4
 5 | 0 | five  | 1 | -1 | 3 | -3
 5 | 0 | five  | 1 | -1 | 5 | -5
 5 | 0 | five  | 1 | -1 | 5 | -5
 5 | 0 | five  | 1 | -1 |   |  0
 5 | 0 | five  | 2 |  2 | 0 |   
 5 | 0 | five  | 2 |  2 | 1 | -1
 5 | 0 | five  | 2 |  2 | 2 |  2
 5 | 0 | five  | 2 |  2 | 2 |  4
 5 | 0 | five  | 2 |  2 | 3 | -3
 5 | 0 | five  | 2 |  2 | 5 | -5
 5 | 0 | five  | 2 |  2 | 5 | -5
 5 | 0 | five  | 2 |  2 |   |  0
 5 | 0 | five  | 2 |  4 | 0 |   
 5 | 0 | five  | 2 |  4 | 1 | -1
 5 | 0 | five  | 2 |  4 | 2 |  2
 5 | 0 | five  | 2 |  4 | 2 |  4
 5 | 0 | five  | 2 |  4 | 3 | -3
 5 | 0 | five  | 2 |  4 | 5 | -5
 5 | 0 | five  | 2 |  4 | 5 | -5
 5 | 0 | five  | 2 |  4 |   |  0
 5 | 0 | five  | 3 | -3 | 0 |   
 5 | 0 | five  | 3 | -3 | 1 | -1
 5 | 0 | five  | 3 | -3 | 2 |  2
 5 | 0 | five  | 3 | -3 | 2 |  4
 5 | 0 | five  | 3 | -3 | 3 | -3
 5 | 0 | five  | 3 | -3 | 5 | -5
 5 | 0 | five  | 3 | -3 | 5 | -5
 5 | 0 | five  | 3 | -3 |   |  0
 5 | 0 | five  | 5 | -5 | 0 |   
 5 | 0 | five  | 5 | -5 | 0 |   
 5 | 0 | five  | 5 | -5 | 1 | -1
 5 | 0 | five  | 5 | -5 | 1 | -1
 5 | 0 | five  | 5 | -5 | 2 |  2
 5 | 0 | five  | 5 | -5 | 2 |  2
 5 | 0 | five  | 5 | -5 | 2 |  4
 5 | 0 | five  | 5 | -5 | 2 |  4
 5 | 0 | five  | 5 | -5 | 3 | -3
 5 | 0 | five  | 5 | -5 | 3 | -3
 5 | 0 | five  | 5 | -5 | 5 | -5
 5 | 0 | five  | 5 | -5 | 5 | -5
 5 | 0 | five  | 5 | -5 | 5 | -5
 5 | 0 | five  | 5 | -5 | 5 | -5
 5 | 0 | five  | 5 | -5 |   |  0
 5 | 0 | five  | 5 | -5 |   |  0
 5 | 0 | five  |   |  0 | 0 |   
 5 | 0 | five  |   |  0 | 1 | -1
 5 | 0 | five  |   |  0 | 2 |  2
 5 | 0 | five  |   |  0 | 2 |  4
 5 | 0 | five  |   |  0 | 3 | -3
 5 | 0 | five  |   |  0 | 5 | -5
 5 | 0 | five  |   |  0 | 5 | -5
 5 | 0 | five  |   |  0 |   |  0
 6 | 6 | six   | 0 |    | 0 |   
 6 | 6 | six   | 0 |    | 1 | -1
 6 | 6 | six   | 0 |    | 2 |  2
 6 | 6 | six   | 0 |    | 2 |  4
 6 | 6 | six   | 0 |    | 3 | -3
 6 | 6 | six   | 0 |    | 5 | -5
 6 | 6 | six   | 0 |    | 5 | -5
 6 | 6 | six   | 0 |    |   |  0
 6 | 6 | six   | 1 | -1 | 0 |   
 6 | 6 | six   | 1 | -1 | 1 | -1
 6 | 6 | six   | 1 | -1 | 2 |  2
 6 | 6 | six   | 1 | -1 | 2 |  4
 6 | 6 | six   | 1 | -1 | 3 | -3
 6 | 6 | six   | 1 | -1 | 5 | -5
 6 | 6 | six   | 1 | -1 | 5 | -5
 6 | 6 | six   | 1 | -1 |   |  0
 6 | 6 | six   | 2 |  2 | 0 |   
 6 | 6 | six   | 2 |  2 | 1 | -1
 6 | 6 | six   | 2 |  2 | 2 |  2
 6 | 6 | six   | 2 |  2 | 2 |  4
 6 | 6 | six   | 2 |  2 | 3 | -3
 6 | 6 | six   | 2 |  2 | 5 | -5
 6 | 6 | six   | 2 |  2 | 5 | -5
 6 | 6 | six   | 2 |  2 |   |  0
 6 | 6 | six   | 2 |  4 | 0 |   
 6 | 6 | six   | 2 |  4 | 1 | -1
 6 | 6 | six   | 2 |  4 | 2 |  2
 6 | 6 | six   | 2 |  4 | 2 |  4
 6 | 6 | six   | 2 |  4 | 3 | -3
 6 | 6 | six   | 2 |  4 | 5 | -5
 6 | 6 | six   | 2 |  4 | 5 | -5
 6 | 6 | six   | 2 |  4 |   |  0
 6 | 6 | six   | 3 | -3 | 0 |   
 6 | 6 | six   | 3 | -3 | 1 | -1
 6 | 6 | six   | 3 | -3 | 2 |  2
 6 | 6 | six   | 3 | -3 | 2 |  4
 6 | 6 | six   | 3 | -3 | 3 | -3
 6 | 6 | six   | 3 | -3 | 5 | -5
 6 | 6 | six   | 3 | -3 | 5 | -5
 6 | 6 | six   | 3 | -3 |   |  0
 6 | 6 | six   | 5 | -5 | 0 |   
 6 | 6 | six   | 5 | -5 | 0 |   
 6 | 6 | six   | 5 | -5 | 1 | -1
 6 | 6 | six   | 5 | -5 | 1 | -1
 6 | 6 | six   | 5 | -5 | 2 |  2
 6 | 6 | six   | 5 | -5 | 2 |  2
 6 | 6 | six   | 5 | -5 | 2 |  4
 6 | 6 | six   | 5 | -5 | 2 |  4
 6 | 6 | six   | 5 | -5 | 3 | -3
 6 | 6 | six   | 5 | -5 | 3 | -3
 6 | 6 | six   | 5 | -5 | 5 | -5
 6 | 6 | six   | 5 | -5 | 5 | -5
 6 | 6 | six   | 5 | -5 | 5 | -5
 6 | 6 | six   | 5 | -5 | 5 | -5
 6 | 6 | six   | 5 | -5 |   |  0
 6 | 6 | six   | 5 | -5 |   |  0
 6 | 6 | six   |   |  0 | 0 |   
 6 | 6 | six   |   |  0 | 1 | -1
 6 | 6 | six   |   |  0 | 2 |  2
 6 | 6 | six   |   |  0 | 2 |  4
 6 | 6 | six   |   |  0 | 3 | -3
 6 | 6 | six   |   |  0 | 5 | -5
 6 | 6 | six   |   |  0 | 5 | -5
 6 | 6 | six   |   |  0 |   |  0
 7 | 7 | seven | 0 |    | 0 |   
 7 | 7 | seven | 0 |    | 1 | -1
 7 | 7 | seven | 0 |    | 2 |  2
 7 | 7 | seven | 0 |    | 2 |  4
 7 | 7 | seven | 0 |    | 3 | -3
 7 | 7 | seven | 0 |    | 5 | -5
 7 | 7 | seven | 0 |    | 5 | -5
 7 | 7 | seven | 0 |    |   |  0
 7 | 7 | seven | 1 | -1 | 0 |   
 7 | 7 | seven | 1 | -1 | 1 | -1
 7 | 7 | seven | 1 | -1 | 2 |  2
 7 | 7 | seven | 1 | -1 | 2 |  4
 7 | 7 | seven | 1 | -1 | 3 | -3
 7 | 7 | seven | 1 | -1 | 5 | -5
 7 | 7 | seven | 1 | -1 | 5 | -5
 7 | 7 | seven | 1 | -1 |   |  0
 7 | 7 | seven | 2 |  2 | 0 |   
 7 | 7 | seven | 2 |  2 | 1 | -1
 7 | 7 | seven | 2 |  2 | 2 |  2
 7 | 7 | seven | 2 |  2 | 2 |  4
 7 | 7 | seven | 2 |  2 | 3 | -3
 7 | 7 | seven | 2 |  2 | 5 | -5
 7 | 7 | seven | 2 |  2 | 5 | -5
 7 | 7 | seven | 2 |  2 |   |  0
 7 | 7 | seven | 2 |  4 | 0 |   
 7 | 7 | seven | 2 |  4 | 1 | -1
 7 | 7 | seven | 2 |  4 | 2 |  2
 7 | 7 | seven | 2 |  4 | 2 |  4
 7 | 7 | seven | 2 |  4 | 3 | -3
 7 | 7 | seven | 2 |  4 | 5 | -5
 7 | 7 | seven | 2 |  4 | 5 | -5
 7 | 7 | seven | 2 |  4 |   |  0
 7 | 7 | seven | 3 | -3 | 0 |   
 7 | 7 | seven | 3 | -3 | 1 | -1
 7 | 7 | seven | 3 | -3 | 2 |  2
 7 | 7 | seven | 3 | -3 | 2 |  4
 7 | 7 | seven | 3 | -3 | 3 | -3
 7 | 7 | seven | 3 | -3 | 5 | -5
 7 | 7 | seven | 3 | -3 | 5 | -5
 7 | 7 | seven | 3 | -3 |   |  0
 7 | 7 | seven | 5 | -5 | 0 |   
 7 | 7 | seven | 5 | -5 | 0 |   
 7 | 7 | seven | 5 | -5 | 1 | -1
 7 | 7 | seven | 5 | -5 | 1 | -1
 7 | 7 | seven | 5 | -5 | 2 |  2
 7 | 7 | seven | 5 | -5 | 2 |  2
 7 | 7 | seven | 5 | -5 | 2 |  4
 7 | 7 | seven | 5 | -5 | 2 |  4
 7 | 7 | seven | 5 | -5 | 3 | -3
 7 | 7 | seven | 5 | -5 | 3 | -3
 7 | 7 | seven | 5 | -5 | 5 | -5
 7 | 7 | seven | 5 | -5 | 5 | -5
 7 | 7 | seven | 5 | -5 | 5 | -5
 7 | 7 | seven | 5 | -5 | 5 | -5
 7 | 7 | seven | 5 | -5 |   |  0
 7 | 7 | seven | 5 | -5 |   |  0
 7 | 7 | seven |   |  0 | 0 |   
 7 | 7 | seven |   |  0 | 1 | -1
 7 | 7 | seven |   |  0 | 2 |  2
 7 | 7 | seven |   |  0 | 2 |  4
 7 | 7 | seven |   |  0 | 3 | -3
 7 | 7 | seven |   |  0 | 5 | -5
 7 | 7 | seven |   |  0 | 5 | -5
 7 | 7 | seven |   |  0 |   |  0
 8 | 8 | eight | 0 |    | 0 |   
 8 | 8 | eight | 0 |    | 1 | -1
 8 | 8 | eight | 0 |    | 2 |  2
 8 | 8 | eight | 0 |    | 2 |  4
 8 | 8 | eight | 0 |    | 3 | -3
 8 | 8 | eight | 0 |    | 5 | -5
 8 | 8 | eight | 0 |    | 5 | -5
 8 | 8 | eight | 0 |    |   |  0
 8 | 8 | eight | 1 | -1 | 0 |   
 8 | 8 | eight | 1 | -1 | 1 | -1
 8 | 8 | eight | 1 | -1 | 2 |  2
 8 | 8 | eight | 1 | -1 | 2 |  4
 8 | 8 | eight | 1 | -1 | 3 | -3
 8 | 8 | eight | 1 | -1 | 5 | -5
 8 | 8 | eight | 1 | -1 | 5 | -5
 8 | 8 | eight | 1 | -1 |   |  0
 8 | 8 | eight | 2 |  2 | 0 |   
 8 | 8 | eight | 2 |  2 | 1 | -1
 8 | 8 | eight | 2 |  2 | 2 |  2
 8 | 8 | eight | 2 |  2 | 2 |  4
 8 | 8 | eight | 2 |  2 | 3 | -3
 8 | 8 | eight | 2 |  2 | 5 | -5
 8 | 8 | eight | 2 |  2 | 5 | -5
 8 | 8 | eight | 2 |  2 |   |  0
 8 | 8 | eight | 2 |  4 | 0 |   
 8 | 8 | eight | 2 |  4 | 1 | -1
 8 | 8 | eight | 2 |  4 | 2 |  2
 8 | 8 | eight | 2 |  4 | 2 |  4
 8 | 8 | eight | 2 |  4 | 3 | -3
 8 | 8 | eight | 2 |  4 | 5 | -5
 8 | 8 | eight | 2 |  4 | 5 | -5
 8 | 8 | eight | 2 |  4 |   |  0
 8 | 8 | eight | 3 | -3 | 0 |   
 8 | 8 | eight | 3 | -3 | 1 | -1
 8 | 8 | eight | 3 | -3 | 2 |  2
 8 | 8 | eight | 3 | -3 | 2 |  4
 8 | 8 | eight | 3 | -3 | 3 | -3
 8 | 8 | eight | 3 | -3 | 5 | -5
 8 | 8 | eight | 3 | -3 | 5 | -5
 8 | 8 | eight | 3 | -3 |   |  0
 8 | 8 | eight | 5 | -5 | 0 |   
 8 | 8 | eight | 5 | -5 | 0 |   
 8 | 8 | eight | 5 | -5 | 1 | -1
 8 | 8 | eight | 5 | -5 | 1 | -1
 8 | 8 | eight | 5 | -5 | 2 |  2
 8 | 8 | eight | 5 | -5 | 2 |  2
 8 | 8 | eight | 5 | -5 | 2 |  4
 8 | 8 | eight | 5 | -5 | 2 |  4
 8 | 8 | eight | 5 | -5 | 3 | -3
 8 | 8 | eight | 5 | -5 | 3 | -3
 8 | 8 | eight | 5 | -5 | 5 | -5
 8 | 8 | eight | 5 | -5 | 5 | -5
 8 | 8 | eight | 5 | -5 | 5 | -5
 8 | 8 | eight | 5 | -5 | 5 | -5
 8 | 8 | eight | 5 | -5 |   |  0
 8 | 8 | eight | 5 | -5 |   |  0
 8 | 8 | eight |   |  0 | 0 |   
 8 | 8 | eight |   |  0 | 1 | -1
 8 | 8 | eight |   |  0 | 2 |  2
 8 | 8 | eight |   |  0 | 2 |  4
 8 | 8 | eight |   |  0 | 3 | -3
 8 | 8 | eight |   |  0 | 5 | -5
 8 | 8 | eight |   |  0 | 5 | -5
 8 | 8 | eight |   |  0 |   |  0
   | 0 | zero  | 0 |    | 0 |   
   | 0 | zero  | 0 |    | 1 | -1
   | 0 | zero  | 0 |    | 2 |  2
   | 0 | zero  | 0 |    | 2 |  4
   | 0 | zero  | 0 |    | 3 | -3
   | 0 | zero  | 0 |    | 5 | -5
   | 0 | zero  | 0 |    | 5 | -5
   | 0 | zero  | 0 |    |   |  0
   | 0 | zero  | 1 | -1 | 0 |   
   | 0 | zero  | 1 | -1 | 1 | -1
   | 0 | zero  | 1 | -1 | 2 |  2
   | 0 | zero  | 1 | -1 | 2 |  4
   | 0 | zero  | 1 | -1 | 3 | -3
   | 0 | zero  | 1 | -1 | 5 | -5
   | 0 | zero  | 1 | -1 | 5 | -5
   | 0 | zero  | 1 | -1 |   |  0
   | 0 | zero  | 2 |  2 | 0 |   
   | 0 | zero  | 2 |  2 | 1 | -1
   | 0 | zero  | 2 |  2 | 2 |  2
   | 0 | zero  | 2 |  2 | 2 |  4
   | 0 | zero  | 2 |  2 | 3 | -3
   | 0 | zero  | 2 |  2 | 5 | -5
   | 0 | zero  | 2 |  2 | 5 | -5
   | 0 | zero  | 2 |  2 |   |  0
   | 0 | zero  | 2 |  4 | 0 |   
   | 0 | zero  | 2 |  4 | 1 | -1
   | 0 | zero  | 2 |  4 | 2 |  2
   | 0 | zero  | 2 |  4 | 2 |  4
   | 0 | zero  | 2 |  4 | 3 | -3
   | 0 | zero  | 2 |  4 | 5 | -5
   | 0 | zero  | 2 |  4 | 5 | -5
   | 0 | zero  | 2 |  4 |   |  0
   | 0 | zero  | 3 | -3 | 0 |   
   | 0 | zero  | 3 | -3 | 1 | -1
   | 0 | zero  | 3 | -3 | 2 |  2
   | 0 | zero  | 3 | -3 | 2 |  4
   | 0 | zero  | 3 | -3 | 3 | -3
   | 0 | zero  | 3 | -3 | 5 | -5
   | 0 | zero  | 3 | -3 | 5 | -5
   | 0 | zero  | 3 | -3 |   |  0
   | 0 | zero  | 5 | -5 | 0 |   
   | 0 | zero  | 5 | -5 | 0 |   
   | 0 | zero  | 5 | -5 | 1 | -1
   | 0 | zero  | 5 | -5 | 1 | -1
   | 0 | zero  | 5 | -5 | 2 |  2
   | 0 | zero  | 5 | -5 | 2 |  2
   | 0 | zero  | 5 | -5 | 2 |  4
   | 0 | zero  | 5 | -5 | 2 |  4
   | 0 | zero  | 5 | -5 | 3 | -3
   | 0 | zero  | 5 | -5 | 3 | -3
   | 0 | zero  | 5 | -5 | 5 | -5
   | 0 | zero  | 5 | -5 | 5 | -5
   | 0 | zero  | 5 | -5 | 5 | -5
   | 0 | zero  | 5 | -5 | 5 | -5
   | 0 | zero  | 5 | -5 |   |  0
   | 0 | zero  | 5 | -5 |   |  0
   | 0 | zero  |   |  0 | 0 |   
   | 0 | zero  |   |  0 | 1 | -1
   | 0 | zero  |   |  0 | 2 |  2
   | 0 | zero  |   |  0 | 2 |  4
   | 0 | zero  |   |  0 | 3 | -3
   | 0 | zero  |   |  0 | 5 | -5
   | 0 | zero  |   |  0 | 5 | -5
   | 0 | zero  |   |  0 |   |  0
   |   | null  | 0 |    | 0 |   
   |   | null  | 0 |    | 1 | -1
   |   | null  | 0 |    | 2 |  2
   |   | null  | 0 |    | 2 |  4
   |   | null  | 0 |    | 3 | -3
   |   | null  | 0 |    | 5 | -5
   |   | null  | 0 |    | 5 | -5
   |   | null  | 0 |    |   |  0
   |   | null  | 1 | -1 | 0 |   
   |   | null  | 1 | -1 | 1 | -1
   |   | null  | 1 | -1 | 2 |  2
   |   | null  | 1 | -1 | 2 |  4
   |   | null  | 1 | -1 | 3 | -3
   |   | null  | 1 | -1 | 5 | -5
   |   | null  | 1 | -1 | 5 | -5
   |   | null  | 1 | -1 |   |  0
   |   | null  | 2 |  2 | 0 |   
   |   | null  | 2 |  2 | 1 | -1
   |   | null  | 2 |  2 | 2 |  2
   |   | null  | 2 |  2 | 2 |  4
   |   | null  | 2 |  2 | 3 | -3
   |   | null  | 2 |  2 | 5 | -5
   |   | null  | 2 |  2 | 5 | -5
   |   | null  | 2 |  2 |   |  0
   |   | null  | 2 |  4 | 0 |   
   |   | null  | 2 |  4 | 1 | -1
   |   | null  | 2 |  4 | 2 |  2
   |   | null  | 2 |  4 | 2 |  4
   |   | null  | 2 |  4 | 3 | -3
   |   | null  | 2 |  4 | 5 | -5
   |   | null  | 2 |  4 | 5 | -5
   |   | null  | 2 |  4 |   |  0
   |   | null  | 3 | -3 | 0 |   
   |   | null  | 3 | -3 | 1 | -1
   |   | null  | 3 | -3 | 2 |  2
   |   | null  | 3 | -3 | 2 |  4
   |   | null  | 3 | -3 | 3 | -3
   |   | null  | 3 | -3 | 5 | -5
   |   | null  | 3 | -3 | 5 | -5
   |   | null  | 3 | -3 |   |  0
   |   | null  | 5 | -5 | 0 |   
   |   | null  | 5 | -5 | 0 |   
   |   | null  | 5 | -5 | 1 | -1
   |   | null  | 5 | -5 | 1 | -1
   |   | null  | 5 | -5 | 2 |  2
   |   | null  | 5 | -5 | 2 |  2
   |   | null  | 5 | -5 | 2 |  4
   |   | null  | 5 | -5 | 2 |  4
   |   | null  | 5 | -5 | 3 | -3
   |   | null  | 5 | -5 | 3 | -3
   |   | null  | 5 | -5 | 5 | -5
   |   | null  | 5 | -5 | 5 | -5
   |   | null  | 5 | -5 | 5 | -5
   |   | null  | 5 | -5 | 5 | -5
   |   | null  | 5 | -5 |   |  0
   |   | null  | 5 | -5 |   |  0
   |   | null  |   |  0 | 0 |   
   |   | null  |   |  0 | 1 | -1
   |   | null  |   |  0 | 2 |  2
   |   | null  |   |  0 | 2 |  4
   |   | null  |   |  0 | 3 | -3
   |   | null  |   |  0 | 5 | -5
   |   | null  |   |  0 | 5 | -5
   |   | null  |   |  0 |   |  0
(704 rows)

--
--
-- Inner joins (equi-joins)
--
--
--
-- Inner joins (equi-joins) with USING clause
-- The USING syntax changes the shape of the resulting table
-- by including a column in the USING clause only once in the result.
--
-- Inner equi-join on specified column
--Testcase 45:
SELECT *
  FROM (SELECT (fields->>'i')::int i,(fields->>'j')::int j,fields->>'t' t FROM J1_TBL) J1_TBL INNER JOIN (SELECT (fields->>'i')::int i,(fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i);
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 5 | 0 | five  | -5
 5 | 0 | five  | -5
(7 rows)

-- Same as above, slightly different syntax
--Testcase 46:
SELECT *
  FROM (SELECT (fields->>'i')::int i,(fields->>'j')::int j,fields->>'t' t FROM J1_TBL) J1_TBL JOIN (SELECT (fields->>'i')::int i,(fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i);
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 5 | 0 | five  | -5
 5 | 0 | five  | -5
(7 rows)

--Testcase 47:
SELECT *
  FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) t1 (a, b, c) JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) t2 (a, d) USING (a)
  ORDER BY a, d;
 a | b |   c   | d  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 5 | 0 | five  | -5
 5 | 0 | five  | -5
(7 rows)

--Testcase 48:
SELECT *
  FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) t1 (a, b, c) JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) t2 (a, b) USING (b)
  ORDER BY b, t1.a;
 b | a |   c   | a 
---+---+-------+---
 0 | 5 | five  |  
 0 |   | zero  |  
 2 | 3 | three | 2
 4 | 1 | one   | 2
(4 rows)

-- test join using aliases
--Testcase 49:
SELECT * FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) J1_TBL JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i) WHERE J1_TBL.t = 'one';  -- ok
 i | j |  t  | k  
---+---+-----+----
 1 | 4 | one | -1
(1 row)

--Testcase 50:
SELECT * FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) J1_TBL JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';  -- ok
 i | j |  t  | k  
---+---+-----+----
 1 | 4 | one | -1
(1 row)

--Testcase 51:
SELECT * FROM ((SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) J1_TBL JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i)) AS x WHERE J1_TBL.t = 'one';  -- error
ERROR:  invalid reference to FROM-clause entry for table "j1_tbl"
LINE 1: ...::int k FROM J2_TBL) J2_TBL USING (i)) AS x WHERE J1_TBL.t =...
                                                             ^
HINT:  There is an entry for table "j1_tbl", but it cannot be referenced from this part of the query.
--Testcase 52:
SELECT * FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) J1_TBL JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i) AS x WHERE x.i::int = 1;  -- ok
 i | j |  t  | k  
---+---+-----+----
 1 | 4 | one | -1
(1 row)

--Testcase 53:
SELECT * FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) J1_TBL JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i) AS x WHERE x.t = 'one';  -- error
ERROR:  column x.t does not exist
LINE 1: ...)::int k FROM J2_TBL) J2_TBL USING (i) AS x WHERE x.t = 'one...
                                                             ^
--Testcase 54:
SELECT * FROM ((SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) J1_TBL JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i) AS x) AS xx WHERE x.i::int = 1;  -- error (XXX could use better hint)
ERROR:  missing FROM-clause entry for table "x"
LINE 1: ...k FROM J2_TBL) J2_TBL USING (i) AS x) AS xx WHERE x.i::int =...
                                                             ^
--Testcase 55:
SELECT * FROM (SELECT (fields->>'i')::int i,(fields->>'j')::int j,fields->>'t' t FROM J1_TBL) a1 JOIN (SELECT (fields->>'i')::int i,(fields->>'k')::int k FROM J2_TBL) a2 USING (i) AS a1;  -- error
ERROR:  table name "a1" specified more than once
--Testcase 56:
SELECT x.* FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) J1_TBL JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';
 i 
---
 1
(1 row)

--Testcase 57:
SELECT ROW(x.*) FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) J1_TBL JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';
 row 
-----
 (1)
(1 row)

--Testcase 58:
SELECT row_to_json(x.*) FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) J1_TBL JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';
 row_to_json 
-------------
 {"i":1}
(1 row)

--
-- NATURAL JOIN
-- Inner equi-join on all columns with the same name
--
--Testcase 59:
SELECT *
  FROM (SELECT (fields->>'i')::int i,(fields->>'j')::int j,fields->>'t' t FROM J1_TBL) J1_TBL NATURAL JOIN (SELECT (fields->>'i')::int i,(fields->>'k')::int k FROM J2_TBL) J2_TBL;
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 5 | 0 | five  | -5
 5 | 0 | five  | -5
(7 rows)

--Testcase 60:
SELECT *
  FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) t1 (a, b, c) NATURAL JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) t2 (a, d);
 a | b |   c   | d  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 5 | 0 | five  | -5
 5 | 0 | five  | -5
(7 rows)

--Testcase 61:
SELECT *
  FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j, fields->>'t' t FROM J1_TBL) t1 (a, b, c) NATURAL JOIN (SELECT (fields->>'i')::int i, (fields->>'k')::int k FROM J2_TBL) t2 (d, a);
 a | b |  c   | d 
---+---+------+---
 0 |   | zero |  
 2 | 3 | two  | 2
 4 | 1 | four | 2
(3 rows)

-- mismatch number of columns
-- currently, Postgres will fill in with underlying names
--Testcase 62:
SELECT *
  FROM (SELECT (fields->>'i')::int i,(fields->>'j')::int j,fields->>'t' t FROM J1_TBL) t1 (a, b) NATURAL JOIN (SELECT (fields->>'i')::int i,(fields->>'k')::int k FROM J2_TBL) t2 (a);
 a | b |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 5 | 0 | five  | -5
 5 | 0 | five  | -5
(7 rows)

--
-- Inner joins (equi-joins)
--
--Testcase 63:
SELECT *
  FROM (SELECT (fields->>'i')::int i,(fields->>'j')::int j,fields->>'t' t FROM J1_TBL) J1_TBL JOIN (select (fields->>'i')::int i, (fields->>'k')::int k from J2_TBL) J2_TBL ON ((J1_TBL.i)::bigint = (J2_TBL.i)::bigint);
 i | j |   t   | i | k  
---+---+-------+---+----
 0 |   | zero  | 0 |   
 1 | 4 | one   | 1 | -1
 2 | 3 | two   | 2 |  2
 2 | 3 | two   | 2 |  4
 3 | 2 | three | 3 | -3
 5 | 0 | five  | 5 | -5
 5 | 0 | five  | 5 | -5
(7 rows)

--Testcase 64:
SELECT *
  FROM (SELECT (fields->>'i')::int i,(fields->>'j')::int j,fields->>'t' t FROM J1_TBL) J1_TBL JOIN (select (fields->>'i')::int i, (fields->>'k')::int k from J2_TBL) J2_TBL ON ((J1_TBL.i)::bigint = (J2_TBL.k)::bigint);
 i | j |  t   | i | k 
---+---+------+---+---
 0 |   | zero |   | 0
 2 | 3 | two  | 2 | 2
 4 | 1 | four | 2 | 4
(3 rows)

--
-- Non-equi-joins
--
--Testcase 65:
SELECT *
  FROM (select (fields->>'i')::int i, (fields->>'j')::int j,fields->>'t' t from J1_TBL) J1_TBL JOIN (select (fields->>'i')::int i, (fields->>'k')::int k from J2_TBL) J2_TBL ON ((J1_TBL.i)::bigint <= (J2_TBL.k)::bigint) ORDER BY J1_TBL.i, J1_TBL.j, J1_TBL.t, J2_TBL.i, J2_TBL.k;
 i | j |   t   | i | k 
---+---+-------+---+---
 0 |   | zero  | 2 | 2
 0 |   | zero  | 2 | 4
 0 |   | zero  |   | 0
 1 | 4 | one   | 2 | 2
 1 | 4 | one   | 2 | 4
 2 | 3 | two   | 2 | 2
 2 | 3 | two   | 2 | 4
 3 | 2 | three | 2 | 4
 4 | 1 | four  | 2 | 4
(9 rows)

--
-- Outer joins
-- Note that OUTER is a noise word
--
--Testcase 66:
SELECT *
  FROM (SELECT (fields->>'i')::int i, (fields->>'j')::int j ,fields->>'t' t FROM J1_TBL) J1_TBL LEFT OUTER JOIN (SELECT (fields->>'i')::int i,(fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i)
  ORDER BY i, k, t;
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 4 | 1 | four  |   
 5 | 0 | five  | -5
 5 | 0 | five  | -5
 6 | 6 | six   |   
 7 | 7 | seven |   
 8 | 8 | eight |   
   |   | null  |   
   | 0 | zero  |   
(13 rows)

--Testcase 67:
SELECT *
  FROM (SELECT (fields->>'i')::int i,(fields->>'j')::int j,fields->>'t' t FROM J1_TBL) J1_TBL LEFT JOIN (SELECT (fields->>'i')::int i,(fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i)
  ORDER BY i::int, k, t;
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 4 | 1 | four  |   
 5 | 0 | five  | -5
 5 | 0 | five  | -5
 6 | 6 | six   |   
 7 | 7 | seven |   
 8 | 8 | eight |   
   |   | null  |   
   | 0 | zero  |   
(13 rows)

--Testcase 68:
SELECT *
  FROM (SELECT (fields->>'i')::int i,(fields->>'j')::int j,fields->>'t' t FROM J1_TBL) J1_TBL RIGHT OUTER JOIN (SELECT (fields->>'i')::int i,(fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i);
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 5 | 0 | five  | -5
 5 | 0 | five  | -5
   |   |       |  0
(8 rows)

--Testcase 69:
SELECT *
  FROM (SELECT (fields->>'i')::int i,(fields->>'j')::int j,fields->>'t' t FROM J1_TBL) J1_TBL RIGHT JOIN (SELECT (fields->>'i')::int i,(fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i);
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 5 | 0 | five  | -5
 5 | 0 | five  | -5
   |   |       |  0
(8 rows)

--Testcase 70:
SELECT *
  FROM (SELECT (fields->>'i')::int i,(fields->>'j')::int j,fields->>'t' t FROM J1_TBL) J1_TBL FULL OUTER JOIN (SELECT (fields->>'i')::int i,(fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i)
  ORDER BY i::int, k, t;
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 4 | 1 | four  |   
 5 | 0 | five  | -5
 5 | 0 | five  | -5
 6 | 6 | six   |   
 7 | 7 | seven |   
 8 | 8 | eight |   
   |   |       |  0
   |   | null  |   
   | 0 | zero  |   
(14 rows)

--Testcase 71:
SELECT *
  FROM (SELECT (fields->>'i')::int i,(fields->>'j')::int j,fields->>'t' t FROM J1_TBL) J1_TBL FULL JOIN (SELECT (fields->>'i')::int i,(fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i)
  ORDER BY i::int, k, t;
 i | j |   t   | k  
---+---+-------+----
 0 |   | zero  |   
 1 | 4 | one   | -1
 2 | 3 | two   |  2
 2 | 3 | two   |  4
 3 | 2 | three | -3
 4 | 1 | four  |   
 5 | 0 | five  | -5
 5 | 0 | five  | -5
 6 | 6 | six   |   
 7 | 7 | seven |   
 8 | 8 | eight |   
   |   |       |  0
   |   | null  |   
   | 0 | zero  |   
(14 rows)

--Testcase 72:
SELECT *
  FROM (SELECT (fields->>'i')::int i,(fields->>'j')::int j,fields->>'t' t FROM J1_TBL) J1_TBL LEFT JOIN (SELECT (fields->>'i')::int i,(fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i) WHERE (k)::int = 1;
 i | j | t | k 
---+---+---+---
(0 rows)

--Testcase 73:
SELECT *
  FROM (SELECT (fields->>'i')::int i,(fields->>'j')::int j,fields->>'t' t FROM J1_TBL) J1_TBL LEFT JOIN (SELECT (fields->>'i')::int i,(fields->>'k')::int k FROM J2_TBL) J2_TBL USING (i) WHERE (i)::int = 1;
 i | j |  t  | k  
---+---+-----+----
 1 | 4 | one | -1
(1 row)

--
-- semijoin selectivity for <>
--
--Testcase 74:
explain (costs off)
select * from (select (fields->>'f1')::int4 f1 from INT4_TBL i4) i4, (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 a) a
where exists(select * from (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 b) b
             where (a.twothousand)::int4 = (b.twothousand)::int4 and (a.fivethous)::int4 <> (b.fivethous)::int4)
      and (i4.f1)::int4 = (a.tenthous)::int4;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Merge Cond: ((((a.fields ->> 'tenthous'::text))::integer) = (((i4.fields ->> 'f1'::text))::integer))
   ->  Sort
         Sort Key: (((a.fields ->> 'tenthous'::text))::integer)
         ->  Hash Semi Join
               Hash Cond: (((a.fields ->> 'twothousand'::text))::integer = ((b.fields ->> 'twothousand'::text))::integer)
               Join Filter: (((a.fields ->> 'fivethous'::text))::integer <> ((b.fields ->> 'fivethous'::text))::integer)
               ->  Foreign Scan on tenk1 a
               ->  Hash
                     ->  Foreign Scan on tenk1 b
   ->  Sort
         Sort Key: (((i4.fields ->> 'f1'::text))::integer)
         ->  Foreign Scan on int4_tbl i4
(13 rows)

--
-- More complicated constructs
--
--
-- Multiway full join
--
--Testcase 75:
CREATE FOREIGN TABLE t1 (fields jsonb OPTIONS (fields 'true')) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 577:
CREATE FOREIGN TABLE t1_nsc (name TEXT, n INTEGER) SERVER influxdb_svr OPTIONS (table 't1');
--Testcase 76:
CREATE FOREIGN TABLE t2 (fields jsonb OPTIONS (fields 'true')) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 578:
CREATE FOREIGN TABLE t2_nsc (name TEXT, n INTEGER) SERVER influxdb_svr OPTIONS (table 't2');
--Testcase 77:
CREATE FOREIGN TABLE t3 (fields jsonb OPTIONS (fields 'true')) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 579:
CREATE FOREIGN TABLE t3_nsc (name TEXT, n INTEGER) SERVER influxdb_svr OPTIONS (table 't3');
--Testcase 78:
INSERT INTO t1_nsc VALUES ( 'bb', 11 );
--Testcase 79:
INSERT INTO t2_nsc VALUES ( 'bb', 12 );
--Testcase 80:
INSERT INTO t2_nsc VALUES ( 'cc', 22 );
--Testcase 81:
INSERT INTO t2_nsc VALUES ( 'ee', 42 );
--Testcase 82:
INSERT INTO t3_nsc VALUES ( 'bb', 13 );
--Testcase 83:
INSERT INTO t3_nsc VALUES ( 'cc', 23 );
--Testcase 84:
INSERT INTO t3_nsc VALUES ( 'dd', 33 );
--Testcase 85:
SELECT * FROM (select fields->>'name' "name", (fields->>'n')::int n from t1) t1 FULL JOIN (select fields->>'name' "name", (fields->>'n')::int n from t2) t2 USING (name) FULL JOIN (select fields->>'name' "name", (fields->>'n')::int n from t3) t3 USING (name);
 name | n  | n  | n  
------+----+----+----
 bb   | 11 | 12 | 13
 cc   |    | 22 | 23
 dd   |    |    | 33
 ee   |    | 42 |   
(4 rows)

--
-- Test interactions of join syntax and subqueries
--
-- Basic cases (we expect planner to pull up the subquery here)
--Testcase 86:
SELECT * FROM
(SELECT * FROM (select fields->>'name' "name", (fields->>'n')::int n from t2) t2) as s2
INNER JOIN
(SELECT * FROM (select fields->>'name' "name", (fields->>'n')::int n from t3) t3) s3
USING (name);
 name | n  | n  
------+----+----
 bb   | 12 | 13
 cc   | 22 | 23
(2 rows)

--Testcase 87:
SELECT * FROM
(SELECT * FROM (select fields->>'name' "name", (fields->>'n')::int n from t2) t2) as s2
LEFT JOIN
(SELECT * FROM (select fields->>'name' "name", (fields->>'n')::int n from t3) t3) s3
USING (name);
 name | n  | n  
------+----+----
 bb   | 12 | 13
 cc   | 22 | 23
 ee   | 42 |   
(3 rows)

--Testcase 88:
SELECT * FROM
(SELECT * FROM (select fields->>'name' "name", (fields->>'n')::int n from t2) t2) as s2
FULL JOIN
(SELECT * FROM (select fields->>'name' "name", (fields->>'n')::int n from t3) t3) s3
USING (name);
 name | n  | n  
------+----+----
 bb   | 12 | 13
 cc   | 22 | 23
 dd   |    | 33
 ee   | 42 |   
(4 rows)

-- Cases with non-nullable expressions in subquery results;
-- make sure these go to null as expected
--Testcase 89:
SELECT * FROM
(SELECT fields->>'name' "name", (fields->>'n')::int as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL INNER JOIN
(SELECT fields->>'name' "name", (fields->>'n')::int as s3_n, 3 as s3_2 FROM t3) s3;
 name | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------
 bb   |   12 |    2 |   13 |    3
 cc   |   22 |    2 |   23 |    3
(2 rows)

--Testcase 90:
SELECT * FROM
(SELECT fields->>'name' "name", (fields->>'n')::int as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL LEFT JOIN
(SELECT fields->>'name' "name", (fields->>'n')::int as s3_n, 3 as s3_2 FROM t3) s3;
 name | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------
 bb   |   12 |    2 |   13 |    3
 cc   |   22 |    2 |   23 |    3
 ee   |   42 |    2 |      |     
(3 rows)

--Testcase 91:
SELECT * FROM
(SELECT fields->>'name' "name", (fields->>'n')::int as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL FULL JOIN
(SELECT fields->>'name' "name", (fields->>'n')::int as s3_n, 3 as s3_2 FROM t3) s3;
 name | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------
 bb   |   12 |    2 |   13 |    3
 cc   |   22 |    2 |   23 |    3
 dd   |      |      |   33 |    3
 ee   |   42 |    2 |      |     
(4 rows)

--Testcase 92:
SELECT * FROM
(SELECT fields->>'name' "name", (fields->>'n')::int as s1_n, 1 as s1_1 FROM t1) as s1
NATURAL INNER JOIN
(SELECT fields->>'name' "name", (fields->>'n')::int as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL INNER JOIN
(SELECT fields->>'name' "name", (fields->>'n')::int as s3_n, 3 as s3_2 FROM t3) s3;
 name | s1_n | s1_1 | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------+------+------
 bb   |   11 |    1 |   12 |    2 |   13 |    3
(1 row)

--Testcase 93:
SELECT * FROM
(SELECT fields->>'name' "name", (fields->>'n')::int as s1_n, 1 as s1_1 FROM t1) as s1
NATURAL FULL JOIN
(SELECT fields->>'name' "name", (fields->>'n')::int as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL FULL JOIN
(SELECT fields->>'name' "name", (fields->>'n')::int as s3_n, 3 as s3_2 FROM t3) s3;
 name | s1_n | s1_1 | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------+------+------
 bb   |   11 |    1 |   12 |    2 |   13 |    3
 cc   |      |      |   22 |    2 |   23 |    3
 dd   |      |      |      |      |   33 |    3
 ee   |      |      |   42 |    2 |      |     
(4 rows)

--Testcase 94:
SELECT * FROM
(SELECT fields->>'name' "name", (fields->>'n')::int as s1_n FROM t1) as s1
NATURAL FULL JOIN
  (SELECT * FROM
    (SELECT fields->>'name' "name", (fields->>'n')::int as s2_n FROM t2) as s2
    NATURAL FULL JOIN
    (SELECT fields->>'name' "name", (fields->>'n')::int as s3_n FROM t3) as s3
  ) ss2;
 name | s1_n | s2_n | s3_n 
------+------+------+------
 bb   |   11 |   12 |   13
 cc   |      |   22 |   23
 dd   |      |      |   33
 ee   |      |   42 |     
(4 rows)

--Testcase 95:
SELECT * FROM
(SELECT fields->>'name' "name", (fields->>'n')::int as s1_n FROM t1) as s1
NATURAL FULL JOIN
  (SELECT * FROM
    (SELECT fields->>'name' "name", (fields->>'n')::int as s2_n, 2 as s2_2 FROM t2) as s2
    NATURAL FULL JOIN
    (SELECT fields->>'name' "name", (fields->>'n')::int as s3_n FROM t3) as s3
  ) ss2;
 name | s1_n | s2_n | s2_2 | s3_n 
------+------+------+------+------
 bb   |   11 |   12 |    2 |   13
 cc   |      |   22 |    2 |   23
 dd   |      |      |      |   33
 ee   |      |   42 |    2 |     
(4 rows)

-- Constants as join keys can also be problematic
--Testcase 96:
SELECT * FROM
  (SELECT fields->>'name' "name", (fields->>'n')::int as s1_n FROM t1) as s1
FULL JOIN
  (SELECT fields->>'name' "name", 2 as s2_n FROM t2) as s2
ON ((s1_n)::int = (s2_n)::int);
 name | s1_n | name | s2_n 
------+------+------+------
      |      | bb   |    2
      |      | cc   |    2
      |      | ee   |    2
 bb   |   11 |      |     
(4 rows)

-- Test for propagation of nullability constraints into sub-joins
--Testcase 97:
create foreign table x (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 580:
create foreign table x_nsc (x1 int, x2 int) server influxdb_svr OPTIONS (table 'x');
--Testcase 98:
insert into x_nsc values (1,11);
--Testcase 99:
insert into x_nsc values (2,22);
--Testcase 100:
insert into x_nsc values (3,null);
--Testcase 101:
insert into x_nsc values (4,44);
--Testcase 102:
insert into x_nsc values (5,null);
--Testcase 103:
create foreign table y (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 581:
create foreign table y_nsc (y1 int, y2 int) server influxdb_svr OPTIONS (table 'y');
--Testcase 104:
insert into y_nsc values (1,111);
--Testcase 105:
insert into y_nsc values (2,222);
--Testcase 106:
insert into y_nsc values (3,333);
--Testcase 107:
insert into y_nsc values (4,null);
--Testcase 108:
select * from x;
         fields          
-------------------------
 {"x1": "1", "x2": "11"}
 {"x1": "2", "x2": "22"}
 {"x1": "3", "x2": null}
 {"x1": "4", "x2": "44"}
 {"x1": "5", "x2": null}
(5 rows)

--Testcase 109:
select * from y;
          fields          
--------------------------
 {"y1": "1", "y2": "111"}
 {"y1": "2", "y2": "222"}
 {"y1": "3", "y2": "333"}
 {"y1": "4", "y2": null}
(4 rows)

--Testcase 110:
select * from (select (fields->>'x1')::int x1, (fields->>'x2')::int x2 from x) x left join (select (fields->>'y1')::int y1, (fields->>'y2')::int y2 from y) y on (x1::int = y1::int and x2 is not null);
 x1 | x2 | y1 | y2  
----+----+----+-----
  1 | 11 |  1 | 111
  2 | 22 |  2 | 222
  3 |    |    |    
  4 | 44 |  4 |    
  5 |    |    |    
(5 rows)

--Testcase 111:
select * from (select (fields->>'x1')::int x1, (fields->>'x2')::int x2 from x) x left join (select (fields->>'y1')::int y1, (fields->>'y2')::int y2 from y) y on (x1::int = y1::int and y2 is not null);
 x1 | x2 | y1 | y2  
----+----+----+-----
  1 | 11 |  1 | 111
  2 | 22 |  2 | 222
  3 |    |  3 | 333
  4 | 44 |    |    
  5 |    |    |    
(5 rows)

--Testcase 112:
select * from ((select (fields->>'x1')::int x1, (fields->>'x2')::int x2 from x) x left join (select (fields->>'y1')::int y1, (fields->>'y2')::int y2 from y) y on (x1::int = y1::int)) left join (select (fields->>'x1')::int x1, (fields->>'x2')::int x2 from x) xx(xx1,xx2)
on (x1::int = xx1::int);
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  2 | 22 |  2 | 222 |   2 |  22
  3 |    |  3 | 333 |   3 |    
  4 | 44 |  4 |     |   4 |  44
  5 |    |    |     |   5 |    
(5 rows)

--Testcase 113:
select * from ((select (fields->>'x1')::int x1, (fields->>'x2')::int x2 from x) x left join (select (fields->>'y1')::int y1, (fields->>'y2')::int y2 from y) y on (x1::int = y1::int)) left join (select (fields->>'x1')::int x1, (fields->>'x2')::int x2 from x) xx(xx1,xx2)
on (x1::int = xx1::int and x2 is not null);
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  2 | 22 |  2 | 222 |   2 |  22
  3 |    |  3 | 333 |     |    
  4 | 44 |  4 |     |   4 |  44
  5 |    |    |     |     |    
(5 rows)

--Testcase 114:
select * from ((select (fields->>'x1')::int x1, (fields->>'x2')::int x2 from x) x left join (select (fields->>'y1')::int y1, (fields->>'y2')::int y2 from y) y on (x1::int = y1::int)) left join (select (fields->>'x1')::int x1, (fields->>'x2')::int x2 from x) xx(xx1,xx2)
on (x1::int = xx1::int and y2 is not null);
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  2 | 22 |  2 | 222 |   2 |  22
  3 |    |  3 | 333 |   3 |    
  4 | 44 |  4 |     |     |    
  5 |    |    |     |     |    
(5 rows)

--Testcase 115:
select * from ((select (fields->>'x1')::int x1, (fields->>'x2')::int x2 from x) x left join (select (fields->>'y1')::int y1, (fields->>'y2')::int y2 from y) y on (x1::int = y1::int)) left join (select (fields->>'x1')::int x1, (fields->>'x2')::int x2 from x) xx(xx1,xx2)
on (x1::int = xx1::int and xx2 is not null);
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  2 | 22 |  2 | 222 |   2 |  22
  3 |    |  3 | 333 |     |    
  4 | 44 |  4 |     |   4 |  44
  5 |    |    |     |     |    
(5 rows)

-- these should NOT give the same answers as above
--Testcase 116:
select * from ((select (fields->>'x1')::int x1, (fields->>'x2')::int x2 from x) x left join (select (fields->>'y1')::int y1, (fields->>'y2')::int y2 from y) y on (x1::int = y1::int)) left join (select (fields->>'x1')::int x1, (fields->>'x2')::int x2 from x) xx(xx1,xx2)
on (x1::int = xx1::int) where (x2 is not null);
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  2 | 22 |  2 | 222 |   2 |  22
  4 | 44 |  4 |     |   4 |  44
(3 rows)

--Testcase 117:
select * from ((select (fields->>'x1')::int x1, (fields->>'x2')::int x2 from x) x left join (select (fields->>'y1')::int y1, (fields->>'y2')::int y2 from y) y on (x1::int = y1::int)) left join (select (fields->>'x1')::int x1, (fields->>'x2')::int x2 from x) xx(xx1,xx2)
on (x1::int = xx1::int) where (y2 is not null);
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  2 | 22 |  2 | 222 |   2 |  22
  3 |    |  3 | 333 |   3 |    
(3 rows)

--Testcase 118:
select * from ((select (fields->>'x1')::int x1, (fields->>'x2')::int x2 from x) x left join (select (fields->>'y1')::int y1, (fields->>'y2')::int y2 from y) y on (x1::int = y1::int)) left join (select (fields->>'x1')::int x1, (fields->>'x2')::int x2 from x) xx(xx1,xx2)
on (x1::int = xx1::int) where (xx2 is not null);
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  2 | 22 |  2 | 222 |   2 |  22
  4 | 44 |  4 |     |   4 |  44
(3 rows)

--
-- regression test: check for bug with propagation of implied equality
-- to outside an IN
--
--Testcase 119:
select count(*) from (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1) a where unique1 in
  (select unique1 from (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1) b join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1) c using (unique1)
   where b.unique2::int4 = 42);
 count 
-------
     1
(1 row)

--
-- regression test: check for failure to generate a plan with multiple
-- degenerate IN clauses
--
--Testcase 120:
select count(*) from (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1) x where
  (x.unique1)::int4 in (select (a.fields->>'f1')::int4 from int4_tbl a,float8_tbl b where (a.fields->>'f1')::int4=(b.fields->>'f1')::float8) and
  (x.unique1)::int4 = 0 and
  (x.unique1)::int4 in (select (aa.fields->>'f1')::int4 from int4_tbl aa,float8_tbl bb where (aa.fields->>'f1')::int4=(bb.fields->>'f1')::float8);
 count 
-------
     1
(1 row)

-- try that with GEQO too
begin;
--Testcase 121:
set geqo = on;
--Testcase 122:
set geqo_threshold = 2;
--Testcase 123:
select count(*) from (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1) x where
  (x.unique1)::int4 in (select a.f1 from (select (fields->>'f1')::int4 f1 from INT4_TBL) a,(select (fields->>'f1')::float8 f1 from FLOAT8_TBL) b where a.f1::int4=b.f1::float8) and
  (x.unique1)::int4 = 0 and
  (x.unique1)::int4 in (select aa.f1 from (select (fields->>'f1')::int4 f1 from INT4_TBL) aa,(select (fields->>'f1')::float8 f1 from FLOAT8_TBL) bb where aa.f1::int4=bb.f1::float8);
 count 
-------
     1
(1 row)

rollback;
--
-- regression test: be sure we cope with proven-dummy append rels
--
--Testcase 124:
CREATE FOREIGN TABLE b_star(fields jsonb OPTIONS (fields 'true')) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 125:
explain (costs off)
select b_star.aa::int4, bb, tenk1.unique1::int, tenk1.unique1::int
  from (select (fields->>'unique1')::int unique1, fields->>'unique2' unique2, fields->>'two' two, fields->>'four' four, fields->>'ten' ten, fields->>'twenty' twenty, fields->>'hundred' hundred, fields->>'thousand' thousand, fields->>'twothousand' twothousand, fields->>'fivethous' fivethous, fields->>'tenthous' tenthous, fields->>'odd' odd, fields->>'even' even, fields->>'stringu1' stringu1, fields->>'stringu2' stringu2, fields->>'string4' string4 from tenk1) tenk1 right join (select (fields->>'class')::char class, (fields->>'aa')::int4 aa, fields->>'bb' bb, (fields->>'a')::int4 a from b_star) b_star on b_star.aa::int4 = tenk1.unique1::int
  where b_star.bb < b_star.bb and b_star.bb is null;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Hash Right Join
   Hash Cond: (((tenk1.fields ->> 'unique1'::text))::integer = ((b_star.fields ->> 'aa'::text))::integer)
   ->  Foreign Scan on tenk1
   ->  Hash
         ->  Foreign Scan on b_star
               Filter: (((fields ->> 'bb'::text) IS NULL) AND ((fields ->> 'bb'::text) < (fields ->> 'bb'::text)))
(6 rows)

--Testcase 126:
select b_star.aa::int4, bb, tenk1.unique1::int, tenk1.unique1::int
  from (select (fields->>'unique1')::int unique1, fields->>'unique2' unique2, fields->>'two' two, fields->>'four' four, fields->>'ten' ten, fields->>'twenty' twenty, fields->>'hundred' hundred, fields->>'thousand' thousand, fields->>'twothousand' twothousand, fields->>'fivethous' fivethous, fields->>'tenthous' tenthous, fields->>'odd' odd, fields->>'even' even, fields->>'stringu1' stringu1, fields->>'stringu2' stringu2, fields->>'string4' string4 from tenk1) tenk1 right join (select (fields->>'class')::char class, (fields->>'aa')::int4 aa, fields->>'bb' bb, (fields->>'a')::int4 a from b_star) b_star on b_star.aa::int4 = tenk1.unique1::int
  where b_star.bb < b_star.bb and b_star.bb is null;
 aa | bb | unique1 | unique1 
----+----+---------+---------
(0 rows)

--Testcase 127:
drop foreign table b_star;
--
-- regression test: check handling of empty-FROM subquery underneath outer join
--
--Testcase 128:
explain (costs off)
select (i1.fields->>'q1')::int8 q1, (i1.fields->>'q2')::int8 q2, (i2.fields->>'q1')::int8 q1, (i2.fields->>'q2')::int8 q2, x from int8_tbl i1 left join (int8_tbl i2 join
  (select 123 as x) ss on (i2.fields->>'q1')::int8 = x) on (i1.fields->>'q2')::int8 = (i2.fields->>'q2')::int8
order by 1, 2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort
   Sort Key: (((i1.fields ->> 'q1'::text))::bigint), (((i1.fields ->> 'q2'::text))::bigint)
   ->  Hash Left Join
         Hash Cond: (((i1.fields ->> 'q2'::text))::bigint = ((i2.fields ->> 'q2'::text))::bigint)
         ->  Foreign Scan on int8_tbl i1
         ->  Hash
               ->  Foreign Scan on int8_tbl i2
(7 rows)

--Testcase 129:
select (i1.fields->>'q1')::int8 q1, (i1.fields->>'q2')::int8 q2, (i2.fields->>'q1')::int8 q1, (i2.fields->>'q2')::int8 q2, x from int8_tbl i1 left join (int8_tbl i2 join
  (select 123 as x) ss on (i2.fields->>'q1')::int8 = x) on (i1.fields->>'q2')::int8= (i2.fields->>'q2')::int8
order by 1, 2;
        q1        |        q2         | q1  |        q2        |  x  
------------------+-------------------+-----+------------------+-----
              123 |               456 | 123 |              456 | 123
              123 |  4567890123456789 | 123 | 4567890123456789 | 123
 4567890123456789 | -4567890123456789 |     |                  |    
 4567890123456789 |               123 |     |                  |    
 4567890123456789 |  4567890123456789 | 123 | 4567890123456789 | 123
(5 rows)

--
-- regression test: check a case where join_clause_is_movable_into() gives
-- an imprecise result, causing an assertion failure
--
--Testcase 130:
select count(*)
from
  (select (t3.fields->>'tenthous')::int4 as x1, coalesce((t1.fields->>'stringu1')::name, (t2.fields->>'stringu1')::name) as x2
   from tenk1 t1
   left join tenk1 t2 on (t1.fields->>'unique1')::int4 = (t2.fields->>'unique1')::int4
   join tenk1 t3 on (t1.fields->>'unique2')::int4 = (t3.fields->>'unique2')::int4) ss,
  tenk1 t4,
  tenk1 t5
where (t4.fields->>'thousand')::int4 = (t5.fields->>'unique1')::int4 and ss.x1 = (t4.fields->>'tenthous')::int4 and ss.x2 = (t5.fields->>'stringu1')::name;
 count 
-------
  1000
(1 row)

--
-- regression test: check a case where we formerly missed including an EC
-- enforcement clause because it was expected to be handled at scan level
--
--Testcase 131:
explain (costs off)
select a.f1, b.f1, (t.fields->>'thousand')::int4 thousand, (t.fields->>'tenhous')::int4 tenthous from
  tenk1 t,
  (select sum((fields->>'f1')::int4)+1 as f1 from int4_tbl i4a) a,
  (select sum((fields->>'f1')::int4) as f1 from int4_tbl i4b) b
where b.f1 = (t.fields->>'thousand')::int4 and a.f1 = b.f1 and (a.f1+b.f1+999) = (t.fields->>'tenthous')::int4;
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (((sum(((i4a.fields ->> 'f1'::text))::integer) + 1)) = (sum(((i4b.fields ->> 'f1'::text))::integer)))
   Join Filter: (((((sum(((i4a.fields ->> 'f1'::text))::integer) + 1)) + (sum(((i4b.fields ->> 'f1'::text))::integer))) + 999) = ((t.fields ->> 'tenthous'::text))::integer)
   ->  Hash Join
         Hash Cond: (((t.fields ->> 'thousand'::text))::integer = ((sum(((i4a.fields ->> 'f1'::text))::integer) + 1)))
         ->  Foreign Scan on tenk1 t
         ->  Hash
               ->  Foreign Scan
   ->  Hash
         ->  Foreign Scan
(10 rows)

--Testcase 132:
select a.f1, b.f1, (t.fields->>'thousand')::int4 thousand, (t.fields->>'tenhous')::int4 tenthous from
  tenk1 t,
  (select sum((fields->>'f1')::int4)+1 as f1 from int4_tbl i4a) a,
   (select sum((fields->>'f1')::int4) as f1 from int4_tbl i4b) b
where b.f1 = (t.fields->>'thousand')::int4 and a.f1 = b.f1 and (a.f1+b.f1+999) = (t.fields->>'tenthous')::int4;
 f1 | f1 | thousand | tenthous 
----+----+----------+----------
(0 rows)

--
-- check a case where we formerly got confused by conflicting sort orders
-- in redundant merge join path keys
--
--Testcase 133:
explain (costs off)
select * from
  (SELECT (fields->>'i')::int i,(fields->>'j')::int j,fields->>'t' t FROM J1_TBL j1_tbl) j1_tbl full join
  (select * from (select (fields->>'i')::int i, (fields->>'k')::int k from J2_TBL j2_tbl) j2_tbl order by (j2_tbl.i)::int desc, (j2_tbl.k)::int asc) j2_tbl
  on (j1_tbl.i)::int = (j2_tbl.i)::int and (j1_tbl.i)::int = (j2_tbl.k)::int;
                                                                                               QUERY PLAN                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Full Join
   Merge Cond: (((((j2_tbl.fields ->> 'i'::text))::integer) = (((j1_tbl.fields ->> 'i'::text))::integer)) AND ((((j2_tbl.fields ->> 'k'::text))::integer) = (((j1_tbl.fields ->> 'i'::text))::integer)))
   ->  Sort
         Sort Key: (((j2_tbl.fields ->> 'i'::text))::integer) DESC, (((j2_tbl.fields ->> 'k'::text))::integer)
         ->  Foreign Scan on j2_tbl
   ->  Sort
         Sort Key: (((j1_tbl.fields ->> 'i'::text))::integer) DESC
         ->  Foreign Scan on j1_tbl
(8 rows)

--Testcase 134:
select * from
  (select (fields->>'i')::int i, (fields->>'j')::int j,fields->>'t' t from J1_TBL j1_tbl) j1_tbl full join
  (select * from (select (fields->>'i')::int i, (fields->>'k')::int k from J2_TBL j2_tbl) j2_tbl order by (j2_tbl.i)::int desc, (j2_tbl.k)::int asc) j2_tbl
  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;
 i | j |   t   | i | k  
---+---+-------+---+----
   |   |       |   |  0
   | 0 | zero  |   |   
   |   | null  |   |   
 8 | 8 | eight |   |   
 7 | 7 | seven |   |   
 6 | 6 | six   |   |   
   |   |       | 5 | -5
   |   |       | 5 | -5
 5 | 0 | five  |   |   
 4 | 1 | four  |   |   
   |   |       | 3 | -3
 3 | 2 | three |   |   
 2 | 3 | two   | 2 |  2
   |   |       | 2 |  4
   |   |       | 1 | -1
   |   |       | 0 |   
 1 | 4 | one   |   |   
 0 |   | zero  |   |   
(18 rows)

--
-- a different check for handling of redundant sort keys in merge joins
--
--Testcase 135:
explain (costs off)
select count(*) from
  (select * from tenk1 x order by (x.fields->>'thousand')::int4, (x.fields->>'twothousand')::int4, (x.fields->>'fivethous')::int4) x
  left join
  (select * from tenk1 y order by (y.fields->>'unique2')::int4) y
  on (x.fields->>'thousand')::int4 = (y.fields->>'unique2')::int4 and (x.fields->>'twothousand')::int4 = (y.fields->>'hundred')::int4 and (x.fields->>'fivethous')::int4 = (y.fields->>'unique2')::int4;
                                                                                                                                                        QUERY PLAN                                                                                                                                                        
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Merge Left Join
         Merge Cond: (((((x.fields ->> 'thousand'::text))::integer) = (((y.fields ->> 'unique2'::text))::integer)) AND ((((x.fields ->> 'twothousand'::text))::integer) = (((y.fields ->> 'hundred'::text))::integer)) AND ((((x.fields ->> 'fivethous'::text))::integer) = (((y.fields ->> 'unique2'::text))::integer)))
         ->  Sort
               Sort Key: (((x.fields ->> 'thousand'::text))::integer), (((x.fields ->> 'twothousand'::text))::integer), (((x.fields ->> 'fivethous'::text))::integer)
               ->  Subquery Scan on x
                     ->  Sort
                           Sort Key: (((x_1.fields ->> 'thousand'::text))::integer), (((x_1.fields ->> 'twothousand'::text))::integer), (((x_1.fields ->> 'fivethous'::text))::integer)
                           ->  Foreign Scan on tenk1 x_1
         ->  Sort
               Sort Key: (((y.fields ->> 'unique2'::text))::integer), (((y.fields ->> 'hundred'::text))::integer)
               ->  Subquery Scan on y
                     ->  Sort
                           Sort Key: (((y_1.fields ->> 'unique2'::text))::integer)
                           ->  Foreign Scan on tenk1 y_1
(15 rows)

--Testcase 136:
select count(*) from
  (select * from tenk1 x order by (x.fields->>'thousand')::int4, (x.fields->>'twothousand')::int4, (x.fields->>'fivethous')::int4) x
  left join
  (select * from tenk1 y order by (y.fields->>'unique2')::int4) y
  on (x.fields->>'thousand')::int4 = (y.fields->>'unique2')::int4 and (x.fields->>'twothousand')::int4 = (y.fields->>'hundred')::int4 and (x.fields->>'fivethous')::int4 = (y.fields->>'unique2')::int4;
 count 
-------
 10000
(1 row)

--
-- Clean up
--
--Testcase 137:
DELETE FROM t1_nsc;
--Testcase 138:
DELETE FROM t2_nsc;
--Testcase 139:
DELETE FROM t3_nsc;
--Testcase 140:
DROP FOREIGN TABLE t1;
--Testcase 582:
DROP FOREIGN TABLE t1_nsc;
--Testcase 141:
DROP FOREIGN TABLE t2;
--Testcase 583:
DROP FOREIGN TABLE t2_nsc;
--Testcase 142:
DROP FOREIGN TABLE t3;
--Testcase 584:
DROP FOREIGN TABLE t3_nsc;
--Testcase 143:
DELETE FROM j1_tbl_nsc;
--Testcase 585:
DROP FOREIGN TABLE J1_TBL;
--Testcase 586:
DROP FOREIGN TABLE j1_tbl_nsc;
--Testcase 144:
DELETE FROM j2_tbl_nsc;
--Testcase 587:
DROP FOREIGN TABLE J2_TBL;
--Testcase 588:
DROP FOREIGN TABLE j2_tbl_nsc;
--Testcase 589:
DELETE FROM x_nsc;
--Testcase 590:
DELETE FROM y_nsc;
--Testcase 591:
DROP FOREIGN TABLE x_nsc;
--Testcase 592:
DROP FOREIGN TABLE y_nsc;
-- Both DELETE and UPDATE allow the specification of additional tables
-- to "join" against to determine which rows should be modified.
--Testcase 145:
CREATE FOREIGN TABLE t1 (fields jsonb OPTIONS (fields 'true')) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 593:
CREATE FOREIGN TABLE t1_nsc (a int, b int) SERVER influxdb_svr OPTIONS (table 't1');
--Testcase 146:
CREATE FOREIGN TABLE t2 (fields jsonb OPTIONS (fields 'true')) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 594:
CREATE FOREIGN TABLE t2_nsc (a int, b int) SERVER influxdb_svr OPTIONS (table 't2');
--Testcase 147:
CREATE FOREIGN TABLE t3 (fields jsonb OPTIONS (fields 'true')) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 595:
CREATE FOREIGN TABLE t3_nsc (x int, y int) SERVER influxdb_svr OPTIONS (table 't3');
--Testcase 148:
INSERT INTO t1_nsc VALUES (5, 10);
--Testcase 149:
INSERT INTO t1_nsc VALUES (15, 20);
--Testcase 150:
INSERT INTO t1_nsc VALUES (100, 100);
--Testcase 151:
INSERT INTO t1_nsc VALUES (200, 1000);
--Testcase 152:
INSERT INTO t2_nsc VALUES (200, 2000);
--Testcase 153:
INSERT INTO t3_nsc VALUES (5, 20);
--Testcase 154:
INSERT INTO t3_nsc VALUES (6, 7);
--Testcase 155:
INSERT INTO t3_nsc VALUES (7, 8);
--Testcase 156:
INSERT INTO t3_nsc VALUES (500, 100);
--Testcase 157:
ALTER TABLE t3 ADD time timestamp;
ALTER TABLE t3_nsc ADD time timestamp;
--Testcase 158:
SELECT (fields->>'x')::int x, (fields->>'y')::int y FROM t3;
  x  |  y  
-----+-----
   5 |  20
   6 |   7
   7 |   8
 500 | 100
(4 rows)

--Testcase 159:
DELETE FROM t3_nsc USING t1_nsc table1 WHERE t3_nsc.x = table1.a;
--Testcase 160:
SELECT (fields->>'x')::int x, (fields->>'y')::int y FROM t3;
  x  |  y  
-----+-----
   6 |   7
   7 |   8
 500 | 100
(3 rows)

--Testcase 161:
DELETE FROM t3_nsc USING t1_nsc JOIN t2_nsc USING (a) WHERE t3_nsc.x > t1_nsc.a;
--Testcase 162:
SELECT (fields->>'x')::int x, (fields->>'y')::int y FROM t3;
 x | y 
---+---
 6 | 7
 7 | 8
(2 rows)

--Testcase 163:
DELETE FROM t3_nsc USING t3_nsc t3_other WHERE t3_nsc.x = t3_other.x AND t3_nsc.y = t3_other.y;
--Testcase 164:
SELECT (fields->>'x')::int x, (fields->>'y')::int y FROM t3;
 x | y 
---+---
(0 rows)

-- Test join against inheritance tree
--Testcase 165:
create temp table t2a () inherits (t2);
--Testcase 166:
insert into t2a values ('{"a": "200", "b": "2001"}');
--Testcase 167:
select * from (select (fields->>'a')::int a, (fields->>'b')::int b from t1) t1 left join (select (fields->>'a')::int a, (fields->>'b')::int b from t2) t2 on (t1.a::int = t2.a::int);
  a  |  b   |  a  |  b   
-----+------+-----+------
   5 |   10 |     |     
  15 |   20 |     |     
 100 |  100 |     |     
 200 | 1000 | 200 | 2000
 200 | 1000 | 200 | 2001
(5 rows)

-- Test matching of column name with wrong alias
--Testcase 168:
select t1.x from (select (fields->>'a')::int a, (fields->>'b')::int b from t1) t1 join (select (fields->>'x')::int x, (fields->>'y')::int y from t3) t3 on (t1.a::int = t3.x::int);
ERROR:  column t1.x does not exist
LINE 1: select t1.x from (select (fields->>'a')::int a, (fields->>'b...
               ^
HINT:  Perhaps you meant to reference the column "t3.x".
--
-- regression test for 8.1 merge right join bug
--
--Testcase 169:
CREATE FOREIGN TABLE tt1 ( fields jsonb OPTIONS (fields 'true') ) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 596:
CREATE FOREIGN TABLE tt1_nsc ( tt1_id int4, joincol int4 ) SERVER influxdb_svr OPTIONS (table 'tt1');
--Testcase 170:
INSERT INTO tt1_nsc VALUES (1, 11);
--Testcase 171:
INSERT INTO tt1_nsc VALUES (2, NULL);
--Testcase 172:
CREATE FOREIGN TABLE tt2 ( fields jsonb OPTIONS (fields 'true') ) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 597:
CREATE FOREIGN TABLE tt2_nsc ( tt2_id int4, joincol int4 ) SERVER influxdb_svr OPTIONS (table 'tt2');
--Testcase 173:
INSERT INTO tt2_nsc VALUES (21, 11);
--Testcase 174:
INSERT INTO tt2_nsc VALUES (22, 11);
--Testcase 175:
set enable_hashjoin to off;
--Testcase 176:
set enable_nestloop to off;
-- these should give the same results
--Testcase 177:
select tt1.*, tt2.* from (select (fields->>'tt1_id')::int4 tt1_id, (fields->>'joincol')::int4 joincol from tt1) tt1 left join (select (fields->>'tt2_id')::int4 tt2_id, (fields->>'joincol')::int4 joincol from tt2) tt2 on tt1.joincol::int4 = tt2.joincol::int4;
 tt1_id | joincol | tt2_id | joincol 
--------+---------+--------+---------
      1 |      11 |     21 |      11
      1 |      11 |     22 |      11
      2 |         |        |        
(3 rows)

--Testcase 178:
select tt1.*, tt2.* from (select (fields->>'tt2_id')::int4 tt2_id, (fields->>'joincol')::int4 joincol from tt2) tt2 right join (select (fields->>'tt1_id')::int4 tt1_id, (fields->>'joincol')::int4 joincol from tt1) tt1 on tt1.joincol::int4 = tt2.joincol::int4;
 tt1_id | joincol | tt2_id | joincol 
--------+---------+--------+---------
      1 |      11 |     21 |      11
      1 |      11 |     22 |      11
      2 |         |        |        
(3 rows)

--Testcase 179:
reset enable_hashjoin;
--Testcase 180:
reset enable_nestloop;
--
-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)
--
--Testcase 181:
set work_mem to '64kB';
--Testcase 182:
set enable_mergejoin to off;
--Testcase 183:
set enable_memoize to off;
--Testcase 184:
explain (costs off)
select count(*) from tenk1 a, tenk1 b
  where ((a.fields->>'hundred')::int4 = (b.fields->>'thousand')::int4) and ((b.fields->>'fivethous')::int4 % 10) < 10;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (((a.fields ->> 'hundred'::text))::integer = ((b.fields ->> 'thousand'::text))::integer)
         ->  Foreign Scan on tenk1 a
         ->  Hash
               ->  Foreign Scan on tenk1 b
(6 rows)

--Testcase 185:
select count(*) from tenk1 a, tenk1 b
  where ((a.fields->>'hundred')::int4 = (b.fields->>'thousand')::int4) and ((b.fields->>'fivethous')::int4 % 10) < 10;
 count  
--------
 100000
(1 row)

--Testcase 186:
reset work_mem;
--Testcase 187:
reset enable_mergejoin;
--Testcase 188:
reset enable_memoize;
--
-- regression test for 8.2 bug with improper re-ordering of left joins
--
--Testcase 189:
create foreign table tt3(fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 598:
create foreign table tt3_nsc(f1 int, f2 text) server influxdb_svr OPTIONS (table 'tt3');
--Testcase 190:
insert into tt3_nsc select x, repeat('xyzzy', 100) from generate_series(1,10000) x;
--Testcase 191:
create foreign table tt4(fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 599:
create foreign table tt4_nsc(f1 int) server influxdb_svr OPTIONS (table 'tt4');
--Testcase 192:
insert into tt4_nsc values (0),(1),(9999);
--Testcase 193:
SELECT (a.fields->>'f1')::int f1
FROM tt4 a
LEFT JOIN (
        SELECT (b.fields->>'f1')::int f1
        FROM tt3 b LEFT JOIN tt3 c ON ((b.fields->>'f1')::int = (c.fields->>'f1')::int)
        WHERE c.fields->>'f1' IS NULL
) AS d ON ((a.fields->>'f1')::int = (d.f1)::int)
WHERE d.f1 IS NULL;
  f1  
------
    0
    1
 9999
(3 rows)

--
-- regression test for proper handling of outer joins within antijoins
--
--Testcase 194:
create foreign table tt4x(fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 195:
explain (costs off)
select * from tt4x t1
where not exists (
  select 1 from tt4x t2
    left join tt4x t3 on (t2.fields->>'c3')::int = (t3.fields->>'c1')::int
    left join ( select (t5.fields->>'c1')::int as c1
                from tt4x t4 left join tt4x t5 on (t4.fields->>'c2')::int = (t5.fields->>'c1')::int
              ) a1 on (t3.fields->>'c2')::int = a1.c1
  where (t1.fields->>'c1')::int = (t2.fields->>'c2')::int
);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Hash Anti Join
   Hash Cond: (((t1.fields ->> 'c1'::text))::integer = ((t2.fields ->> 'c2'::text))::integer)
   ->  Foreign Scan on tt4x t1
   ->  Hash
         ->  Merge Right Join
               Merge Cond: (((t5.fields ->> 'c1'::text))::integer = (((t3.fields ->> 'c2'::text))::integer))
               ->  Merge Join
                     Merge Cond: ((((t4.fields ->> 'c2'::text))::integer) = (((t5.fields ->> 'c1'::text))::integer))
                     ->  Sort
                           Sort Key: (((t4.fields ->> 'c2'::text))::integer)
                           ->  Foreign Scan on tt4x t4
                     ->  Sort
                           Sort Key: (((t5.fields ->> 'c1'::text))::integer)
                           ->  Foreign Scan on tt4x t5
               ->  Sort
                     Sort Key: (((t3.fields ->> 'c2'::text))::integer)
                     ->  Merge Left Join
                           Merge Cond: ((((t2.fields ->> 'c3'::text))::integer) = (((t3.fields ->> 'c1'::text))::integer))
                           ->  Sort
                                 Sort Key: (((t2.fields ->> 'c3'::text))::integer)
                                 ->  Foreign Scan on tt4x t2
                           ->  Sort
                                 Sort Key: (((t3.fields ->> 'c1'::text))::integer)
                                 ->  Foreign Scan on tt4x t3
(24 rows)

--
-- regression test for problems of the sort depicted in bug #3494
--
--Testcase 196:
create foreign table tt5(fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 600:
create foreign table tt5_nsc(f1 int, f2 int) server influxdb_svr OPTIONS (table 'tt5');
--Testcase 197:
create foreign table tt6(fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 601:
create foreign table tt6_nsc(f1 int, f2 int) server influxdb_svr OPTIONS (table 'tt6');
--Testcase 198:
insert into tt5_nsc values(1, 10);
--Testcase 199:
insert into tt5_nsc values(1, 11);
--Testcase 200:
insert into tt6_nsc values(1, 9);
--Testcase 201:
insert into tt6_nsc values(1, 2);
--Testcase 202:
insert into tt6_nsc values(2, 9);
--Testcase 203:
select * from (select (fields->>'f1')::int f1, (fields->>'f2')::int f2 from tt5) tt5,(select (fields->>'f1')::int f1, (fields->>'f2')::int f2 from tt6) tt6 where (tt5.f1)::int = (tt6.f1)::int and (tt5.f1)::int = (tt5.f2)::int - (tt6.f2)::int;
 f1 | f2 | f1 | f2 
----+----+----+----
  1 | 10 |  1 |  9
(1 row)

--
-- regression test for problems of the sort depicted in bug #3588
--
--Testcase 204:
create foreign table xx (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 602:
create foreign table xx_nsc (pkxx int) server influxdb_svr OPTIONS (table 'xx');
--Testcase 205:
create foreign table yy (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 603:
create foreign table yy_nsc (pkyy int, pkxx int) server influxdb_svr OPTIONS (table 'yy');
--Testcase 206:
insert into xx_nsc values (1);
--Testcase 207:
insert into xx_nsc values (2);
--Testcase 208:
insert into xx_nsc values (3);
--Testcase 209:
insert into yy_nsc values (101, 1);
--Testcase 210:
insert into yy_nsc values (201, 2);
--Testcase 211:
insert into yy_nsc values (301, NULL);
--Testcase 212:
select (yy.fields->>'pkyy')::int as yy_pkyy, (yy.fields->>'pkxx')::int as yy_pkxx, (yya.fields->>'pkyy')::int as yya_pkyy,
       (xxa.fields->>'pkxx')::int as xxa_pkxx, (xxb.fields->>'pkxx')::int as xxb_pkxx
from yy
     left join (SELECT * FROM yy where (fields->>'pkyy')::int = 101) as yya ON (yy.fields->>'pkyy')::int = (yya.fields->>'pkyy')::int
     left join xx xxa on (yya.fields->>'pkxx')::int = (xxa.fields->>'pkxx')::int
     left join xx xxb on coalesce ((xxa.fields->>'pkxx')::int, 1) = (xxb.fields->>'pkxx')::int ORDER BY yy_pkyy, yy_pkxx, yya_pkyy, xxa_pkxx, xxb_pkxx;
 yy_pkyy | yy_pkxx | yya_pkyy | xxa_pkxx | xxb_pkxx 
---------+---------+----------+----------+----------
     101 |       1 |      101 |        1 |        1
     201 |       2 |          |          |        1
     301 |         |          |          |        1
(3 rows)

--
-- regression test for improper pushing of constants across outer-join clauses
-- (as seen in early 8.2.x releases)
--
--Testcase 213:
create foreign table zt1 (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 604:
create foreign table zt1_nsc (f1 int) server influxdb_svr OPTIONS (table 'zt1');
--Testcase 214:
create foreign table zt2 (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 605:
create foreign table zt2_nsc (f2 int) server influxdb_svr OPTIONS (table 'zt2');
--Testcase 215:
create foreign table zt3 (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 216:
insert into zt1_nsc values(53);
--Testcase 217:
insert into zt2_nsc values(53);
--Testcase 218:
select * from
  (select (fields->>'f2')::int f2 from zt2) zt2 left join (select (fields->>'f3')::int f3 from zt3) zt3 on (f2::int = f3::int)
      left join (select (fields->>'f1')::int f1 from zt1) zt1 on (f3::int = f1::int)
where (f2)::int = 53;
 f2 | f3 | f1 
----+----+----
 53 |    |   
(1 row)

--Testcase 219:
create temp view zv1 as select *,'dummy'::text AS junk from zt1;
--Testcase 220:
select * from
  (select (fields->>'f2')::int f2 from zt2) zt2 left join (select (fields->>'f3')::int f3 from zt3) zt3 on (f2::int = f3::int)
      left join zv1 on (f3::int = (zv1.fields->>'f1')::int)
where (f2)::int = 53;
 f2 | f3 | fields | junk 
----+----+--------+------
 53 |    |        | 
(1 row)

--
-- regression test for improper extraction of OR indexqual conditions
-- (as seen in early 8.3.x releases)
--
--Testcase 221:
select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred
from (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1) a left join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1) b on a.unique2 = b.tenthous
where (a.unique1)::int4 = 42 and
      ((b.unique2 is null and (a.ten)::int4 = 2) or (b.hundred)::int4 = 3);
 unique2 | ten | tenthous | unique2 | hundred 
---------+-----+----------+---------+---------
(0 rows)

--
-- test proper positioning of one-time quals in EXISTS (8.4devel bug)
--
--Testcase 222:
prepare foo(bool) as
  select count(*) from (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1) a left join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1) b
    on ((a.unique2)::int4 = (b.unique1)::int4 and exists
        (select 1 from (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1) c where (c.thousand)::int4 = (b.unique2)::int4 and $1));
--Testcase 223:
execute foo(true);
 count 
-------
 10000
(1 row)

--Testcase 224:
execute foo(false);
 count 
-------
 10000
(1 row)

--
-- test for sane behavior with noncanonical merge clauses, per bug #4926
--
begin;
--Testcase 225:
set enable_mergejoin = 1;
--Testcase 226:
set enable_hashjoin = 0;
--Testcase 227:
set enable_nestloop = 0;
--Testcase 228:
create foreign table a (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 229:
create foreign table b (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 230:
select * from (select (fields->>'i')::int i from a) a left join (select (fields->>'x')::int x, (fields->>'y')::int y from b) b on i::int = x::int and i::int = y::int and x::int = i::int;
 i | x | y 
---+---+---
(0 rows)

--Testcase 231:
DROP FOREIGN TABLE a;
--Testcase 232:
DROP FOREIGN TABLE b;
rollback;
--
-- test handling of merge clauses using record_ops
--
begin;
--Testcase 233:
create type mycomptype as (id int, v bigint);
--Testcase 234:
create temp table tidv (idv mycomptype);
--Testcase 235:
create index on tidv (idv);
--Testcase 236:
explain (costs off)
select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;
                        QUERY PLAN                        
----------------------------------------------------------
 Merge Join
   Merge Cond: (a.idv = b.idv)
   ->  Index Only Scan using tidv_idv_idx on tidv a
   ->  Materialize
         ->  Index Only Scan using tidv_idv_idx on tidv b
(5 rows)

--Testcase 237:
set enable_mergejoin = 0;
--Testcase 238:
set enable_hashjoin = 0;
--Testcase 239:
explain (costs off)
select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;
                     QUERY PLAN                     
----------------------------------------------------
 Nested Loop
   ->  Seq Scan on tidv a
   ->  Index Only Scan using tidv_idv_idx on tidv b
         Index Cond: (idv = a.idv)
(4 rows)

rollback;
--
-- test NULL behavior of whole-row Vars, per bug #5025
--
--Testcase 240:
select t1.q2, count(t2.*)
from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) t1 left join (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) t2 on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

--Testcase 241:
select (t1.fields->>'q2')::int8 q2, count(t2.*)
from int8_tbl t1 left join (select * from int8_tbl) t2 on ((t1.fields->>'q2')::int8 = (t2.fields->>'q1')::int8)
group by t1.fields->>'q2' order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

--Testcase 242:
select (t1.fields->>'q2')::int8 q2, count(t2.*)
from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on ((t1.fields->>'q2')::int8 = (t2.fields->>'q1')::int8)
group by t1.fields->>'q2' order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

--Testcase 243:
select (t1.fields->>'q2')::int8 q2, count(t2.*)
from int8_tbl t1 left join
  (select (fields->>'q1')::int8 q1, case when (fields->>'q2')::int8=1 then 1 else (fields->>'q2')::int8 end as q2 from int8_tbl) t2
  on ((t1.fields->>'q2')::int8 = t2.q1)
group by t1.fields->>'q2' order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

--
-- test incorrect failure to NULL pulled-up subexpressions
--
begin;
--Testcase 244:
create foreign table a (
     fields jsonb OPTIONS (fields 'true')
) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 606:
create foreign table a_nsc (
     code char
) server influxdb_svr OPTIONS (table 'a');
--Testcase 245:
create foreign table b (
     fields jsonb OPTIONS (fields 'true')
) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 607:
create foreign table b_nsc (
     a char,
     num integer
) server influxdb_svr OPTIONS (table 'b');
--Testcase 246:
create foreign table c (
     fields jsonb OPTIONS (fields 'true')
) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 608:
create foreign table c_nsc (
     name char,
     a char
) server influxdb_svr OPTIONS (table 'c');
--Testcase 247:
insert into a_nsc (code) values ('p');
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 248:
insert into a_nsc (code) values ('q');
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 249:
insert into b_nsc (a, num) values ('p', 1);
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 250:
insert into b_nsc (a, num) values ('p', 2);
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 251:
insert into c_nsc (name, a) values ('A', 'p');
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 252:
insert into c_nsc (name, a) values ('B', 'q');
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 253:
insert into c_nsc (name, a) values ('C', null);
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 254:
select c.name, ss.code, ss.b_cnt, ss.const
from (select fields->>'name' "name", fields->>'a' a from c) c left join
  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const
   from (select fields->>'code' code from a) a left join
     (select count(1) as cnt, b.fields->>'a' a from b group by b.fields->>'a') as b_grp
     on a.code = b_grp.a
  ) as ss
  on (c.a = ss.code)
order by c.name;
 name | code | b_cnt | const 
------+------+-------+-------
 A    | p    |     2 |    -1
 B    | q    |     0 |    -1
 C    |      |       |      
(3 rows)

--Testcase 255:
DELETE FROM a_nsc;
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 256:
DELETE FROM b_nsc;
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 257:
DELETE FROM c_nsc;
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 258:
DROP FOREIGN TABLE a;
--Testcase 609:
DROP FOREIGN TABLE a_nsc;
--Testcase 259:
DROP FOREIGN TABLE b;
--Testcase 610:
DROP FOREIGN TABLE b_nsc;
--Testcase 260:
DROP FOREIGN TABLE c;
--Testcase 611:
DROP FOREIGN TABLE c_nsc;
rollback;
--
-- test incorrect handling of placeholders that only appear in targetlists,
-- per bug #6154
--
--Testcase 261:
SELECT * FROM
( SELECT 1 as key1 ) sub1
LEFT JOIN
( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM
    ( SELECT 1 as key3 ) sub3
    LEFT JOIN
    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM
        ( SELECT 1 as key5 ) sub5
        LEFT JOIN
        ( SELECT 2 as key6, 42 as value1 ) sub6
        ON sub5.key5 = sub6.key6
    ) sub4
    ON sub4.key5 = sub3.key3
) sub2
ON sub1.key1 = sub2.key3;
 key1 | key3 | value2 | value3 
------+------+--------+--------
    1 |    1 |      1 |      1
(1 row)

-- test the path using join aliases, too
--Testcase 262:
SELECT * FROM
( SELECT 1 as key1 ) sub1
LEFT JOIN
( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM
    ( SELECT 1 as key3 ) sub3
    LEFT JOIN
    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM
        ( SELECT 1 as key5 ) sub5
        LEFT JOIN
        ( SELECT 2 as key6, 42 as value1 ) sub6
        ON sub5.key5 = sub6.key6
    ) sub4
    ON sub4.key5 = sub3.key3
) sub2
ON sub1.key1 = sub2.key3;
 key1 | key3 | value2 | value3 
------+------+--------+--------
    1 |    1 |      1 |      1
(1 row)

--
-- test case where a PlaceHolderVar is used as a nestloop parameter
--
--Testcase 263:
EXPLAIN (COSTS OFF)
SELECT qq, (fields->>'unique1')::int4 unique1
  FROM
  ( SELECT COALESCE((fields->>'q1')::int8, 0) AS qq FROM int8_tbl a ) AS ss1
  FULL OUTER JOIN
  ( SELECT COALESCE((fields->>'q2')::int8, -1) AS qq FROM int8_tbl b ) AS ss2
  USING (qq)
  INNER JOIN tenk1 c ON qq = (fields->>'unique2')::int4;
                                                                                              QUERY PLAN                                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Merge Cond: ((((c.fields ->> 'unique2'::text))::integer) = (COALESCE((COALESCE(((a.fields ->> 'q1'::text))::bigint, '0'::bigint)), (COALESCE(((b.fields ->> 'q2'::text))::bigint, '-1'::bigint)))))
   ->  Sort
         Sort Key: (((c.fields ->> 'unique2'::text))::integer)
         ->  Foreign Scan on tenk1 c
   ->  Sort
         Sort Key: (COALESCE((COALESCE(((a.fields ->> 'q1'::text))::bigint, '0'::bigint)), (COALESCE(((b.fields ->> 'q2'::text))::bigint, '-1'::bigint))))
         ->  Merge Full Join
               Merge Cond: ((COALESCE(((a.fields ->> 'q1'::text))::bigint, '0'::bigint)) = (COALESCE(((b.fields ->> 'q2'::text))::bigint, '-1'::bigint)))
               ->  Sort
                     Sort Key: (COALESCE(((a.fields ->> 'q1'::text))::bigint, '0'::bigint))
                     ->  Foreign Scan on int8_tbl a
               ->  Sort
                     Sort Key: (COALESCE(((b.fields ->> 'q2'::text))::bigint, '-1'::bigint))
                     ->  Foreign Scan on int8_tbl b
(15 rows)

--Testcase 264:
SELECT qq, (fields->>'unique1')::int4 unique1
  FROM
  ( SELECT COALESCE((fields->>'q1')::int8, 0) AS qq FROM int8_tbl a ) AS ss1
  FULL OUTER JOIN
  ( SELECT COALESCE((fields->>'q2')::int8, -1) AS qq FROM int8_tbl b ) AS ss2
  USING (qq)
  INNER JOIN tenk1 c ON qq = (fields->>'unique2')::int4;
 qq  | unique1 
-----+---------
 123 |    4596
 123 |    4596
 456 |    7318
(3 rows)

--
-- nested nestloops can require nested PlaceHolderVars
--
--Testcase 265:
create foreign table nt1 (
  fields jsonb OPTIONS (fields 'true')
) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 612:
create foreign table nt1_nsc (
  id int,
  a1 boolean,
  a2 boolean
) server influxdb_svr OPTIONS (table 'nt1');
--Testcase 266:
create foreign table nt2 (
  fields jsonb OPTIONS (fields 'true')
) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 613:
create foreign table nt2_nsc (
  id int,
  nt1_id int,
  b1 boolean,
  b2 boolean
) server influxdb_svr OPTIONS (table 'nt2');
--Testcase 267:
create foreign table nt3 (
  fields jsonb OPTIONS (fields 'true')
) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 614:
create foreign table nt3_nsc (
  id int,
  nt2_id int,
  c1 boolean
) server influxdb_svr OPTIONS (table 'nt3');
--Testcase 268:
insert into nt1_nsc values (1,true,true);
--Testcase 269:
insert into nt1_nsc values (2,true,false);
--Testcase 270:
insert into nt1_nsc values (3,false,false);
--Testcase 271:
insert into nt2_nsc values (1,1,true,true);
--Testcase 272:
insert into nt2_nsc values (2,2,true,false);
--Testcase 273:
insert into nt2_nsc values (3,3,false,false);
--Testcase 274:
insert into nt3_nsc values (1,1,true);
--Testcase 275:
insert into nt3_nsc values (2,2,false);
--Testcase 276:
insert into nt3_nsc values (3,3,true);
--Testcase 277:
explain (costs off)
select (nt3.fields->>'id')::int id
from nt3 as nt3
  left join
    (select (nt2.fields->>'id')::int id, (nt2.fields->>'nt1_id')::int nt1_id, (nt2.fields->>'b1')::boolean b1, (nt2.fields->>'b2')::boolean b2, ((nt2.fields->>'b1')::boolean and ss1.a3) AS b3
     from nt2 as nt2
       left join
         (select (nt1.fields->>'id')::int id, (nt1.fields->>'a1')::boolean a1, (nt1.fields->>'a2')::boolean a2, ((nt1.fields->>'id')::int is not null) as a3 from nt1) as ss1
         on ss1.id = (nt2.fields->>'nt1_id')::int
    ) as ss2
    on ss2.id = (nt3.fields->>'nt2_id')::int
where (nt3.fields->>'id')::int = 1 and ss2.b3;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (((nt2.fields ->> 'nt1_id'::text))::integer = ((nt1.fields ->> 'id'::text))::integer)
   Join Filter: (((nt2.fields ->> 'b1'::text))::boolean AND ((((nt1.fields ->> 'id'::text))::integer IS NOT NULL)))
   ->  Hash Join
         Hash Cond: (((nt2.fields ->> 'id'::text))::integer = ((nt3.fields ->> 'nt2_id'::text))::integer)
         ->  Foreign Scan on nt2
         ->  Hash
               ->  Foreign Scan on nt3
   ->  Hash
         ->  Foreign Scan on nt1
(10 rows)

--Testcase 278:
select (nt3.fields->>'id')::int id
from nt3 as nt3
  left join
    (select (nt2.fields->>'id')::int id, (nt2.fields->>'nt1_id')::int nt1_id, (nt2.fields->>'b1')::boolean b1, (nt2.fields->>'b2')::boolean b2, ((nt2.fields->>'b1')::boolean and ss1.a3) AS b3
     from nt2 as nt2
       left join
         (select (nt1.fields->>'id')::int id, (nt1.fields->>'a1')::boolean a1, (nt1.fields->>'a2')::boolean a2, ((nt1.fields->>'id')::int is not null) as a3 from nt1) as ss1
         on ss1.id = (nt2.fields->>'nt1_id')::int
    ) as ss2
    on ss2.id = (nt3.fields->>'nt2_id')::int
where (nt3.fields->>'id')::int = 1 and ss2.b3;
 id 
----
  1
(1 row)

--
-- test case where a PlaceHolderVar is propagated into a subquery
--
--Testcase 279:
explain (costs off)
select * from
  (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL t1) t1 left join
  (select q1 as x, 42 as y from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL t2) t2) ss
  on (t1.q2)::int8 = (ss.x)::int8
where
  1 = (select 1 from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL t3) t3 where ss.y is not null limit 1)
order by 1,2;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: (((t1.fields ->> 'q1'::text))::bigint), (((t1.fields ->> 'q2'::text))::bigint)
   ->  Merge Right Join
         Merge Cond: ((((t2.fields ->> 'q1'::text))::bigint) = (((t1.fields ->> 'q2'::text))::bigint))
         Filter: (1 = (SubPlan 1))
         ->  Sort
               Sort Key: (((t2.fields ->> 'q1'::text))::bigint)
               ->  Foreign Scan on int8_tbl t2
         ->  Sort
               Sort Key: (((t1.fields ->> 'q2'::text))::bigint)
               ->  Foreign Scan on int8_tbl t1
         SubPlan 1
           ->  Limit
                 ->  Result
                       One-Time Filter: ((42) IS NOT NULL)
                       ->  Foreign Scan on int8_tbl t3
(16 rows)

--Testcase 280:
select * from
  (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL t1) t1 left join
  (select q1 as x, 42 as y from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL t2) t2) ss
  on (t1.q2)::int8 = (ss.x)::int8
where
  1 = (select 1 from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL t3) t3 where ss.y is not null limit 1)
order by 1,2;
        q1        |        q2        |        x         | y  
------------------+------------------+------------------+----
              123 | 4567890123456789 | 4567890123456789 | 42
              123 | 4567890123456789 | 4567890123456789 | 42
              123 | 4567890123456789 | 4567890123456789 | 42
 4567890123456789 |              123 |              123 | 42
 4567890123456789 |              123 |              123 | 42
 4567890123456789 | 4567890123456789 | 4567890123456789 | 42
 4567890123456789 | 4567890123456789 | 4567890123456789 | 42
 4567890123456789 | 4567890123456789 | 4567890123456789 | 42
(8 rows)

--
-- variant where a PlaceHolderVar is needed at a join, but not above the join
--
--Testcase 281:
explain (costs off)
select * from
  (select (fields->>'f1')::int4 f1 from INT4_TBL i41) as i41,
  lateral
    (select 1 as x from
      (select i41.f1 as lat,
              i42.f1 as loc from
         (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i81) as i81, (select (fields->>'f1')::int4 f1 from INT4_TBL i42) as i42) as ss1
      right join (select (fields->>'f1')::int4 f1 from INT4_TBL i43) as i43 on (i43.f1 > 1)
      where ss1.loc = ss1.lat) as ss2
where i41.f1 > 0;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Nested Loop
   ->  Nested Loop
         ->  Foreign Scan on int4_tbl i41
         ->  Nested Loop
               Join Filter: (((i41.fields ->> 'f1'::text))::integer = ((i42.fields ->> 'f1'::text))::integer)
               ->  Foreign Scan on int8_tbl i81
               ->  Materialize
                     ->  Foreign Scan on int4_tbl i42
   ->  Materialize
         ->  Foreign Scan on int4_tbl i43
(10 rows)

--Testcase 282:
select * from
  (select (fields->>'f1')::int4 f1 from INT4_TBL i41) as i41,
  lateral
    (select 1 as x from
      (select i41.f1 as lat,
              i42.f1 as loc from
         (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i81) as i81, (select (fields->>'f1')::int4 f1 from INT4_TBL i42) as i42) as ss1
      right join (select (fields->>'f1')::int4 f1 from INT4_TBL i43) as i43 on (i43.f1 > 1)
      where ss1.loc = ss1.lat) as ss2
where i41.f1 > 0;
     f1     | x 
------------+---
     123456 | 1
     123456 | 1
     123456 | 1
     123456 | 1
     123456 | 1
     123456 | 1
     123456 | 1
     123456 | 1
     123456 | 1
     123456 | 1
 2147483647 | 1
 2147483647 | 1
 2147483647 | 1
 2147483647 | 1
 2147483647 | 1
 2147483647 | 1
 2147483647 | 1
 2147483647 | 1
 2147483647 | 1
 2147483647 | 1
(20 rows)

--
-- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE
--
--Testcase 283:
select * from (select (fields->>'f1')::int4 f1 from INT4_TBL) a full join (select (fields->>'f1')::int4 f1 from INT4_TBL) b on true;
     f1      |     f1      
-------------+-------------
           0 |           0
           0 |      123456
           0 |     -123456
           0 |  2147483647
           0 | -2147483647
      123456 |           0
      123456 |      123456
      123456 |     -123456
      123456 |  2147483647
      123456 | -2147483647
     -123456 |           0
     -123456 |      123456
     -123456 |     -123456
     -123456 |  2147483647
     -123456 | -2147483647
  2147483647 |           0
  2147483647 |      123456
  2147483647 |     -123456
  2147483647 |  2147483647
  2147483647 | -2147483647
 -2147483647 |           0
 -2147483647 |      123456
 -2147483647 |     -123456
 -2147483647 |  2147483647
 -2147483647 | -2147483647
(25 rows)

--Testcase 284:
select * from (select (fields->>'f1')::int4 f1 from INT4_TBL) a full join (select (fields->>'f1')::int4 f1 from INT4_TBL) b on false;
     f1      |     f1      
-------------+-------------
             |           0
             |      123456
             |     -123456
             |  2147483647
             | -2147483647
           0 |            
      123456 |            
     -123456 |            
  2147483647 |            
 -2147483647 |            
(10 rows)

--
-- test for ability to use a cartesian join when necessary
--
--Testcase 285:
create foreign table q1 (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 286:
create foreign table q2 (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 287:
explain (costs off)
select * from
  (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1) tenk1 join (select (fields->>'f1')::int4 f1 from INT4_TBL) INT4_TBL on (f1)::int = (twothousand)::int,
   (select (fields->>'q1')::int q1 from q1) q1, (select (fields->>'q2')::int q2 from q2) q2
where (q1)::int = thousand::int or (q2)::int = thousand::int;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Merge Cond: ((((int4_tbl.fields ->> 'f1'::text))::integer) = (((tenk1.fields ->> 'twothousand'::text))::integer))
   ->  Sort
         Sort Key: (((int4_tbl.fields ->> 'f1'::text))::integer)
         ->  Foreign Scan on int4_tbl
   ->  Materialize
         ->  Sort
               Sort Key: (((tenk1.fields ->> 'twothousand'::text))::integer)
               ->  Nested Loop
                     Join Filter: ((((q1.fields ->> 'q1'::text))::integer = ((tenk1.fields ->> 'thousand'::text))::integer) OR (((q2.fields ->> 'q2'::text))::integer = ((tenk1.fields ->> 'thousand'::text))::integer))
                     ->  Nested Loop
                           ->  Foreign Scan on tenk1
                           ->  Materialize
                                 ->  Foreign Scan on q1
                     ->  Materialize
                           ->  Foreign Scan on q2
(16 rows)

--Testcase 288:
explain (costs off)
select * from
  (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1) tenk1 join (select (fields->>'f1')::int4 f1 from INT4_TBL) INT4_TBL on (f1)::int = (twothousand)::int,
  (select (fields->>'q1')::int q1 from q1) q1, (select (fields->>'q2')::int q2 from q2) q2
where (thousand)::int = ((q1)::int + (q2)::int);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Merge Cond: ((((tenk1.fields ->> 'thousand'::text))::integer) = ((((q1.fields ->> 'q1'::text))::integer + ((q2.fields ->> 'q2'::text))::integer)))
   ->  Sort
         Sort Key: (((tenk1.fields ->> 'thousand'::text))::integer)
         ->  Merge Join
               Merge Cond: ((((tenk1.fields ->> 'twothousand'::text))::integer) = (((int4_tbl.fields ->> 'f1'::text))::integer))
               ->  Sort
                     Sort Key: (((tenk1.fields ->> 'twothousand'::text))::integer)
                     ->  Foreign Scan on tenk1
               ->  Sort
                     Sort Key: (((int4_tbl.fields ->> 'f1'::text))::integer)
                     ->  Foreign Scan on int4_tbl
   ->  Materialize
         ->  Sort
               Sort Key: ((((q1.fields ->> 'q1'::text))::integer + ((q2.fields ->> 'q2'::text))::integer))
               ->  Nested Loop
                     ->  Foreign Scan on q1
                     ->  Materialize
                           ->  Foreign Scan on q2
(19 rows)

--
-- test ability to generate a suitable plan for a star-schema query
--
--Testcase 289:
explain (costs off)
select * from
  (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 tenk1) tenk1, (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL a) a, (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL b) b
where thousand::int4 = a.q1::int8 and tenthous::int4 = b.q1::int8 and a.q2::int8 = 1 and b.q2::int8 = 2;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (((tenk1.fields ->> 'tenthous'::text))::integer = ((b.fields ->> 'q1'::text))::bigint)
   ->  Hash Join
         Hash Cond: (((tenk1.fields ->> 'thousand'::text))::integer = ((a.fields ->> 'q1'::text))::bigint)
         ->  Foreign Scan on tenk1
         ->  Hash
               ->  Foreign Scan on int8_tbl a
   ->  Hash
         ->  Foreign Scan on int8_tbl b
(9 rows)

--
-- test a corner case in which we shouldn't apply the star-schema optimization
--
--Testcase 290:
explain (costs off)
select (t1.fields->>'unique2')::int4 unique2, (t1.fields->>'stringu1')::name stringu1, (t2.fields->>'unique1')::int4 unique1, (t2.fields->>'stringu2')::name stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (select 1,0 from onerow) v1(x1,x2)
               left join (select 3,1 from onerow) v2(y1,y2)
               on (v1.x1)::int4 = (v2.y2)::int4) subq1
    on ((i1.fields->>'f1')::int4 = (subq1.x2)::int4)
  on ((t1.fields->>'unique2')::int4 = (subq1.d1)::int4)
  left join tenk1 t2
  on ((subq1.y1)::int4 = (t2.fields->>'unique1')::int4)
where (t1.fields->>'unique2')::int4 < 42 and (t1.fields->>'stringu1')::name > t2.fields->>'stringu2';
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Nested Loop
   ->  Foreign Scan on int4_tbl i1
   ->  Materialize
         ->  Hash Join
               Hash Cond: ((11) = ((t1.fields ->> 'unique2'::text))::integer)
               Join Filter: (((t1.fields ->> 'stringu1'::text))::name > (t2.fields ->> 'stringu2'::text))
               ->  Nested Loop
                     ->  Seq Scan on onerow
                     ->  Hash Join
                           Hash Cond: (((t2.fields ->> 'unique1'::text))::integer = (3))
                           ->  Foreign Scan on tenk1 t2
                           ->  Hash
                                 ->  Seq Scan on onerow onerow_1
               ->  Hash
                     ->  Foreign Scan on tenk1 t1
(15 rows)

--Testcase 291:
select (t1.fields->>'unique2')::int4 unique2, (t1.fields->>'stringu1')::name stringu1, (t2.fields->>'unique1')::int4 unique1, (t2.fields->>'stringu2')::name stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (select 1,0 from onerow) v1(x1,x2)
               left join (select 3,1 from onerow) v2(y1,y2)
               on (v1.x1)::int4 = (v2.y2)::int4) subq1
    on ((i1.fields->>'f1')::int4 = (subq1.x2)::int4)
  on ((t1.fields->>'unique2')::int4 = (subq1.d1)::int4)
  left join tenk1 t2
  on ((subq1.y1)::int4 = (t2.fields->>'unique1')::int4)
where (t1.fields->>'unique2')::int4 < 42 and (t1.fields->>'stringu1')::name > t2.fields->>'stringu2';
 unique2 | stringu1 | unique1 | stringu2 
---------+----------+---------+----------
      11 | WFAAAA   |       3 | LKIAAA
(1 row)

-- variant that isn't quite a star-schema case
--Testcase 292:
select ss1.d1 from
  tenk1 as t1
  inner join tenk1 as t2
  on (t1.fields->>'tenthous')::int4 = (t2.fields->>'ten')::int4
  inner join
    int8_tbl as i8
    left join int4_tbl as i4
      inner join (select 64::information_schema.cardinal_number as d1
                  from tenk1 t3,
                       lateral (select abs((t3.fields->>'unique1')::int4) + random()) ss0(x)
                  where (t3.fields->>'fivethous')::int4 < 0) as ss1
      on (i4.fields->>'f1')::int4 = ss1.d1
    on (i8.fields->>'q1')::int8 = (i4.fields->>'f1')::int4
  on (t1.fields->>'tenthous')::int4 = ss1.d1
where (t1.fields->>'unique1')::int4 < (i4.fields->>'f1')::int4;
 d1 
----
(0 rows)

-- this variant is foldable by the remove-useless-RESULT-RTEs code
--Testcase 293:
explain (costs off)
select (t1.fields->>'unique2')::int4 unique2, (t1.fields->>'stringu1')::name stringu1, (t2.fields->>'unique1')::int4 unique1, (t2.fields->>'stringu2')::name stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (values(1,0)) v1(x1,x2)
               left join (values(3,1)) v2(y1,y2)
               on v1.x1 = v2.y2) subq1
    on ((i1.fields->>'f1')::int4 = subq1.x2)
  on ((t1.fields->>'unique2')::int4 = subq1.d1)
  left join tenk1 t2
  on (subq1.y1 = (t2.fields->>'unique1')::int4)
where (t1.fields->>'unique2')::int4 < 42 and (t1.fields->>'stringu1')::name > (t2.fields->>'stringu2')::name;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (((t2.fields ->> 'unique1'::text))::integer = (3))
   Join Filter: (((t1.fields ->> 'stringu1'::text))::name > ((t2.fields ->> 'stringu2'::text))::name)
   ->  Foreign Scan on tenk1 t2
   ->  Hash
         ->  Hash Join
               Hash Cond: (((t1.fields ->> 'unique2'::text))::integer = (11))
               ->  Foreign Scan on tenk1 t1
               ->  Hash
                     ->  Foreign Scan on int4_tbl i1
(10 rows)

--Testcase 294:
select (t1.fields->>'unique2')::int4 unique2, (t1.fields->>'stringu1')::name stringu1, (t2.fields->>'unique1')::int4 unique1, (t2.fields->>'stringu2')::name stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (values(1,0)) v1(x1,x2)
               left join (values(3,1)) v2(y1,y2)
               on v1.x1 = v2.y2) subq1
    on ((i1.fields->>'f1')::int4 = subq1.x2)
  on ((t1.fields->>'unique2')::int4 = subq1.d1)
  left join tenk1 t2
  on (subq1.y1 = (t2.fields->>'unique1')::int4)
where (t1.fields->>'unique2')::int4 < 42 and (t1.fields->>'stringu1')::name > (t2.fields->>'stringu2')::name;
 unique2 | stringu1 | unique1 | stringu2 
---------+----------+---------+----------
      11 | WFAAAA   |       3 | LKIAAA
(1 row)

-- Here's a variant that we can't fold too aggressively, though,
-- or we end up with noplace to evaluate the lateral PHV
--Testcase 295:
explain (verbose, costs off)
select * from
  (select 1 as x) ss1 left join (select 2 as y) ss2 on (true),
  lateral (select ss2.y as z limit 1) ss3;
        QUERY PLAN         
---------------------------
 Nested Loop
   Output: 1, (2), ((2))
   ->  Result
         Output: 2
   ->  Limit
         Output: ((2))
         ->  Result
               Output: (2)
(8 rows)

--Testcase 296:
select * from
  (select 1 as x) ss1 left join (select 2 as y) ss2 on (true),
  lateral (select ss2.y as z limit 1) ss3;
 x | y | z 
---+---+---
 1 | 2 | 2
(1 row)

-- Test proper handling of appendrel PHVs during useless-RTE removal
--Testcase 297:
explain (costs off)
select * from
  (select 0 as z) as t1
  left join
  (select true as a) as t2
  on true,
  lateral (select true as b
           union all
           select a as b) as t3
where b;
              QUERY PLAN               
---------------------------------------
 Nested Loop
   ->  Result
   ->  Append
         ->  Result
         ->  Result
               One-Time Filter: (true)
(6 rows)

--Testcase 298:
select * from
  (select 0 as z) as t1
  left join
  (select true as a) as t2
  on true,
  lateral (select true as b
           union all
           select a as b) as t3
where b;
 z | a | b 
---+---+---
 0 | t | t
 0 | t | t
(2 rows)

--
-- test inlining of immutable functions
--
--Testcase 299:
create function f_immutable_int4(i integer) returns integer as
$$ begin return i; end; $$ language plpgsql immutable;
-- check optimization of function scan with join
--Testcase 300:
explain (costs off)
select (fields->>'unique1')::int4 unique1 from tenk1, (select * from f_immutable_int4(1) x) x
where x = (fields->>'unique1')::int4;
      QUERY PLAN       
-----------------------
 Foreign Scan on tenk1
(1 row)

--Testcase 301:
explain (verbose, costs off)
select (fields->>'unique1')::int4 unique1, x.*
from tenk1, (select *, random() from f_immutable_int4(1) x) x
where x = (fields->>'unique1')::int4;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Hash Join
   Output: ((tenk1.fields ->> 'unique1'::text))::integer, (1), (random())
   Hash Cond: (((tenk1.fields ->> 'unique1'::text))::integer = (1))
   ->  Foreign Scan on public.tenk1
         Output: tenk1.fields
         InfluxDB query: SELECT * FROM "tenk"
   ->  Hash
         Output: (1), (random())
         ->  Result
               Output: 1, random()
(10 rows)

--Testcase 302:
explain (costs off)
select (fields->>'unique1')::int4 unique1 from tenk1, f_immutable_int4(1) x where x = (fields->>'unique1')::int4;
      QUERY PLAN       
-----------------------
 Foreign Scan on tenk1
(1 row)

--Testcase 303:
explain (costs off)
select (fields->>'unique1')::int4 unique1 from tenk1, lateral f_immutable_int4(1) x where x = (fields->>'unique1')::int4;
      QUERY PLAN       
-----------------------
 Foreign Scan on tenk1
(1 row)

--Testcase 569:
explain (costs off)
select (fields->>'unique1')::int4 unique1 from tenk1, lateral f_immutable_int4(1) x where x in (select 17);
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

--Testcase 304:
explain (costs off)
select (fields->>'unique1')::int4 unique1, x from tenk1 join f_immutable_int4(1) x on (fields->>'unique1')::int4 = x;
      QUERY PLAN       
-----------------------
 Foreign Scan on tenk1
(1 row)

--Testcase 305:
explain (costs off)
select (fields->>'unique1')::int4 unique1, x from tenk1 left join f_immutable_int4(1) x on (fields->>'unique1')::int4 = x;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Nested Loop Left Join
   Join Filter: (((tenk1.fields ->> 'unique1'::text))::integer = 1)
   ->  Foreign Scan on tenk1
   ->  Materialize
         ->  Result
(5 rows)

--Testcase 306:
explain (costs off)
select (fields->>'unique1')::int4 unique1, x from tenk1 right join f_immutable_int4(1) x on (fields->>'unique1')::int4 = x;
         QUERY PLAN          
-----------------------------
 Nested Loop Left Join
   ->  Result
   ->  Foreign Scan on tenk1
(3 rows)

--Testcase 307:
explain (costs off)
select (fields->>'unique1')::int4 unique1, x from tenk1 full join f_immutable_int4(1) x on (fields->>'unique1')::int4 = x;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Hash Full Join
   Hash Cond: (((tenk1.fields ->> 'unique1'::text))::integer = (1))
   ->  Foreign Scan on tenk1
   ->  Hash
         ->  Result
(5 rows)

-- check that pullup of a const function allows further const-folding
--Testcase 308:
explain (costs off)
select (fields->>'unique1')::int4 unique1 from tenk1, f_immutable_int4(1) x where x = 42;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

-- test inlining of immutable functions with PlaceHolderVars
--Testcase 309:
explain (costs off)
select (nt3.fields->>'id')::int id
from nt3 as nt3
  left join
    (select nt2.*, ((nt2.fields->>'b1')::boolean or i4 = 42) AS b3
     from nt2 as nt2
       left join
         f_immutable_int4(0) i4
         on i4 = (nt2.fields->>'nt1_id')::int
    ) as ss2
    on (ss2.fields->>'id')::int = (nt3.fields->>'nt2_id')::int
where (nt3.fields->>'id')::int = 1 and (ss2.b3)::boolean;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Hash Right Join
   Hash Cond: (((nt2.fields ->> 'id'::text))::integer = ((nt3.fields ->> 'nt2_id'::text))::integer)
   Filter: ((((nt2.fields ->> 'b1'::text))::boolean OR ((0) = 42)))
   ->  Nested Loop Left Join
         Join Filter: (0 = ((nt2.fields ->> 'nt1_id'::text))::integer)
         ->  Foreign Scan on nt2
         ->  Materialize
               ->  Result
   ->  Hash
         ->  Foreign Scan on nt3
(10 rows)

--Testcase 310:
drop function f_immutable_int4(int);
-- test inlining when function returns composite
--Testcase 311:
create function mki8(bigint, bigint) returns int8_tbl as
$$select row('{"q1" : ' || cast($1 as text) || ', "q2" : ' || cast($2 as text) || '}')::int8_tbl$$ language sql;
--Testcase 312:
create function mki4(int) returns int4_tbl as
$$select row('{"f1" : ' || cast($1 as text) || '}')::int4_tbl$$ language sql;
--Testcase 313:
explain (verbose, costs off)
select * from mki8(1, 2);
                       QUERY PLAN                        
---------------------------------------------------------
 Function Scan on mki8
   Output: fields
   Function Call: '("{""q1"": 1, ""q2"": 2}")'::int8_tbl
(3 rows)

--Testcase 314:
select * from mki8(1, 2);
       fields       
--------------------
 {"q1": 1, "q2": 2}
(1 row)

--Testcase 315:
explain (verbose, costs off)
select * from mki4(42);
                  QUERY PLAN                   
-----------------------------------------------
 Function Scan on mki4
   Output: fields
   Function Call: '("{""f1"": 42}")'::int4_tbl
(3 rows)

--Testcase 316:
select * from mki4(42);
   fields   
------------
 {"f1": 42}
(1 row)

--Testcase 317:
drop function mki8(bigint, bigint);
--Testcase 318:
drop function mki4(int);
--
-- test extraction of restriction OR clauses from join OR clause
-- (we used to only do this for indexable clauses)
--
--Testcase 319:
explain (costs off)
select * from (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 a) a join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 b) b on
  ((a.unique1)::int4 = 1 and (b.unique1)::int4 = 2) or ((a.unique2)::int4 = 3 and (b.hundred)::int4 = 4);
                                                                                                           QUERY PLAN                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Join Filter: (((((a.fields ->> 'unique1'::text))::integer = 1) AND (((b.fields ->> 'unique1'::text))::integer = 2)) OR ((((a.fields ->> 'unique2'::text))::integer = 3) AND (((b.fields ->> 'hundred'::text))::integer = 4)))
   ->  Foreign Scan on tenk1 a
   ->  Materialize
         ->  Foreign Scan on tenk1 b
(5 rows)

--Testcase 320:
explain (costs off)
select * from (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 a) a join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 b) b on
  ((a.unique1)::int4 = 1 and (b.unique1)::int4 = 2) or ((a.unique2)::int4 = 3 and (b.ten)::int4 = 4);
                                                                                                         QUERY PLAN                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Join Filter: (((((a.fields ->> 'unique1'::text))::integer = 1) AND (((b.fields ->> 'unique1'::text))::integer = 2)) OR ((((a.fields ->> 'unique2'::text))::integer = 3) AND (((b.fields ->> 'ten'::text))::integer = 4)))
   ->  Foreign Scan on tenk1 a
   ->  Materialize
         ->  Foreign Scan on tenk1 b
(5 rows)

--Testcase 321:
explain (costs off)
select * from (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 a) a join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 b) b on
  ((a.unique1)::int4 = 1 and (b.unique1)::int4 = 2) or
  (((a.unique2)::int4 = 3 or (a.unique2)::int4 = 7) and (b.hundred)::int4 = 4);
                                                                                                                                      QUERY PLAN                                                                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Join Filter: (((((a.fields ->> 'unique1'::text))::integer = 1) AND (((b.fields ->> 'unique1'::text))::integer = 2)) OR (((((a.fields ->> 'unique2'::text))::integer = 3) OR (((a.fields ->> 'unique2'::text))::integer = 7)) AND (((b.fields ->> 'hundred'::text))::integer = 4)))
   ->  Foreign Scan on tenk1 a
   ->  Materialize
         ->  Foreign Scan on tenk1 b
(5 rows)

--
-- test placement of movable quals in a parameterized join tree
--
--Testcase 322:
explain (costs off)
select * from (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 t1) t1 left join
  ((select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 t2) t2 join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 t3) t3 on (t2.thousand)::int4 = (t3.unique2)::int4)
  on (t1.hundred)::int4 = (t2.hundred)::int4 and (t1.ten)::int4 = (t3.ten)::int4
where (t1.unique1)::int4 = 1;
                                                                                           QUERY PLAN                                                                                           
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join
   Hash Cond: ((((t2.fields ->> 'hundred'::text))::integer = ((t1.fields ->> 'hundred'::text))::integer) AND (((t3.fields ->> 'ten'::text))::integer = ((t1.fields ->> 'ten'::text))::integer))
   ->  Merge Join
         Merge Cond: ((((t2.fields ->> 'thousand'::text))::integer) = (((t3.fields ->> 'unique2'::text))::integer))
         ->  Sort
               Sort Key: (((t2.fields ->> 'thousand'::text))::integer)
               ->  Foreign Scan on tenk1 t2
         ->  Sort
               Sort Key: (((t3.fields ->> 'unique2'::text))::integer)
               ->  Foreign Scan on tenk1 t3
   ->  Hash
         ->  Foreign Scan on tenk1 t1
(12 rows)

--Testcase 323:
explain (costs off)
select * from (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 t1) t1 left join
  ((select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 t2) t2 join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 t3) t3 on (t2.thousand)::int4 = (t3.unique2)::int4)
  on (t1.hundred)::int4 = (t2.hundred)::int4 and (t1.ten)::int4 + (t2.ten)::int4 = (t3.ten)::int4
where (t1.unique1)::int4 = 1;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join
   Hash Cond: (((t2.fields ->> 'hundred'::text))::integer = ((t1.fields ->> 'hundred'::text))::integer)
   Join Filter: ((((t1.fields ->> 'ten'::text))::integer + ((t2.fields ->> 'ten'::text))::integer) = ((t3.fields ->> 'ten'::text))::integer)
   ->  Merge Join
         Merge Cond: ((((t2.fields ->> 'thousand'::text))::integer) = (((t3.fields ->> 'unique2'::text))::integer))
         ->  Sort
               Sort Key: (((t2.fields ->> 'thousand'::text))::integer)
               ->  Foreign Scan on tenk1 t2
         ->  Sort
               Sort Key: (((t3.fields ->> 'unique2'::text))::integer)
               ->  Foreign Scan on tenk1 t3
   ->  Hash
         ->  Foreign Scan on tenk1 t1
(13 rows)

--Testcase 324:
explain (costs off)
select count(*) from
  (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 a) a join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 b) b on (a.unique1)::int4 = (b.unique2)::int4
  left join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 c) c on (a.unique2)::int4 = (b.unique1)::int4 and (c.thousand)::int4 = (a.thousand)::int4
  join (select (fields->>'f1')::int4 f1 from INT4_TBL) INT4_TBL on (b.thousand)::int4 = (f1)::int4;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Merge Join
         Merge Cond: ((((int4_tbl.fields ->> 'f1'::text))::integer) = (((b.fields ->> 'thousand'::text))::integer))
         ->  Sort
               Sort Key: (((int4_tbl.fields ->> 'f1'::text))::integer)
               ->  Foreign Scan on int4_tbl
         ->  Sort
               Sort Key: (((b.fields ->> 'thousand'::text))::integer)
               ->  Merge Left Join
                     Merge Cond: ((((a.fields ->> 'thousand'::text))::integer) = (((c.fields ->> 'thousand'::text))::integer))
                     Join Filter: (((a.fields ->> 'unique2'::text))::integer = ((b.fields ->> 'unique1'::text))::integer)
                     ->  Sort
                           Sort Key: (((a.fields ->> 'thousand'::text))::integer)
                           ->  Merge Join
                                 Merge Cond: ((((a.fields ->> 'unique1'::text))::integer) = (((b.fields ->> 'unique2'::text))::integer))
                                 ->  Sort
                                       Sort Key: (((a.fields ->> 'unique1'::text))::integer)
                                       ->  Foreign Scan on tenk1 a
                                 ->  Sort
                                       Sort Key: (((b.fields ->> 'unique2'::text))::integer)
                                       ->  Foreign Scan on tenk1 b
                     ->  Sort
                           Sort Key: (((c.fields ->> 'thousand'::text))::integer)
                           ->  Foreign Scan on tenk1 c
(24 rows)

--Testcase 325:
select count(*) from
  (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 a) a join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 b) b on (a.unique1)::int4 = (b.unique2)::int4
  left join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 c) c on (a.unique2)::int4 = (b.unique1)::int4 and (c.thousand)::int4 = (a.thousand)::int4
  join int4_tbl on (b.thousand)::int4 = (fields->>'f1')::int4;
 count 
-------
    10
(1 row)

--Testcase 326:
explain (costs off)
select (b.fields->>'unique1')::int4 unique1 from
  tenk1 a join tenk1 b on (a.fields->>'unique1')::int4 = (b.fields->>'unique2')::int4
  left join tenk1 c on (b.fields->>'unique1')::int4 = 42 and (c.fields->>'thousand')::int4 = (a.fields->>'thousand')::int4
  join (select (fields->>'f1')::int4 f1 from INT4_TBL i1) i1 on (b.fields->>'thousand')::int4 = (f1)::int4
  right join int4_tbl i2 on (i2.fields->>'f1')::int4 = (b.fields->>'tenthous')::int4
  order by 1;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: (((b.fields ->> 'unique1'::text))::integer)
   ->  Merge Left Join
         Merge Cond: ((((i2.fields ->> 'f1'::text))::integer) = (((b.fields ->> 'tenthous'::text))::integer))
         ->  Sort
               Sort Key: (((i2.fields ->> 'f1'::text))::integer)
               ->  Foreign Scan on int4_tbl i2
         ->  Materialize
               ->  Sort
                     Sort Key: (((b.fields ->> 'tenthous'::text))::integer)
                     ->  Merge Join
                           Merge Cond: ((((i1.fields ->> 'f1'::text))::integer) = (((b.fields ->> 'thousand'::text))::integer))
                           ->  Sort
                                 Sort Key: (((i1.fields ->> 'f1'::text))::integer)
                                 ->  Foreign Scan on int4_tbl i1
                           ->  Sort
                                 Sort Key: (((b.fields ->> 'thousand'::text))::integer)
                                 ->  Merge Left Join
                                       Merge Cond: ((((a.fields ->> 'thousand'::text))::integer) = (((c.fields ->> 'thousand'::text))::integer))
                                       Join Filter: (((b.fields ->> 'unique1'::text))::integer = 42)
                                       ->  Sort
                                             Sort Key: (((a.fields ->> 'thousand'::text))::integer)
                                             ->  Merge Join
                                                   Merge Cond: ((((a.fields ->> 'unique1'::text))::integer) = (((b.fields ->> 'unique2'::text))::integer))
                                                   ->  Sort
                                                         Sort Key: (((a.fields ->> 'unique1'::text))::integer)
                                                         ->  Foreign Scan on tenk1 a
                                                   ->  Sort
                                                         Sort Key: (((b.fields ->> 'unique2'::text))::integer)
                                                         ->  Foreign Scan on tenk1 b
                                       ->  Sort
                                             Sort Key: (((c.fields ->> 'thousand'::text))::integer)
                                             ->  Foreign Scan on tenk1 c
(33 rows)

--Testcase 327:
select (b.fields->>'unique1')::int4 unique1 from
  tenk1 a join tenk1 b on (a.fields->>'unique1')::int4 = (b.fields->>'unique2')::int4
  left join tenk1 c on (b.fields->>'unique1')::int4 = 42 and (c.fields->>'thousand')::int4 = (a.fields->>'thousand')::int4
  join (select (fields->>'f1')::int4 f1 from INT4_TBL i1) i1 on (b.fields->>'thousand')::int4 = (f1)::int4
  right join int4_tbl i2 on (i2.fields->>'f1')::int4 = (b.fields->>'tenthous')::int4
  order by 1;
 unique1 
---------
       0
        
        
        
        
(5 rows)

--Testcase 328:
explain (costs off)
select * from
(
  select unique1, q1, coalesce((unique1)::int4, -1) + (q1)::int8 as fault
  from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) int8_tbl left join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1) tenk1 on ((q2)::int8 = (unique2)::int4)
) ss
where fault = 122
order by fault;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Merge Left Join
   Merge Cond: ((((int8_tbl.fields ->> 'q2'::text))::bigint) = (((tenk1.fields ->> 'unique2'::text))::integer))
   Filter: ((COALESCE(((tenk1.fields ->> 'unique1'::text))::integer, '-1'::integer) + ((int8_tbl.fields ->> 'q1'::text))::bigint) = 122)
   ->  Sort
         Sort Key: (((int8_tbl.fields ->> 'q2'::text))::bigint)
         ->  Foreign Scan on int8_tbl
   ->  Sort
         Sort Key: (((tenk1.fields ->> 'unique2'::text))::integer)
         ->  Foreign Scan on tenk1
(9 rows)

--Testcase 329:
select * from
(
  select unique1, q1, coalesce((unique1)::int4, -1) + (q1)::int8 as fault
  from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) int8_tbl left join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1) tenk1 on ((q2)::int8 = (unique2)::int4)
) ss
where fault = 122
order by fault;
 unique1 | q1  | fault 
---------+-----+-------
         | 123 |   122
(1 row)

--Testcase 330:
explain (costs off)
select * from
(values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)
left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x
left join unnest(v1ys) as u1(u1y) on u1y = v2y;
                         QUERY PLAN                          
-------------------------------------------------------------
 Nested Loop Left Join
   ->  Values Scan on "*VALUES*"
   ->  Hash Right Join
         Hash Cond: (u1.u1y = "*VALUES*_1".column2)
         Filter: ("*VALUES*_1".column1 = "*VALUES*".column1)
         ->  Function Scan on unnest u1
         ->  Hash
               ->  Values Scan on "*VALUES*_1"
(8 rows)

--Testcase 331:
select * from
(values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)
left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x
left join unnest(v1ys) as u1(u1y) on u1y = v2y;
 v1x |  v1ys   | v2x | v2y | u1y 
-----+---------+-----+-----+-----
   1 | {10,20} |   1 |  10 |  10
   2 | {20,30} |   2 |  20 |  20
(2 rows)

--
-- test handling of potential equivalence clauses above outer joins
--
--Testcase 332:
explain (costs off)
select q1, unique2, thousand, hundred
  from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL a) a left join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 b) b on (q1)::int8 = (unique2)::int4
  where coalesce((thousand)::int4,123) = (q1)::int8 and (q1)::int8 = coalesce((hundred)::int4,123);
                                                                                                       QUERY PLAN                                                                                                       
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Left Join
   Merge Cond: ((((a.fields ->> 'q1'::text))::bigint) = (((b.fields ->> 'unique2'::text))::integer))
   Filter: ((COALESCE(((b.fields ->> 'thousand'::text))::integer, 123) = (((a.fields ->> 'q1'::text))::bigint)) AND ((((a.fields ->> 'q1'::text))::bigint) = COALESCE(((b.fields ->> 'hundred'::text))::integer, 123)))
   ->  Sort
         Sort Key: (((a.fields ->> 'q1'::text))::bigint)
         ->  Foreign Scan on int8_tbl a
   ->  Sort
         Sort Key: (((b.fields ->> 'unique2'::text))::integer)
         ->  Foreign Scan on tenk1 b
(9 rows)

--Testcase 333:
select q1, unique2, thousand, hundred
  from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL a) a left join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 b) b on (q1)::int8 = (unique2)::int4
  where coalesce((thousand)::int4,123) = (q1)::int8 and (q1)::int8 = coalesce((hundred)::int4,123);
 q1 | unique2 | thousand | hundred 
----+---------+----------+---------
(0 rows)

--Testcase 334:
explain (costs off)
select f1, unique2, case when (unique2)::int4 is null then (f1)::int4 else 0 end
  from (select (fields->>'f1')::int4 f1 from INT4_TBL a) a left join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 b) b on (f1)::int4 = (unique2)::int4
  where (case when (unique2)::int4 is null then (f1)::int4 else 0 end) = 0;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Merge Left Join
   Merge Cond: ((((a.fields ->> 'f1'::text))::integer) = (((b.fields ->> 'unique2'::text))::integer))
   Filter: (CASE WHEN (((b.fields ->> 'unique2'::text))::integer IS NULL) THEN (((a.fields ->> 'f1'::text))::integer) ELSE 0 END = 0)
   ->  Sort
         Sort Key: (((a.fields ->> 'f1'::text))::integer)
         ->  Foreign Scan on int4_tbl a
   ->  Sort
         Sort Key: (((b.fields ->> 'unique2'::text))::integer)
         ->  Foreign Scan on tenk1 b
(9 rows)

--Testcase 335:
select f1, unique2, case when (unique2)::int4 is null then (f1)::int4 else 0 end
  from (select (fields->>'f1')::int4 f1 from INT4_TBL a) a left join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 b) b on (f1)::int4 = (unique2)::int4
  where (case when (unique2)::int4 is null then (f1)::int4 else 0 end) = 0;
 f1 | unique2 | case 
----+---------+------
  0 |       0 |    0
(1 row)

--
-- another case with equivalence clauses above outer joins (bug #8591)
--
--Testcase 336:
explain (costs off)
select (a.fields->>'unique1')::int4 unique1, (b.fields->>'unique1')::int4 unique1, (c.fields->>'unique1')::int4 unique1, coalesce((b.fields->>'twothousand')::int4, (a.fields->>'twothousand')::int4)
  from tenk1 a left join tenk1 b on (b.fields->>'thousand')::int4 = (a.fields->>'unique1')::int4                        left join tenk1 c on (c.fields->>'unique2')::int4 = coalesce((b.fields->>'twothousand')::int4, (a.fields->>'twothousand')::int4)
  where (a.fields->>'unique2')::int4 < 10 and coalesce((b.fields->>'twothousand')::int4, (a.fields->>'twothousand')::int4) = 44;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Left Join
   Hash Cond: (COALESCE(((b.fields ->> 'twothousand'::text))::integer, ((a.fields ->> 'twothousand'::text))::integer) = ((c.fields ->> 'unique2'::text))::integer)
   ->  Merge Left Join
         Merge Cond: ((((a.fields ->> 'unique1'::text))::integer) = (((b.fields ->> 'thousand'::text))::integer))
         Filter: (COALESCE(((b.fields ->> 'twothousand'::text))::integer, ((a.fields ->> 'twothousand'::text))::integer) = 44)
         ->  Sort
               Sort Key: (((a.fields ->> 'unique1'::text))::integer)
               ->  Foreign Scan on tenk1 a
         ->  Sort
               Sort Key: (((b.fields ->> 'thousand'::text))::integer)
               ->  Foreign Scan on tenk1 b
   ->  Hash
         ->  Foreign Scan on tenk1 c
(13 rows)

--Testcase 337:
select (a.fields->>'unique1')::int4 unique1, (b.fields->>'unique1')::int4 unique1, (c.fields->>'unique1')::int4 unique1, coalesce((b.fields->>'twothousand')::int4, (a.fields->>'twothousand')::int4)
  from tenk1 a left join tenk1 b on (b.fields->>'thousand')::int4 = (a.fields->>'unique1')::int4                        left join tenk1 c on (c.fields->>'unique2')::int4 = coalesce((b.fields->>'twothousand')::int4, (a.fields->>'twothousand')::int4)
  where (a.fields->>'unique2')::int4 < 10 and coalesce((b.fields->>'twothousand')::int4, (a.fields->>'twothousand')::int4) = 44;
 unique1 | unique1 | unique1 | coalesce 
---------+---------+---------+----------
(0 rows)

--
-- check handling of join aliases when flattening multiple levels of subquery
--
--Testcase 338:
explain (verbose, costs off)
select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from
  (values (0),(1)) foo1(join_key)
left join
  (select join_key, bug_field from
    (select ss1.join_key, ss1.bug_field from
      (select (fields->>'f1')::int4 as join_key, 666 as bug_field from int4_tbl i1) ss1
    ) foo2
   left join
    (select (fields->>'unique2')::int4 as join_key from tenk1 i2) ss2
   using (join_key)
  ) foo3
using (join_key);
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Hash Right Join
   Output: "*VALUES*".column1, ((i1.fields ->> 'f1'::text))::integer, (666)
   Hash Cond: (((i1.fields ->> 'f1'::text))::integer = "*VALUES*".column1)
   ->  Merge Left Join
         Output: i1.fields, 666
         Merge Cond: ((((i1.fields ->> 'f1'::text))::integer) = (((i2.fields ->> 'unique2'::text))::integer))
         ->  Sort
               Output: i1.fields, (((i1.fields ->> 'f1'::text))::integer)
               Sort Key: (((i1.fields ->> 'f1'::text))::integer)
               ->  Foreign Scan on public.int4_tbl i1
                     Output: i1.fields, ((i1.fields ->> 'f1'::text))::integer
                     InfluxDB query: SELECT * FROM "int4_tbl"
         ->  Sort
               Output: i2.fields, (((i2.fields ->> 'unique2'::text))::integer)
               Sort Key: (((i2.fields ->> 'unique2'::text))::integer)
               ->  Foreign Scan on public.tenk1 i2
                     Output: i2.fields, ((i2.fields ->> 'unique2'::text))::integer
                     InfluxDB query: SELECT * FROM "tenk"
   ->  Hash
         Output: "*VALUES*".column1
         ->  Values Scan on "*VALUES*"
               Output: "*VALUES*".column1
(22 rows)

--Testcase 339:
select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from
  (values (0),(1)) foo1(join_key)
left join
  (select join_key, bug_field from
    (select ss1.join_key, ss1.bug_field from
      (select (fields->>'f1')::int4 as join_key, 666 as bug_field from int4_tbl i1) ss1
    ) foo2
   left join
    (select (fields->>'unique2')::int4 as join_key from tenk1 i2) ss2
   using (join_key)
  ) foo3
using (join_key);
 foo1_id | foo3_id | bug_field 
---------+---------+-----------
       0 |       0 |       666
       1 |         |          
(2 rows)

--
-- test successful handling of nested outer joins with degenerate join quals
--
--Testcase 340:
create foreign table text_tbl(fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 341:
explain (verbose, costs off)
select t1.* from
  (select fields->>'f1' f1 from text_tbl t1) t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2) b2
      on ((i8.fields->>'q1')::int8 = (b2.fields->>'q1')::int8)
    on ((b2.d2)::int8 = (b1.fields->>'q2')::int8)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on ((i8.fields->>'q2')::int8 = (i4.fields->>'f1')::int4);
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Merge Right Join
   Output: (t1.fields ->> 'f1'::text)
   Merge Cond: ((((i4.fields ->> 'f1'::text))::integer) = (((i8.fields ->> 'q2'::text))::bigint))
   ->  Sort
         Output: i4.fields, (((i4.fields ->> 'f1'::text))::integer)
         Sort Key: (((i4.fields ->> 'f1'::text))::integer)
         ->  Foreign Scan on public.int4_tbl i4
               Output: i4.fields, ((i4.fields ->> 'f1'::text))::integer
               InfluxDB query: SELECT * FROM "int4_tbl"
   ->  Materialize
         Output: t1.fields, i8.fields, (((i8.fields ->> 'q2'::text))::bigint)
         ->  Sort
               Output: t1.fields, i8.fields, (((i8.fields ->> 'q2'::text))::bigint)
               Sort Key: (((i8.fields ->> 'q2'::text))::bigint)
               ->  Nested Loop Left Join
                     Output: t1.fields, i8.fields, ((i8.fields ->> 'q2'::text))::bigint
                     Join Filter: ((t1.fields ->> 'f1'::text) = '***'::text)
                     ->  Foreign Scan on public.text_tbl t1
                           Output: t1.fields
                           InfluxDB query: SELECT * FROM "text_tbl"
                     ->  Materialize
                           Output: i8.fields
                           ->  Merge Left Join
                                 Output: i8.fields
                                 Merge Cond: ((((i8b1.fields ->> 'q2'::text))::bigint) = (((NULL::integer))::bigint))
                                 ->  Sort
                                       Output: i8b1.fields, (((i8b1.fields ->> 'q2'::text))::bigint)
                                       Sort Key: (((i8b1.fields ->> 'q2'::text))::bigint)
                                       ->  Foreign Scan on public.int8_tbl i8b1
                                             Output: i8b1.fields, ((i8b1.fields ->> 'q2'::text))::bigint
                                             InfluxDB query: SELECT * FROM "int8_tbl"
                                 ->  Sort
                                       Output: i8.fields, (NULL::integer), (((NULL::integer))::bigint)
                                       Sort Key: (((NULL::integer))::bigint)
                                       ->  Merge Join
                                             Output: i8.fields, (NULL::integer), ((NULL::integer))::bigint
                                             Merge Cond: ((((i8b2.fields ->> 'q1'::text))::bigint) = (((i8.fields ->> 'q1'::text))::bigint))
                                             ->  Sort
                                                   Output: i8b2.fields, (NULL::integer), (((i8b2.fields ->> 'q1'::text))::bigint)
                                                   Sort Key: (((i8b2.fields ->> 'q1'::text))::bigint)
                                                   ->  Foreign Scan on public.int8_tbl i8b2
                                                         Output: i8b2.fields, NULL::integer, ((i8b2.fields ->> 'q1'::text))::bigint
                                                         InfluxDB query: SELECT * FROM "int8_tbl"
                                             ->  Sort
                                                   Output: i8.fields, (((i8.fields ->> 'q1'::text))::bigint)
                                                   Sort Key: (((i8.fields ->> 'q1'::text))::bigint)
                                                   ->  Foreign Scan on public.int8_tbl i8
                                                         Output: i8.fields, ((i8.fields ->> 'q1'::text))::bigint
                                                         InfluxDB query: SELECT * FROM "int8_tbl"
(49 rows)

--Testcase 342:
select t1.* from
  (select fields->>'f1' f1 from text_tbl t1) t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2) b2
      on ((i8.fields->>'q1')::int8 = (b2.fields->>'q1')::int8)
    on ((b2.d2)::int8 = (b1.fields->>'q2')::int8)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on ((i8.fields->>'q2')::int8 = (i4.fields->>'f1')::int4);
        f1         
-------------------
 doh!
 hi de ho neighbor
(2 rows)

--Testcase 343:
explain (verbose, costs off)
select t1.* from
  (select fields->>'f1' f1 from text_tbl t1) t1
  left join (select *, '***'::text as d1 from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8b1) i8b1 ) b1
    left join (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8) i8
      left join (select *, null::int as d2 from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8b2) i8b2, (select (fields->>'f1')::int4 f1 from INT4_TBL i4b2) i4b2) b2
      on ((i8.q1)::int8 = (b2.q1)::int8)
    on ((b2.d2)::int8 = (b1.q2)::int8)
  on (t1.f1 = b1.d1)
  left join (select (fields->>'f1')::int4 f1 from INT4_TBL i4) i4
  on ((i8.q2)::int8 = (i4.f1)::int4);
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Right Join
   Output: (t1.fields ->> 'f1'::text)
   Merge Cond: ((((i4.fields ->> 'f1'::text))::integer) = (((i8.fields ->> 'q2'::text))::bigint))
   ->  Sort
         Output: i4.fields, (((i4.fields ->> 'f1'::text))::integer)
         Sort Key: (((i4.fields ->> 'f1'::text))::integer)
         ->  Foreign Scan on public.int4_tbl i4
               Output: i4.fields, ((i4.fields ->> 'f1'::text))::integer
               InfluxDB query: SELECT * FROM "int4_tbl"
   ->  Materialize
         Output: t1.fields, i8.fields, (((i8.fields ->> 'q2'::text))::bigint)
         ->  Sort
               Output: t1.fields, i8.fields, (((i8.fields ->> 'q2'::text))::bigint)
               Sort Key: (((i8.fields ->> 'q2'::text))::bigint)
               ->  Nested Loop Left Join
                     Output: t1.fields, i8.fields, ((i8.fields ->> 'q2'::text))::bigint
                     Join Filter: ((t1.fields ->> 'f1'::text) = '***'::text)
                     ->  Foreign Scan on public.text_tbl t1
                           Output: t1.fields
                           InfluxDB query: SELECT * FROM "text_tbl"
                     ->  Materialize
                           Output: i8.fields
                           ->  Merge Left Join
                                 Output: i8.fields
                                 Merge Cond: ((((i8b1.fields ->> 'q2'::text))::bigint) = (((NULL::integer))::bigint))
                                 ->  Sort
                                       Output: i8b1.fields, (((i8b1.fields ->> 'q2'::text))::bigint)
                                       Sort Key: (((i8b1.fields ->> 'q2'::text))::bigint)
                                       ->  Foreign Scan on public.int8_tbl i8b1
                                             Output: i8b1.fields, ((i8b1.fields ->> 'q2'::text))::bigint
                                             InfluxDB query: SELECT * FROM "int8_tbl"
                                 ->  Materialize
                                       Output: i8.fields, (NULL::integer), (((NULL::integer))::bigint)
                                       ->  Sort
                                             Output: i8.fields, (NULL::integer), (((NULL::integer))::bigint)
                                             Sort Key: (((NULL::integer))::bigint)
                                             ->  Merge Left Join
                                                   Output: i8.fields, (NULL::integer), ((NULL::integer))::bigint
                                                   Merge Cond: ((((i8.fields ->> 'q1'::text))::bigint) = (((i8b2.fields ->> 'q1'::text))::bigint))
                                                   ->  Sort
                                                         Output: i8.fields, (((i8.fields ->> 'q1'::text))::bigint)
                                                         Sort Key: (((i8.fields ->> 'q1'::text))::bigint)
                                                         ->  Foreign Scan on public.int8_tbl i8
                                                               Output: i8.fields, ((i8.fields ->> 'q1'::text))::bigint
                                                               InfluxDB query: SELECT * FROM "int8_tbl"
                                                   ->  Materialize
                                                         Output: i8b2.fields, (NULL::integer), (((i8b2.fields ->> 'q1'::text))::bigint)
                                                         ->  Sort
                                                               Output: i8b2.fields, (NULL::integer), (((i8b2.fields ->> 'q1'::text))::bigint)
                                                               Sort Key: (((i8b2.fields ->> 'q1'::text))::bigint)
                                                               ->  Nested Loop
                                                                     Output: i8b2.fields, NULL::integer, ((i8b2.fields ->> 'q1'::text))::bigint
                                                                     ->  Foreign Scan on public.int4_tbl i4b2
                                                                           InfluxDB query: SELECT * FROM "int4_tbl"
                                                                     ->  Materialize
                                                                           Output: i8b2.fields
                                                                           ->  Foreign Scan on public.int8_tbl i8b2
                                                                                 Output: i8b2.fields
                                                                                 InfluxDB query: SELECT * FROM "int8_tbl"
(59 rows)

--Testcase 344:
select t1.* from
  (select fields->>'f1' f1 from text_tbl t1) t1
  left join (select *, '***'::text as d1 from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8b1) i8b1) b1
    left join (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8) i8
      left join (select *, null::int as d2 from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8b2) i8b2, (select (fields->>'f1')::int4 f1 from INT4_TBL i4b2) i4b2) b2
      on ((i8.q1)::int8 = (b2.q1)::int8)
    on ((b2.d2)::int8 = (b1.q2)::int8)
  on (t1.f1 = b1.d1)
  left join (select (fields->>'f1')::int4 f1 from INT4_TBL i4) i4
  on ((i8.q2)::int8 = (i4.f1)::int4);
        f1         
-------------------
 doh!
 hi de ho neighbor
(2 rows)

--Testcase 345:
explain (verbose, costs off)
select t1.* from
  (select fields->>'f1' f1 from text_tbl t1) t1
  left join (select *, '***'::text as d1 from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8b1) i8b1) b1
    left join (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8) i8
      left join (select *, null::int as d2 from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8b2) i8b2, (select (fields->>'f1')::int4 f1 from INT4_TBL i4b2) i4b2
                 where (q1)::int8 = (f1)::int8) b2
      on ((i8.q1)::int8 = (b2.q1)::int8)
    on ((b2.d2)::int8 = (b1.q2)::int8)
  on (t1.f1 = b1.d1)
  left join (select (fields->>'f1')::int4 f1 from INT4_TBL i4) i4
  on ((i8.q2)::int8 = (i4.f1)::int4);
                                                                                 QUERY PLAN                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Right Join
   Output: (t1.fields ->> 'f1'::text)
   Merge Cond: ((((i4.fields ->> 'f1'::text))::integer) = (((i8.fields ->> 'q2'::text))::bigint))
   ->  Sort
         Output: i4.fields, (((i4.fields ->> 'f1'::text))::integer)
         Sort Key: (((i4.fields ->> 'f1'::text))::integer)
         ->  Foreign Scan on public.int4_tbl i4
               Output: i4.fields, ((i4.fields ->> 'f1'::text))::integer
               InfluxDB query: SELECT * FROM "int4_tbl"
   ->  Materialize
         Output: t1.fields, i8.fields, (((i8.fields ->> 'q2'::text))::bigint)
         ->  Sort
               Output: t1.fields, i8.fields, (((i8.fields ->> 'q2'::text))::bigint)
               Sort Key: (((i8.fields ->> 'q2'::text))::bigint)
               ->  Nested Loop Left Join
                     Output: t1.fields, i8.fields, ((i8.fields ->> 'q2'::text))::bigint
                     Join Filter: ((t1.fields ->> 'f1'::text) = '***'::text)
                     ->  Foreign Scan on public.text_tbl t1
                           Output: t1.fields
                           InfluxDB query: SELECT * FROM "text_tbl"
                     ->  Materialize
                           Output: i8.fields
                           ->  Merge Left Join
                                 Output: i8.fields
                                 Merge Cond: ((((i8b1.fields ->> 'q2'::text))::bigint) = (((NULL::integer))::bigint))
                                 ->  Sort
                                       Output: i8b1.fields, (((i8b1.fields ->> 'q2'::text))::bigint)
                                       Sort Key: (((i8b1.fields ->> 'q2'::text))::bigint)
                                       ->  Foreign Scan on public.int8_tbl i8b1
                                             Output: i8b1.fields, ((i8b1.fields ->> 'q2'::text))::bigint
                                             InfluxDB query: SELECT * FROM "int8_tbl"
                                 ->  Materialize
                                       Output: i8.fields, (NULL::integer), (((NULL::integer))::bigint)
                                       ->  Sort
                                             Output: i8.fields, (NULL::integer), (((NULL::integer))::bigint)
                                             Sort Key: (((NULL::integer))::bigint)
                                             ->  Merge Left Join
                                                   Output: i8.fields, (NULL::integer), ((NULL::integer))::bigint
                                                   Merge Cond: ((((i8.fields ->> 'q1'::text))::bigint) = ((i8b2.fields ->> 'q1'::text))::bigint)
                                                   ->  Sort
                                                         Output: i8.fields, (((i8.fields ->> 'q1'::text))::bigint)
                                                         Sort Key: (((i8.fields ->> 'q1'::text))::bigint)
                                                         ->  Foreign Scan on public.int8_tbl i8
                                                               Output: i8.fields, ((i8.fields ->> 'q1'::text))::bigint
                                                               InfluxDB query: SELECT * FROM "int8_tbl"
                                                   ->  Materialize
                                                         Output: i8b2.fields, (NULL::integer)
                                                         ->  Merge Join
                                                               Output: i8b2.fields, NULL::integer
                                                               Merge Cond: ((((i8b2.fields ->> 'q1'::text))::bigint) = ((((i4b2.fields ->> 'f1'::text))::integer)::bigint))
                                                               ->  Sort
                                                                     Output: i8b2.fields, (((i8b2.fields ->> 'q1'::text))::bigint)
                                                                     Sort Key: (((i8b2.fields ->> 'q1'::text))::bigint)
                                                                     ->  Foreign Scan on public.int8_tbl i8b2
                                                                           Output: i8b2.fields, ((i8b2.fields ->> 'q1'::text))::bigint
                                                                           InfluxDB query: SELECT * FROM "int8_tbl"
                                                               ->  Sort
                                                                     Output: i4b2.fields, ((((i4b2.fields ->> 'f1'::text))::integer)::bigint)
                                                                     Sort Key: ((((i4b2.fields ->> 'f1'::text))::integer)::bigint)
                                                                     ->  Foreign Scan on public.int4_tbl i4b2
                                                                           Output: i4b2.fields, (((i4b2.fields ->> 'f1'::text))::integer)::bigint
                                                                           InfluxDB query: SELECT * FROM "int4_tbl"
(62 rows)

--Testcase 346:
select t1.* from
  (select fields->>'f1' f1 from text_tbl t1) t1
  left join (select *, '***'::text as d1 from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8b1) i8b1) b1
    left join (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8) i8
      left join (select *, null::int as d2 from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8b2) i8b2, (select (fields->>'f1')::int4 f1 from INT4_TBL i4b2) i4b2
                 where (q1)::int8 = (f1)::int8) b2
      on ((i8.q1)::int8 = (b2.q1)::int8)
    on ((b2.d2)::int8 = (b1.q2)::int8)
  on (t1.f1 = b1.d1)
  left join (select (fields->>'f1')::int4 f1 from INT4_TBL i4) i4
  on ((i8.q2)::int8 = (i4.f1)::int4);
        f1         
-------------------
 doh!
 hi de ho neighbor
(2 rows)

--Testcase 347:
explain (verbose, costs off)
select * from
  (select fields->>'f1' f1 from text_tbl t1) t1
  inner join (select (fields->>'q1')::int8 q1, fields->>'q2' q2 from INT8_TBL i8) i8
  on (i8.q2)::bigint = 456
  right join (select fields->>'f1' f1 from text_tbl t2) t2
  on t1.f1 = 'doh!'
  left join (select (fields->>'f1')::int4 f1 from INT4_TBL i4) i4
  on i8.q1 = i4.f1;
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Output: (t1.fields ->> 'f1'::text), ((i8.fields ->> 'q1'::text))::bigint, (i8.fields ->> 'q2'::text), (t2.fields ->> 'f1'::text), ((i4.fields ->> 'f1'::text))::integer
   ->  Foreign Scan on public.text_tbl t2
         Output: t2.fields
         InfluxDB query: SELECT * FROM "text_tbl"
   ->  Materialize
         Output: i8.fields, i4.fields, t1.fields
         ->  Nested Loop
               Output: i8.fields, i4.fields, t1.fields
               ->  Hash Right Join
                     Output: i8.fields, i4.fields
                     Hash Cond: (((i4.fields ->> 'f1'::text))::integer = ((i8.fields ->> 'q1'::text))::bigint)
                     ->  Foreign Scan on public.int4_tbl i4
                           Output: i4.fields
                           InfluxDB query: SELECT * FROM "int4_tbl"
                     ->  Hash
                           Output: i8.fields
                           ->  Foreign Scan on public.int8_tbl i8
                                 Output: i8.fields
                                 InfluxDB query: SELECT * FROM "int8_tbl" WHERE (("q2" = 456))
               ->  Materialize
                     Output: t1.fields
                     ->  Foreign Scan on public.text_tbl t1
                           Output: t1.fields
                           InfluxDB query: SELECT * FROM "text_tbl" WHERE (("f1" = 'doh!'))
(25 rows)

--Testcase 348:
select * from
  (select fields->>'f1' f1 from text_tbl t1) t1
  inner join (select (fields->>'q1')::int8 q1, fields->>'q2' q2 from INT8_TBL i8) i8
  on (i8.q2)::bigint = 456
  right join (select fields->>'f1' f1 from text_tbl t2) t2
  on t1.f1 = 'doh!'
  left join (select (fields->>'f1')::int4 f1 from INT4_TBL i4) i4
  on i8.q1 = i4.f1;
  f1  | q1  | q2  |        f1         | f1 
------+-----+-----+-------------------+----
 doh! | 123 | 456 | doh!              |   
 doh! | 123 | 456 | hi de ho neighbor |   
(2 rows)

--
-- test for appropriate join order in the presence of lateral references
--
--Testcase 349:
explain (verbose, costs off)
select * from
  (select fields->>'f1' f1 from text_tbl t1) t1
  left join (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8) i8
  on (i8.q2)::int8 = 123,
  lateral (select i8.q1, t2.fields->>'f1' f1 from text_tbl t2 limit 1) as ss
where t1.f1 = ss.f1;
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: (t1.fields ->> 'f1'::text), ((i8.fields ->> 'q1'::text))::bigint, ((i8.fields ->> 'q2'::text))::bigint, (((i8.fields ->> 'q1'::text))::bigint), ((t2.fields ->> 'f1'::text))
   Join Filter: ((t1.fields ->> 'f1'::text) = ((t2.fields ->> 'f1'::text)))
   ->  Nested Loop Left Join
         Output: t1.fields, i8.fields
         ->  Foreign Scan on public.text_tbl t1
               Output: t1.fields
               InfluxDB query: SELECT * FROM "text_tbl"
         ->  Materialize
               Output: i8.fields
               ->  Foreign Scan on public.int8_tbl i8
                     Output: i8.fields
                     InfluxDB query: SELECT * FROM "int8_tbl" WHERE (("q2" = 123))
   ->  Foreign Scan on public.text_tbl t2
         Output: ((i8.fields ->> 'q1'::text))::bigint, (t2.fields ->> 'f1'::text)
         InfluxDB query: SELECT "f1" FROM "text_tbl" LIMIT 1
(16 rows)

--Testcase 350:
select * from
  (select fields->>'f1' f1 from text_tbl t1) t1
  left join (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8) i8
  on (i8.q2)::int8 = 123,
  lateral (select i8.q1, t2.fields->>'f1' f1 from text_tbl t2 limit 1) as ss
where t1.f1 = ss.f1;
  f1  |        q1        | q2  |        q1        |  f1  
------+------------------+-----+------------------+------
 doh! | 4567890123456789 | 123 | 4567890123456789 | doh!
(1 row)

--Testcase 351:
explain (verbose, costs off)
select * from
  (select fields->>'f1' f1 from text_tbl t1) t1
  left join (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8) i8
  on (i8.q2)::bigint = 123,
  lateral (select i8.q1, t2.fields->>'f1' f1 from text_tbl t2 limit 1) as ss1,
  lateral (select ss1.* from text_tbl t3 limit 1) as ss2
where t1.f1 = ss2.f1;
                                                                                                                            QUERY PLAN                                                                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: (t1.fields ->> 'f1'::text), ((i8.fields ->> 'q1'::text))::bigint, ((i8.fields ->> 'q2'::text))::bigint, (((i8.fields ->> 'q1'::text))::bigint), ((t2.fields ->> 'f1'::text)), ((((i8.fields ->> 'q1'::text))::bigint)), (((t2.fields ->> 'f1'::text)))
   Join Filter: ((t1.fields ->> 'f1'::text) = (((t2.fields ->> 'f1'::text))))
   ->  Nested Loop
         Output: t1.fields, i8.fields, (((i8.fields ->> 'q1'::text))::bigint), ((t2.fields ->> 'f1'::text))
         ->  Nested Loop Left Join
               Output: t1.fields, i8.fields
               ->  Foreign Scan on public.text_tbl t1
                     Output: t1.fields
                     InfluxDB query: SELECT * FROM "text_tbl"
               ->  Materialize
                     Output: i8.fields
                     ->  Foreign Scan on public.int8_tbl i8
                           Output: i8.fields
                           InfluxDB query: SELECT * FROM "int8_tbl" WHERE (("q2" = 123))
         ->  Foreign Scan on public.text_tbl t2
               Output: ((i8.fields ->> 'q1'::text))::bigint, (t2.fields ->> 'f1'::text)
               InfluxDB query: SELECT "f1" FROM "text_tbl" LIMIT 1
   ->  Foreign Scan on public.text_tbl t3
         Output: (((i8.fields ->> 'q1'::text))::bigint), ((t2.fields ->> 'f1'::text))
         InfluxDB query: SELECT * FROM "text_tbl" LIMIT 1
(21 rows)

--Testcase 352:
select * from
  (select fields->>'f1' f1 from text_tbl t1) t1
  left join (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8) i8
  on (i8.q2)::bigint = 123,
  lateral (select i8.q1, t2.fields->>'f1' f1 from text_tbl t2 limit 1) as ss1,
  lateral (select ss1.* from text_tbl t3 limit 1) as ss2
where t1.f1 = ss2.f1;
  f1  |        q1        | q2  |        q1        |  f1  |        q1        |  f1  
------+------------------+-----+------------------+------+------------------+------
 doh! | 4567890123456789 | 123 | 4567890123456789 | doh! | 4567890123456789 | doh!
(1 row)

--Testcase 353:
explain (verbose, costs off)
select 1 from
  text_tbl as tt1
  inner join text_tbl as tt2 on (tt1.fields->>'f1' = 'foo')
  left join text_tbl as tt3 on (tt3.fields->>'f1' = 'foo')
  left join text_tbl as tt4 on (tt3.fields->>'f1' = tt4.fields->>'f1'),
  lateral (select tt4.fields->>'f1' as c0 from text_tbl as tt5 limit 1) as ss1
where tt1.fields->>'f1' = ss1.c0;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Nested Loop
   Output: 1
   ->  Nested Loop Left Join
         Output: tt1.fields, tt4.fields
         ->  Nested Loop
               Output: tt1.fields
               ->  Foreign Scan on public.text_tbl tt2
                     InfluxDB query: SELECT * FROM "text_tbl"
               ->  Materialize
                     Output: tt1.fields
                     ->  Foreign Scan on public.text_tbl tt1
                           Output: tt1.fields
                           InfluxDB query: SELECT * FROM "text_tbl" WHERE (("f1" = 'foo'))
         ->  Hash Left Join
               Output: tt4.fields
               Hash Cond: ((tt3.fields ->> 'f1'::text) = (tt4.fields ->> 'f1'::text))
               ->  Foreign Scan on public.text_tbl tt3
                     Output: tt3.fields
                     InfluxDB query: SELECT * FROM "text_tbl" WHERE (("f1" = 'foo'))
               ->  Hash
                     Output: tt4.fields
                     ->  Foreign Scan on public.text_tbl tt4
                           Output: tt4.fields
                           InfluxDB query: SELECT * FROM "text_tbl" WHERE (("f1" = 'foo'))
   ->  Subquery Scan on ss1
         Output: ss1.c0
         Filter: (ss1.c0 = 'foo'::text)
         ->  Foreign Scan on public.text_tbl tt5
               Output: (tt4.fields ->> 'f1'::text)
               InfluxDB query: SELECT * FROM "text_tbl" LIMIT 1
(30 rows)

--Testcase 354:
select 1 from
  text_tbl as tt1
  inner join text_tbl as tt2 on (tt1.fields->>'f1' = 'foo')
  left join text_tbl as tt3 on (tt3.fields->>'f1' = 'foo')
  left join text_tbl as tt4 on (tt3.fields->>'f1' = tt4.fields->>'f1'),
  lateral (select tt4.fields->>'f1' as c0 from text_tbl as tt5 limit 1) as ss1
where tt1.fields->>'f1' = ss1.c0;
 ?column? 
----------
(0 rows)

--
-- check a case in which a PlaceHolderVar forces join order
--
--Testcase 355:
explain (verbose, costs off)
select ss2.* from
  (select (fields->>'f1')::int4 f1 from INT4_TBL) i41
  left join (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) i8
    join (select i42.fields->>'f1' as c1, i43.fields->>'f1' as c2, 42 as c3
          from int4_tbl i42, int4_tbl i43) ss1
    on (i8.q1)::int8 = (ss1.c2)::int8
  on (i41.f1)::int4 = (ss1.c1)::int4,
  lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2
where (ss1.c2)::int8 = 0;
                                                                                                        QUERY PLAN                                                                                                         
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: (((int4_tbl.fields ->> 'f1'::text))::integer), (((int8_tbl.fields ->> 'q1'::text))::bigint), (((int8_tbl.fields ->> 'q2'::text))::bigint), ((i42.fields ->> 'f1'::text)), ((i43.fields ->> 'f1'::text)), ((42))
   ->  Nested Loop
         Output: int4_tbl.fields, i42.fields, int8_tbl.fields, i43.fields, 42
         ->  Nested Loop
               Output: int4_tbl.fields, i42.fields, int8_tbl.fields
               ->  Merge Join
                     Output: int4_tbl.fields, i42.fields
                     Merge Cond: ((((int4_tbl.fields ->> 'f1'::text))::integer) = (((i42.fields ->> 'f1'::text))::integer))
                     ->  Sort
                           Output: int4_tbl.fields, (((int4_tbl.fields ->> 'f1'::text))::integer)
                           Sort Key: (((int4_tbl.fields ->> 'f1'::text))::integer)
                           ->  Foreign Scan on public.int4_tbl
                                 Output: int4_tbl.fields, ((int4_tbl.fields ->> 'f1'::text))::integer
                                 InfluxDB query: SELECT * FROM "int4_tbl"
                     ->  Sort
                           Output: i42.fields, (((i42.fields ->> 'f1'::text))::integer)
                           Sort Key: (((i42.fields ->> 'f1'::text))::integer)
                           ->  Foreign Scan on public.int4_tbl i42
                                 Output: i42.fields, ((i42.fields ->> 'f1'::text))::integer
                                 InfluxDB query: SELECT * FROM "int4_tbl"
               ->  Materialize
                     Output: int8_tbl.fields
                     ->  Foreign Scan on public.int8_tbl
                           Output: int8_tbl.fields
                           InfluxDB query: SELECT * FROM "int8_tbl" WHERE (("q1" = 0))
         ->  Materialize
               Output: i43.fields
               ->  Foreign Scan on public.int4_tbl i43
                     Output: i43.fields
                     InfluxDB query: SELECT * FROM "int4_tbl" WHERE (("f1" = 0))
   ->  Foreign Scan on public.text_tbl
         Output: ((int4_tbl.fields ->> 'f1'::text))::integer, ((int8_tbl.fields ->> 'q1'::text))::bigint, ((int8_tbl.fields ->> 'q2'::text))::bigint, (i42.fields ->> 'f1'::text), (i43.fields ->> 'f1'::text), (42)
         InfluxDB query: SELECT * FROM "text_tbl" LIMIT 1
(34 rows)

--Testcase 356:
select ss2.* from
  (select (fields->>'f1')::int4 f1 from INT4_TBL) i41
  left join (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) i8
    join (select i42.fields->>'f1' as c1, i43.fields->>'f1' as c2, 42 as c3
          from int4_tbl i42, int4_tbl i43) ss1
    on (i8.q1)::int8 = (ss1.c2)::int8
  on (i41.f1)::int4 = (ss1.c1)::int4,
  lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2
where (ss1.c2)::int8 = 0;
 f1 | q1 | q2 | c1 | c2 | c3 
----+----+----+----+----+----
(0 rows)

--
-- test successful handling of full join underneath left join (bug #14105)
--
--Testcase 357:
explain (costs off)
select * from
  (select 1 as id) as xx
  left join
    ((select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 a1) as a1 full join (select 1 as id) as yy on ((a1.unique1)::int4 = yy.id))
  on (xx.id = coalesce(yy.id));
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Nested Loop Left Join
   ->  Result
   ->  Hash Full Join
         Hash Cond: (((a1.fields ->> 'unique1'::text))::integer = (1))
         Filter: (1 = COALESCE((1)))
         ->  Foreign Scan on tenk1 a1
         ->  Hash
               ->  Result
(8 rows)

--Testcase 358:
select * from
  (select 1 as id) as xx
  left join
    ((select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1) as a1 full join (select 1 as id) as yy on ((a1.unique1)::int4 = yy.id))
  on (xx.id = coalesce(yy.id));
 id | unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 | id 
----+---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+----
  1 |       1 |    2838 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | EFEAAA   | OOOOxx  |  1
(1 row)

--
-- test ability to push constants through outer join clauses
--
--Testcase 359:
explain (costs off)
  select * from (select (fields->>'f1')::int4 f1 from INT4_TBL a) a left join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 b) b on (f1)::int4 = (unique2)::int4 where (f1)::int4 = 0;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Hash Left Join
   Hash Cond: (((a.fields ->> 'f1'::text))::integer = ((b.fields ->> 'unique2'::text))::integer)
   ->  Foreign Scan on int4_tbl a
   ->  Hash
         ->  Foreign Scan on tenk1 b
(5 rows)

--Testcase 360:
explain (costs off)
  select * from (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 a) a full join (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, (fields->>'two')::int4 two, (fields->>'four')::int4 four, (fields->>'ten')::int4 ten, (fields->>'twenty')::int4 twenty, (fields->>'hundred')::int4 hundred, (fields->>'thousand')::int4 thousand, (fields->>'twothousand')::int4 twothousand, (fields->>'fivethous')::int4 fivethous, (fields->>'tenthous')::int4 tenthous, (fields->>'odd')::int4 odd, (fields->>'even')::int4 even, (fields->>'stringu1')::name stringu1, (fields->>'stringu2')::name stringu2, (fields->>'string4')::name string4 from tenk1 b) b using(unique2) where (unique2)::int4 = 42;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Hash Full Join
   Hash Cond: (((a.fields ->> 'unique2'::text))::integer = ((b.fields ->> 'unique2'::text))::integer)
   ->  Foreign Scan on tenk1 a
   ->  Hash
         ->  Foreign Scan on tenk1 b
(5 rows)

--
-- test that quals attached to an outer join have correct semantics,
-- specifically that they don't re-use expressions computed below the join;
-- we force a mergejoin so that coalesce(b.q1, 1) appears as a join input
--
--Testcase 361:
set enable_hashjoin to off;
--Testcase 362:
set enable_nestloop to off;
--Testcase 363:
explain (verbose, costs off)
  select (a.fields->>'q2')::int8 q2, (b.fields->>'q1')::int8 q1
    from int8_tbl a left join int8_tbl b on (a.fields->>'q2')::int8 = coalesce((b.fields->>'q1')::int8, 1)
    where coalesce((b.fields->>'q1')::int8, 1) > 0;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Merge Left Join
   Output: (((a.fields ->> 'q2'::text))::bigint), ((b.fields ->> 'q1'::text))::bigint
   Merge Cond: ((((a.fields ->> 'q2'::text))::bigint) = (COALESCE(((b.fields ->> 'q1'::text))::bigint, '1'::bigint)))
   Filter: (COALESCE(((b.fields ->> 'q1'::text))::bigint, '1'::bigint) > 0)
   ->  Sort
         Output: a.fields, (((a.fields ->> 'q2'::text))::bigint)
         Sort Key: (((a.fields ->> 'q2'::text))::bigint)
         ->  Foreign Scan on public.int8_tbl a
               Output: a.fields, ((a.fields ->> 'q2'::text))::bigint
               InfluxDB query: SELECT * FROM "int8_tbl"
   ->  Sort
         Output: b.fields, (COALESCE(((b.fields ->> 'q1'::text))::bigint, '1'::bigint))
         Sort Key: (COALESCE(((b.fields ->> 'q1'::text))::bigint, '1'::bigint))
         ->  Foreign Scan on public.int8_tbl b
               Output: b.fields, COALESCE(((b.fields ->> 'q1'::text))::bigint, '1'::bigint)
               InfluxDB query: SELECT * FROM "int8_tbl"
(16 rows)

--Testcase 364:
select (a.fields->>'q2')::int8 q2, (b.fields->>'q1')::int8 q1
  from int8_tbl a left join int8_tbl b on (a.fields->>'q2')::int8 = coalesce((b.fields->>'q1')::int8, 1)
  where coalesce((b.fields->>'q1')::int8, 1) > 0;
        q2         |        q1        
-------------------+------------------
 -4567890123456789 |                 
               123 |              123
               123 |              123
               456 |                 
  4567890123456789 | 4567890123456789
  4567890123456789 | 4567890123456789
  4567890123456789 | 4567890123456789
  4567890123456789 | 4567890123456789
  4567890123456789 | 4567890123456789
  4567890123456789 | 4567890123456789
(10 rows)

--Testcase 365:
reset enable_hashjoin;
--Testcase 366:
reset enable_nestloop;
--
-- test join removal
--
begin;
--Testcase 367:
CREATE FOREIGN TABLE a (fields jsonb OPTIONS (fields 'true')) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 615:
CREATE FOREIGN TABLE a_nsc (id int, b_id int) SERVER influxdb_svr OPTIONS (table 'a');
--Testcase 368:
CREATE FOREIGN TABLE b (fields jsonb OPTIONS (fields 'true')) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 616:
CREATE FOREIGN TABLE b_nsc (id int, c_id int) SERVER influxdb_svr OPTIONS (table 'b');
--Testcase 369:
CREATE FOREIGN TABLE c (fields jsonb OPTIONS (fields 'true')) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 617:
CREATE FOREIGN TABLE c_nsc (id int) SERVER influxdb_svr OPTIONS (table 'c');
--Testcase 370:
CREATE FOREIGN TABLE d (fields jsonb OPTIONS (fields 'true')) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 618:
CREATE FOREIGN TABLE d_nsc (a int, b int) SERVER influxdb_svr OPTIONS (table 'd');
--Testcase 371:
INSERT INTO a_nsc VALUES (0, 0), (1, NULL);
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 372:
INSERT INTO b_nsc VALUES (0, 0), (1, NULL);
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 373:
INSERT INTO c_nsc VALUES (0), (1);
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 374:
INSERT INTO d_nsc VALUES (1,3), (2,2), (3,1);
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
-- all three cases should be optimizable into a simple seqscan
--Testcase 375:
explain (costs off) SELECT a.* FROM (select (fields->>'id')::int id, (fields->>'b_id')::int b_id from a) a LEFT JOIN (select (fields->>'id')::int id, (fields->>'c_id')::int c_id from b) b ON a.b_id = b.id;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Merge Left Join
   Merge Cond: ((((a.fields ->> 'b_id'::text))::integer) = (((b.fields ->> 'id'::text))::integer))
   ->  Sort
         Sort Key: (((a.fields ->> 'b_id'::text))::integer)
         ->  Foreign Scan on a
   ->  Sort
         Sort Key: (((b.fields ->> 'id'::text))::integer)
         ->  Foreign Scan on b
(8 rows)

--Testcase 376:
explain (costs off) SELECT b.* FROM (select (fields->>'id')::int id, (fields->>'c_id')::int c_id from b) b LEFT JOIN (select (fields->>'id')::int id from c) c ON b.c_id = c.id;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Merge Left Join
   Merge Cond: ((((b.fields ->> 'c_id'::text))::integer) = (((c.fields ->> 'id'::text))::integer))
   ->  Sort
         Sort Key: (((b.fields ->> 'c_id'::text))::integer)
         ->  Foreign Scan on b
   ->  Sort
         Sort Key: (((c.fields ->> 'id'::text))::integer)
         ->  Foreign Scan on c
(8 rows)

--Testcase 377:
explain (costs off)
  SELECT a.* FROM (select (fields->>'id')::int id, (fields->>'b_id')::int b_id from a) a LEFT JOIN ((select (fields->>'id')::int id, (fields->>'c_id')::int c_id from b) b left join (select (fields->>'id')::int id from c) c on b.c_id = c.id)
  ON (a.b_id = b.id);
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Merge Right Join
   Merge Cond: ((((c.fields ->> 'id'::text))::integer) = (((b.fields ->> 'c_id'::text))::integer))
   ->  Sort
         Sort Key: (((c.fields ->> 'id'::text))::integer)
         ->  Foreign Scan on c
   ->  Sort
         Sort Key: (((b.fields ->> 'c_id'::text))::integer)
         ->  Merge Left Join
               Merge Cond: ((((a.fields ->> 'b_id'::text))::integer) = (((b.fields ->> 'id'::text))::integer))
               ->  Sort
                     Sort Key: (((a.fields ->> 'b_id'::text))::integer)
                     ->  Foreign Scan on a
               ->  Sort
                     Sort Key: (((b.fields ->> 'id'::text))::integer)
                     ->  Foreign Scan on b
(15 rows)

-- check optimization of outer join within another special join
--Testcase 378:
explain (costs off)
select (fields->>'id')::int id from a where (fields->>'id')::int in (
	select (b.fields->>'id')::int from b left join c on (b.fields->>'id')::int = (c.fields->>'id')::int
);
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (((a.fields ->> 'id'::text))::integer = ((b.fields ->> 'id'::text))::integer)
   ->  Foreign Scan on a
   ->  Hash
         ->  HashAggregate
               Group Key: (((b.fields ->> 'id'::text))::integer)
               ->  Merge Left Join
                     Merge Cond: ((((b.fields ->> 'id'::text))::integer) = (((c.fields ->> 'id'::text))::integer))
                     ->  Sort
                           Sort Key: (((b.fields ->> 'id'::text))::integer)
                           ->  Foreign Scan on b
                     ->  Sort
                           Sort Key: (((c.fields ->> 'id'::text))::integer)
                           ->  Foreign Scan on c
(14 rows)

-- check that join removal works for a left join when joining a subquery
-- that is guaranteed to be unique by its GROUP BY clause
--Testcase 379:
explain (costs off)
select d.* from (select (fields->>'a')::int a, (fields->>'b')::int b from d) d left join (select * from (select (fields->>'id')::int id, (fields->>'c_id')::int c_id from b) b group by b.id, b.c_id) s
  on (d.a)::int = (s.id)::int and (d.b)::int = (s.c_id)::int;
    QUERY PLAN     
-------------------
 Foreign Scan on d
(1 row)

-- similarly, but keying off a DISTINCT clause
--Testcase 380:
explain (costs off)
select d.* from (select (fields->>'a')::int a, (fields->>'b')::int b from d) d left join (select distinct * from (select (fields->>'id')::int id, (fields->>'c_id')::int c_id from b) b) s
  on (d.a)::int = (s.id)::int and (d.b)::int = (s.c_id)::int;
    QUERY PLAN     
-------------------
 Foreign Scan on d
(1 row)

-- join removal is not possible when the GROUP BY contains a column that is
-- not in the join condition.  (Note: as of 9.6, we notice that b.id is a
-- primary key and so drop b.c_id from the GROUP BY of the resulting plan;
-- but this happens too late for join removal in the outer plan level.)
--Testcase 381:
explain (costs off)
select d.* from (select (fields->>'a')::int a, (fields->>'b')::int b from d) d left join (select * from (select (fields->>'id')::int id, (fields->>'c_id')::int c_id from b) b group by b.id, b.c_id) s
  on (d.a)::int = (s.id)::int;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Hash Left Join
   Hash Cond: (((d.fields ->> 'a'::text))::integer = s.id)
   ->  Foreign Scan on d
   ->  Hash
         ->  Subquery Scan on s
               ->  HashAggregate
                     Group Key: ((b.fields ->> 'id'::text))::integer, ((b.fields ->> 'c_id'::text))::integer
                     ->  Foreign Scan on b
(8 rows)

-- similarly, but keying off a DISTINCT clause
--Testcase 382:
explain (costs off)
select d.* from (select (fields->>'a')::int a, (fields->>'b')::int b from d) d left join (select distinct * from (select (fields->>'id')::int id, (fields->>'c_id')::int c_id from b) b) s
  on (d.a)::int = (s.id)::int;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Hash Left Join
   Hash Cond: (((d.fields ->> 'a'::text))::integer = s.id)
   ->  Foreign Scan on d
   ->  Hash
         ->  Subquery Scan on s
               ->  HashAggregate
                     Group Key: ((b.fields ->> 'id'::text))::integer, ((b.fields ->> 'c_id'::text))::integer
                     ->  Foreign Scan on b
(8 rows)

-- check join removal works when uniqueness of the join condition is enforced
-- by a UNION
--Testcase 383:
explain (costs off)
select d.* from (select (fields->>'a')::int a, (fields->>'b')::int b from d) d left join (select (fields->>'id')::int id from a union select (fields->>'id')::int id from b) s
  on (d.a)::int = (s.id)::int;
    QUERY PLAN     
-------------------
 Foreign Scan on d
(1 row)

-- check join removal with a cross-type comparison operator
--Testcase 384:
explain (costs off)
select i8.* from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8) i8 left join (select (fields->>'f1')::int f1 from int4_tbl group by (fields->>'f1')::int) i4
  on (i8.q1)::int8 = (i4.f1)::int4;
         QUERY PLAN          
-----------------------------
 Foreign Scan on int8_tbl i8
(1 row)

-- check join removal with lateral references
--Testcase 385:
explain (costs off)
select 1 from (select (a.fields->>'id')::int id FROM a left join b on (a.fields->>'b_id')::int = (b.fields->>'id')::int) q,
			  lateral generate_series(1, (q.id)::int) gs(i) where (q.id)::int = (gs.i)::int;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Merge Right Join
   Merge Cond: ((((b.fields ->> 'id'::text))::integer) = (((a.fields ->> 'b_id'::text))::integer))
   ->  Sort
         Sort Key: (((b.fields ->> 'id'::text))::integer)
         ->  Foreign Scan on b
   ->  Sort
         Sort Key: (((a.fields ->> 'b_id'::text))::integer)
         ->  Nested Loop
               ->  Foreign Scan on a
               ->  Function Scan on generate_series gs
                     Filter: (((a.fields ->> 'id'::text))::integer = i)
(11 rows)

--Testcase 386:
DELETE FROM a_nsc;
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 387:
DELETE FROM b_nsc;
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 388:
DELETE FROM c_nsc;
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 389:
DELETE FROM d_nsc;
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 390:
DROP FOREIGN TABLE a;
--Testcase 619:
DROP FOREIGN TABLE a_nsc;
--Testcase 391:
DROP FOREIGN TABLE b;
--Testcase 620:
DROP FOREIGN TABLE b_nsc;
--Testcase 392:
DROP FOREIGN TABLE c;
--Testcase 621:
DROP FOREIGN TABLE c_nsc;
--Testcase 393:
DROP FOREIGN TABLE d;
--Testcase 622:
DROP FOREIGN TABLE d_nsc;
rollback;
--Testcase 394:
create foreign table parent (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 623:
create foreign table parent_nsc (k int, pd int) server influxdb_svr OPTIONS (table 'parent');
--Testcase 395:
create foreign table child (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 624:
create foreign table child_nsc (k int, cd int) server influxdb_svr OPTIONS (table 'child');
--Testcase 396:
insert into parent_nsc values (1, 10), (2, 20), (3, 30);
--Testcase 397:
insert into child_nsc values (1, 100), (4, 400);
-- this case is optimizable
--Testcase 398:
select p.* from (select (fields->>'k')::int k, (fields->>'pd')::int pd from parent p) p left join (select (fields->>'k')::int k, (fields->>'cd')::int cd from child c) c on ((p.k)::int = (c.k)::int);
 k | pd 
---+----
 1 | 10
 2 | 20
 3 | 30
(3 rows)

--Testcase 399:
explain (costs off)
  select p.* from (select (fields->>'k')::int k, (fields->>'pd')::int pd from parent p) p left join (select (fields->>'k')::int k, (fields->>'cd')::int cd from child c) c on ((p.k)::int = (c.k)::int);
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Merge Left Join
   Merge Cond: ((((p.fields ->> 'k'::text))::integer) = (((c.fields ->> 'k'::text))::integer))
   ->  Sort
         Sort Key: (((p.fields ->> 'k'::text))::integer)
         ->  Foreign Scan on parent p
   ->  Sort
         Sort Key: (((c.fields ->> 'k'::text))::integer)
         ->  Foreign Scan on child c
(8 rows)

-- this case is not
--Testcase 400:
select p.*, linked from (select (fields->>'k')::int k, (fields->>'pd')::int pd from parent p) p
  left join (select c.*, true as linked from (select (fields->>'k')::int k, (fields->>'cd')::int cd from child c) c) as ss
  on (p.k = ss.k);
 k | pd | linked 
---+----+--------
 1 | 10 | t
 2 | 20 | 
 3 | 30 | 
(3 rows)

--Testcase 401:
explain (costs off)
  select p.*, linked from (select (fields->>'k')::int k, (fields->>'pd')::int pd from parent p) p
    left join (select c.*, true as linked from (select (fields->>'k')::int k, (fields->>'cd')::int cd from child c) c) as ss
    on (p.k = ss.k);
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Merge Right Join
   Merge Cond: ((((c.fields ->> 'k'::text))::integer) = (((p.fields ->> 'k'::text))::integer))
   ->  Sort
         Sort Key: (((c.fields ->> 'k'::text))::integer)
         ->  Foreign Scan on child c
   ->  Sort
         Sort Key: (((p.fields ->> 'k'::text))::integer)
         ->  Foreign Scan on parent p
(8 rows)

-- check for a 9.0rc1 bug: join removal breaks pseudoconstant qual handling
--Testcase 402:
select p.* from
  (select (fields->>'k')::int k, (fields->>'pd')::int pd from parent) p left join (select (fields->>'k')::int k, (fields->>'cd')::int cd from child) c on ((p.k)::int = (c.k)::int)
  where (p.k)::int = 1 and (p.k)::int = 2;
 k | pd 
---+----
(0 rows)

--Testcase 403:
explain (costs off)
select p.* from
  (select (fields->>'k')::int k, (fields->>'pd')::int pd from parent) p left join (select (fields->>'k')::int k, (fields->>'cd')::int cd from child) c on ((p.k)::int = (c.k)::int)
  where (p.k)::int = 1 and (p.k)::int = 2;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

--Testcase 404:
select p.* from
  ((select (fields->>'k')::int k, (fields->>'pd')::int pd from parent) p left join (select (fields->>'k')::int k, (fields->>'cd')::int cd from child) c on ((p.k)::int = (c.k)::int)) join (select (fields->>'k')::int k, (fields->>'pd')::int pd from parent) x on (p.k)::int = (x.k)::int
  where (p.k)::int = 1 and (p.k)::int = 2;
 k | pd 
---+----
(0 rows)

--Testcase 405:
explain (costs off)
select p.* from
  ((select (fields->>'k')::int k, (fields->>'pd')::int pd from parent) p left join (select (fields->>'k')::int k, (fields->>'cd')::int cd from child) c on ((p.k)::int = (c.k)::int)) join (select (fields->>'k')::int k, (fields->>'pd')::int pd from parent) x on (p.k)::int = (x.k)::int
  where (p.k)::int = 1 and (p.k)::int = 2;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

-- bug 5255: this is not optimizable by join removal
begin;
--Testcase 406:
CREATE FOREIGN TABLE a (fields jsonb OPTIONS (fields 'true')) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 625:
CREATE FOREIGN TABLE a_nsc (id int) SERVER influxdb_svr OPTIONS (table 'a');
--Testcase 407:
CREATE FOREIGN TABLE b (fields jsonb OPTIONS (fields 'true')) SERVER influxdb_svr OPTIONS(schemaless 'true');
--Testcase 626:
CREATE FOREIGN TABLE b_nsc (id int, a_id int) SERVER influxdb_svr OPTIONS (table 'b');
--Testcase 408:
INSERT INTO a_nsc VALUES (0), (1);
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 409:
INSERT INTO b_nsc VALUES (0, 0), (1, NULL);
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 410:
SELECT * FROM (select (fields->>'id')::int id, (fields->>'a_id')::int a_id from b) b LEFT JOIN (select (fields->>'id')::int id from a) a ON ((b.a_id)::int = (a.id)::int) WHERE ((a.id)::int IS NULL OR (a.id)::int > 0);
 id | a_id | id 
----+------+----
  1 |      |   
(1 row)

--Testcase 411:
SELECT b.* FROM (select (fields->>'id')::int id, (fields->>'a_id')::int a_id from b) b LEFT JOIN (select (fields->>'id')::int id from a) a ON ((b.a_id)::int = (a.id)::int) WHERE ((a.id)::int IS NULL OR (a.id)::int > 0);
 id | a_id 
----+------
  1 |     
(1 row)

--Testcase 412:
DELETE FROM a_nsc;
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 413:
DELETE FROM b_nsc;
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 414:
DROP FOREIGN TABLE a;
--Testcase 627:
DROP FOREIGN TABLE a_nsc;
--Testcase 415:
DROP FOREIGN TABLE b;
--Testcase 628:
DROP FOREIGN TABLE b_nsc;
rollback;
-- another join removal bug: this is not optimizable, either
begin;
--Testcase 416:
create foreign table innertab (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 629:
create foreign table innertab_nsc (id int8, dat1 int8) server influxdb_svr OPTIONS (table 'innertab');
--Testcase 417:
insert into innertab_nsc values(123, 42);
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 418:
SELECT * FROM
    (SELECT 1 AS x) ss1
  LEFT JOIN
    (SELECT q1, q2, COALESCE(dat1, q1) AS y
     FROM (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) int8_tbl LEFT JOIN (select (fields->>'id')::int id, (fields->>'dat1')::int dat1 from innertab) innertab ON (q2)::int8 = (id)::int) ss2
  ON true;
 x |        q1        |        q2         |        y         
---+------------------+-------------------+------------------
 1 | 4567890123456789 | -4567890123456789 | 4567890123456789
 1 | 4567890123456789 |               123 |               42
 1 |              123 |               456 |              123
 1 |              123 |  4567890123456789 |              123
 1 | 4567890123456789 |  4567890123456789 | 4567890123456789
(5 rows)

-- Clean up
--Testcase 630:
DELETE FROM innertab_nsc;
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 631:
DROP FOREIGN TABLE innertab;
--Testcase 632:
DROP FOREIGN TABLE innertab_nsc;
rollback;
-- another join removal bug: we must clean up correctly when removing a PHV
begin;
--Testcase 419:
create foreign table uniquetbl (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 420:
explain (costs off)
select t1.* from
  (select fields->>'f1' f1 from uniquetbl t1) as t1
  left join (select *, '***'::text as d1 from (select fields->>'f1' f1 from uniquetbl uniquetbl) uniquetbl) t2
  on t1.f1 = t2.f1
  left join (select fields->>'f1' f1 from uniquetbl t3) t3
  on t2.d1 = t3.f1;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Merge Right Join
   Merge Cond: (((t3.fields ->> 'f1'::text)) = ('***'::text))
   ->  Sort
         Sort Key: ((t3.fields ->> 'f1'::text))
         ->  Foreign Scan on uniquetbl t3
   ->  Sort
         Sort Key: ('***'::text)
         ->  Merge Right Join
               Merge Cond: (((uniquetbl.fields ->> 'f1'::text)) = ((t1.fields ->> 'f1'::text)))
               ->  Sort
                     Sort Key: ((uniquetbl.fields ->> 'f1'::text))
                     ->  Foreign Scan on uniquetbl
               ->  Sort
                     Sort Key: ((t1.fields ->> 'f1'::text))
                     ->  Foreign Scan on uniquetbl t1
(15 rows)

--Testcase 421:
explain (costs off)
select t0.*
from
 (select fields->>'f1' f1 from text_tbl t0) t0
 left join
   (select case (t1.fields->>'ten')::int4 when 0 then 'doh!'::text else null::text end as case1,
           t1.fields->>'stringu2' stringu2
     from tenk1 t1
     join int4_tbl i4 ON (i4.fields->>'f1')::int4 = (t1.fields->>'unique2')::int4
     left join uniquetbl u1 ON u1.fields->>'f1' = (t1.fields->>'string4')::name) ss
  on t0.f1 = ss.case1
where ss.stringu2 !~* ss.case1;
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Right Join
   Merge Cond: (((u1.fields ->> 'f1'::text)) = (((t1.fields ->> 'string4'::text))::name))
   ->  Sort
         Sort Key: ((u1.fields ->> 'f1'::text))
         ->  Foreign Scan on uniquetbl u1
   ->  Materialize
         ->  Sort
               Sort Key: (((t1.fields ->> 'string4'::text))::name) COLLATE "default"
               ->  Merge Join
                     Merge Cond: (((t0.fields ->> 'f1'::text)) = (CASE ((t1.fields ->> 'ten'::text))::integer WHEN 0 THEN 'doh!'::text ELSE NULL::text END))
                     ->  Sort
                           Sort Key: ((t0.fields ->> 'f1'::text))
                           ->  Foreign Scan on text_tbl t0
                     ->  Sort
                           Sort Key: (CASE ((t1.fields ->> 'ten'::text))::integer WHEN 0 THEN 'doh!'::text ELSE NULL::text END)
                           ->  Merge Join
                                 Merge Cond: ((((t1.fields ->> 'unique2'::text))::integer) = (((i4.fields ->> 'f1'::text))::integer))
                                 ->  Sort
                                       Sort Key: (((t1.fields ->> 'unique2'::text))::integer)
                                       ->  Foreign Scan on tenk1 t1
                                             Filter: ((fields ->> 'stringu2'::text) !~* CASE ((fields ->> 'ten'::text))::integer WHEN 0 THEN 'doh!'::text ELSE NULL::text END)
                                 ->  Sort
                                       Sort Key: (((i4.fields ->> 'f1'::text))::integer)
                                       ->  Foreign Scan on int4_tbl i4
(24 rows)

--Testcase 422:
select t0.*
from
 (select fields->>'f1' f1 from text_tbl t0) t0
 left join
   (select case (t1.fields->>'ten')::int4 when 0 then 'doh!'::text else null::text end as case1,
           t1.fields->>'stringu2' stringu2
     from tenk1 t1
     join int4_tbl i4 ON (i4.fields->>'f1')::int4 = (t1.fields->>'unique2')::int4
     left join uniquetbl u1 ON u1.fields->>'f1' = (t1.fields->>'string4')::name) ss
  on t0.f1 = ss.case1
where ss.stringu2 !~* ss.case1;
  f1  
------
 doh!
(1 row)

rollback;
-- test case to expose miscomputation of required relid set for a PHV
--Testcase 423:
explain (verbose, costs off)
select i8.*, ss.v, (t.fields->>'unique2')::int4 unique2
  from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8) i8
    left join int4_tbl i4 on (i4.fields->>'f1')::int4 = 1
    left join lateral (select (i4.fields->>'f1')::int4 + 1 as v) as ss on true
    left join tenk1 t on (t.fields->>'unique2')::int4 = (ss.v)::int4
where q2::int8 = 456;
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join
   Output: ((i8.fields ->> 'q1'::text))::bigint, ((i8.fields ->> 'q2'::text))::bigint, ((((i4.fields ->> 'f1'::text))::integer + 1)), ((t.fields ->> 'unique2'::text))::integer
   Hash Cond: (((t.fields ->> 'unique2'::text))::integer = ((((i4.fields ->> 'f1'::text))::integer + 1)))
   ->  Foreign Scan on public.tenk1 t
         Output: t.fields
         InfluxDB query: SELECT * FROM "tenk"
   ->  Hash
         Output: i8.fields, ((((i4.fields ->> 'f1'::text))::integer + 1))
         ->  Nested Loop Left Join
               Output: i8.fields, (((i4.fields ->> 'f1'::text))::integer + 1)
               ->  Foreign Scan on public.int8_tbl i8
                     Output: i8.fields
                     InfluxDB query: SELECT * FROM "int8_tbl" WHERE (("q2" = 456))
               ->  Materialize
                     Output: i4.fields
                     ->  Foreign Scan on public.int4_tbl i4
                           Output: i4.fields
                           InfluxDB query: SELECT * FROM "int4_tbl" WHERE (("f1" = 1))
(18 rows)

--Testcase 424:
select i8.*, ss.v, (t.fields->>'unique2')::int4 unique2
  from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8) i8
    left join int4_tbl i4 on (i4.fields->>'f1')::int4 = 1
    left join lateral (select (i4.fields->>'f1')::int4 + 1 as v) as ss on true
    left join tenk1 t on (t.fields->>'unique2')::int4 = (ss.v)::int4
where q2::int8 = 456;
 q1  | q2  | v | unique2 
-----+-----+---+---------
 123 | 456 |   |        
(1 row)

-- InfluxDB does not support partition table, create local table for test
-- and check a related issue where we miscompute required relids for
-- a PHV that's been translated to a child rel
--Testcase 570:
create temp table parttbl (a integer primary key) partition by range (a);
--Testcase 571:
create temp table parttbl1 partition of parttbl for values from (1) to (100);
--Testcase 572:
insert into parttbl values (11), (12);
--Testcase 573:
explain (costs off)
select * from
  (select *, 12 as phv from parttbl) as ss
  right join (select (fields->>'f1')::int4 f1 from int4_tbl) int4_tbl on true
where ss.a = ss.phv and f1 = 0;
              QUERY PLAN              
--------------------------------------
 Nested Loop
   ->  Seq Scan on parttbl1 parttbl
         Filter: (a = 12)
   ->  Materialize
         ->  Foreign Scan on int4_tbl
(5 rows)

--Testcase 574:
select * from
  (select *, 12 as phv from parttbl) as ss
  right join (select (fields->>'f1')::int4 f1 from int4_tbl) int4_tbl on true
where ss.a = ss.phv and f1 = 0;
 a  | phv | f1 
----+-----+----
 12 |  12 |  0
(1 row)

-- bug #8444: we've historically allowed duplicate aliases within aliased JOINs
--Testcase 425:
select * from
  (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) x join ((select (fields->>'f1')::int4 f1 from INT4_TBL) x cross join (select (fields->>'f1')::int4 f1 from INT4_TBL) y) j on  q1 = f1; -- error
ERROR:  column reference "f1" is ambiguous
LINE 2: ...ct (fields->>'f1')::int4 f1 from INT4_TBL) y) j on  q1 = f1;
                                                                    ^
--Testcase 426:
select * from
  (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) x join ((select (fields->>'f1')::int4 f1 from INT4_TBL) x cross join (select (fields->>'f1')::int4 f1 from INT4_TBL) y) j on q1 = y.f1; -- error
ERROR:  invalid reference to FROM-clause entry for table "y"
LINE 2: ...t (fields->>'f1')::int4 f1 from INT4_TBL) y) j on q1 = y.f1;
                                                                  ^
HINT:  There is an entry for table "y", but it cannot be referenced from this part of the query.
--Testcase 427:
select * from
  (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) x join ((select (fields->>'f1')::int4 f1 from INT4_TBL) x cross join (select (fields->>'f1')::int4 f1 from INT4_TBL) y(ff)) j on q1 = f1; -- ok
 q1 | q2 | f1 | ff 
----+----+----+----
(0 rows)

--
-- Test hints given on incorrect column references are useful
--
--Testcase 428:
select (t1.ffields->>'unique1')::int4 unique1 from
  tenk1 t1 join tenk2 t2 on (t1.fields->>'two')::int4 = (t2.fields->>'two')::int4; -- error, prefer "t1" suggestion
ERROR:  column t1.ffields does not exist
LINE 1: select (t1.ffields->>'unique1')::int4 unique1 from
                ^
HINT:  Perhaps you meant to reference the column "t1.fields".
--Testcase 429:
select (t2.ffields->>'unique1')::int4 unique1 from
  tenk1 t1 join tenk2 t2 on (t1.fields->>'two')::int4 = (t2.fields->>'two')::int4; -- error, prefer "t2" suggestion
ERROR:  column t2.ffields does not exist
LINE 1: select (t2.ffields->>'unique1')::int4 unique1 from
                ^
HINT:  Perhaps you meant to reference the column "t2.fields".
--Testcase 430:
select (ffields->>'unique1')::int4 unique1 from
  tenk1 t1 join tenk2 t2 on (t1.fields->>'two')::int4 = (t2.fields->>'two')::int4; -- error, suggest both at once
ERROR:  column "ffields" does not exist
LINE 1: select (ffields->>'unique1')::int4 unique1 from
                ^
HINT:  Perhaps you meant to reference the column "t1.fields" or the column "t2.fields".
--
-- Take care to reference the correct RTE
--
--Testcase 431:
select atts.relid::regclass, s.* from pg_stats s join
    pg_attribute a on s.attname = a.attname and s.tablename =
    a.attrelid::regclass::text join (select unnest(indkey) attnum,
    indexrelid from pg_index i) atts on atts.attnum = a.attnum where
    schemaname != 'pg_catalog';
ERROR:  column atts.relid does not exist
LINE 1: select atts.relid::regclass, s.* from pg_stats s join
               ^
--
-- Test LATERAL
--
--Testcase 432:
select unique2, x.*
from (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, fields->>'two' two, fields->>'four' four, fields->>'ten' ten, fields->>'twenty' twenty, fields->>'hundred' hundred, fields->>'thousand' thousand, fields->>'twothousand' twothousand, fields->>'fivethous' fivethous, fields->>'tenthous' tenthous, fields->>'odd' odd, fields->>'even' even, fields->>'stringu1' stringu1, fields->>'stringu2' stringu2, fields->>'string4' string4 from tenk1 a) a, lateral (select * from (select (fields->>'f1')::int4 f1 from INT4_TBL b) b where f1 = a.unique1) x;
 unique2 | f1 
---------+----
    9998 |  0
(1 row)

--Testcase 433:
explain (costs off)
  select unique2, x.*
  from (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2, fields->>'two' two, fields->>'four' four, fields->>'ten' ten, fields->>'twenty' twenty, fields->>'hundred' hundred, fields->>'thousand' thousand, fields->>'twothousand' twothousand, fields->>'fivethous' fivethous, fields->>'tenthous' tenthous, fields->>'odd' odd, fields->>'even' even, fields->>'stringu1' stringu1, fields->>'stringu2' stringu2, fields->>'string4' string4 from tenk1 a) a, lateral (select * from (select (fields->>'f1')::int4 f1 from INT4_TBL b) b where f1 = a.unique1) x;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Merge Join
   Merge Cond: ((((a.fields ->> 'unique1'::text))::integer) = (((b.fields ->> 'f1'::text))::integer))
   ->  Sort
         Sort Key: (((a.fields ->> 'unique1'::text))::integer)
         ->  Foreign Scan on tenk1 a
   ->  Sort
         Sort Key: (((b.fields ->> 'f1'::text))::integer)
         ->  Foreign Scan on int4_tbl b
(8 rows)

--Testcase 434:
select unique2, x.*
from (select (fields->>'f1')::int4 f1 from INT4_TBL x) x, lateral (select (fields->>'unique2')::int4 unique2 from tenk1 where f1 = (fields->>'unique1')::int4) ss;
 unique2 | f1 
---------+----
    9998 |  0
(1 row)

--Testcase 435:
explain (costs off)
  select unique2, x.*
  from (select (fields->>'f1')::int4 f1 from INT4_TBL x) x, lateral (select (fields->>'unique2')::int4 unique2 from tenk1 where f1 = (fields->>'unique1')::int4) ss;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Merge Join
   Merge Cond: ((((x.fields ->> 'f1'::text))::integer) = (((tenk1.fields ->> 'unique1'::text))::integer))
   ->  Sort
         Sort Key: (((x.fields ->> 'f1'::text))::integer)
         ->  Foreign Scan on int4_tbl x
   ->  Sort
         Sort Key: (((tenk1.fields ->> 'unique1'::text))::integer)
         ->  Foreign Scan on tenk1
(8 rows)

--Testcase 436:
explain (costs off)
  select unique2, x.*
  from (select (fields->>'f1')::int4 f1 from INT4_TBL x) x cross join lateral (select (fields->>'unique2')::int4 unique2 from tenk1 where f1 = (fields->>'unique1')::int4) ss;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Merge Join
   Merge Cond: ((((x.fields ->> 'f1'::text))::integer) = (((tenk1.fields ->> 'unique1'::text))::integer))
   ->  Sort
         Sort Key: (((x.fields ->> 'f1'::text))::integer)
         ->  Foreign Scan on int4_tbl x
   ->  Sort
         Sort Key: (((tenk1.fields ->> 'unique1'::text))::integer)
         ->  Foreign Scan on tenk1
(8 rows)

--Testcase 437:
select unique2, x.*
from (select (fields->>'f1')::int4 f1 from INT4_TBL x) x left join lateral (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2 from tenk1 where f1 = (fields->>'unique1')::int4) ss on true;
 unique2 |     f1      
---------+-------------
         | -2147483647
         |     -123456
    9998 |           0
         |      123456
         |  2147483647
(5 rows)

--Testcase 438:
explain (costs off)
  select unique2, x.*
  from (select (fields->>'f1')::int4 f1 from INT4_TBL x) x left join lateral (select (fields->>'unique1')::int4 unique1, (fields->>'unique2')::int4 unique2 from tenk1 where f1 = (fields->>'unique1')::int4) ss on true;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Merge Left Join
   Merge Cond: ((((x.fields ->> 'f1'::text))::integer) = (((tenk1.fields ->> 'unique1'::text))::integer))
   ->  Sort
         Sort Key: (((x.fields ->> 'f1'::text))::integer)
         ->  Foreign Scan on int4_tbl x
   ->  Sort
         Sort Key: (((tenk1.fields ->> 'unique1'::text))::integer)
         ->  Foreign Scan on tenk1
(8 rows)

-- check scoping of lateral versus parent references
-- the first of these should return int8_tbl.q2, the second int8_tbl.q1
--Testcase 439:
select *, (select r from (select q1 as q2) x, (select q2 as r) y) from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) int8_tbl;
        q1        |        q2         |         r         
------------------+-------------------+-------------------
              123 |               456 |               456
              123 |  4567890123456789 |  4567890123456789
 4567890123456789 |               123 |               123
 4567890123456789 |  4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789 | -4567890123456789
(5 rows)

--Testcase 440:
select *, (select r from (select q1 as q2) x, lateral (select q2 as r) y) from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) int8_tbl;
        q1        |        q2         |        r         
------------------+-------------------+------------------
              123 |               456 |              123
              123 |  4567890123456789 |              123
 4567890123456789 |               123 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 | 4567890123456789
(5 rows)

-- lateral with function in FROM
--Testcase 441:
select count(*) from tenk1 a, lateral generate_series(1, (fields->>'two')::int4) g;
 count 
-------
  5000
(1 row)

--Testcase 442:
explain (costs off)
  select count(*) from tenk1 a, lateral generate_series(1, (fields->>'two')::int4) g;
                   QUERY PLAN                   
------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Foreign Scan on tenk1 a
         ->  Function Scan on generate_series g
(4 rows)

--Testcase 443:
explain (costs off)
  select count(*) from tenk1 a cross join lateral generate_series(1,(fields->>'two')::int4) g;
                   QUERY PLAN                   
------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Foreign Scan on tenk1 a
         ->  Function Scan on generate_series g
(4 rows)

-- don't need the explicit LATERAL keyword for functions
--Testcase 444:
explain (costs off)
  select count(*) from tenk1 a, generate_series(1,(fields->>'two')::int4) g;
                   QUERY PLAN                   
------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Foreign Scan on tenk1 a
         ->  Function Scan on generate_series g
(4 rows)

-- lateral with UNION ALL subselect
--Testcase 445:
explain (costs off)
  select * from generate_series(100,200) g,
    lateral (select * from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL a) a where g = (q1)::int8 union all
             select * from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL b) b where g = (q2)::int8) ss;
                QUERY PLAN                
------------------------------------------
 Nested Loop
   ->  Function Scan on generate_series g
   ->  Append
         ->  Foreign Scan on int8_tbl a
         ->  Foreign Scan on int8_tbl b
(5 rows)

--Testcase 446:
select * from generate_series(100,200) g,
  lateral (select * from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL a) a where g = (q1)::int8 union all
           select * from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL b) b where g = (q2)::int8) ss;
  g  |        q1        |        q2        
-----+------------------+------------------
 123 |              123 |              456
 123 |              123 | 4567890123456789
 123 | 4567890123456789 |              123
(3 rows)

-- lateral with VALUES
--Testcase 447:
explain (costs off)
  select count(*) from tenk1 a,
    tenk1 b join lateral (values(a.fields->>'unique1')) ss(x) on b.fields->>'unique2' = ss.x;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Aggregate
   ->  Merge Join
         Merge Cond: (((a.fields ->> 'unique1'::text)) = ((b.fields ->> 'unique2'::text)))
         ->  Sort
               Sort Key: ((a.fields ->> 'unique1'::text))
               ->  Foreign Scan on tenk1 a
         ->  Sort
               Sort Key: ((b.fields ->> 'unique2'::text))
               ->  Foreign Scan on tenk1 b
(9 rows)

--Testcase 448:
select count(*) from tenk1 a,
  tenk1 b join lateral (values(a.fields->>'unique1')) ss(x) on b.fields->>'unique2' = ss.x;
 count 
-------
 10000
(1 row)

-- lateral with VALUES, no flattening possible
--Testcase 449:
explain (costs off)
  select count(*) from tenk1 a,
    tenk1 b join lateral (values((a.fields->>'unique1')::int4),(-1)) ss(x) on (b.fields->>'unique2')::int4 = (ss.x)::int;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Aggregate
   ->  Merge Join
         Merge Cond: ((((b.fields ->> 'unique2'::text))::integer) = "*VALUES*".column1)
         ->  Sort
               Sort Key: (((b.fields ->> 'unique2'::text))::integer)
               ->  Foreign Scan on tenk1 b
         ->  Sort
               Sort Key: "*VALUES*".column1
               ->  Nested Loop
                     ->  Foreign Scan on tenk1 a
                     ->  Values Scan on "*VALUES*"
(11 rows)

--Testcase 450:
select count(*) from tenk1 a,
  tenk1 b join lateral (values((a.fields->>'unique1')::int4),(-1)) ss(x) on (b.fields->>'unique2')::int4 = (ss.x)::int;
 count 
-------
 10000
(1 row)

-- lateral injecting a strange outer join condition
--Testcase 451:
explain (costs off)
  select * from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL a) a,
    (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL x) x left join lateral (select a.q1 from (select (fields->>'f1')::int4 f1 from INT4_TBL y) y) ss(z)
      on x.q2 = ss.z
  order by (a.q1)::int8, (a.q2)::int8, (x.q1)::int8, (x.q2)::int8, (ss.z)::int8;
                                                                                                  QUERY PLAN                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: (((a.fields ->> 'q1'::text))::bigint), (((a.fields ->> 'q2'::text))::bigint), (((x.fields ->> 'q1'::text))::bigint), (((x.fields ->> 'q2'::text))::bigint), (((a.fields ->> 'q1'::text))::bigint)
   ->  Nested Loop
         ->  Foreign Scan on int8_tbl a
         ->  Merge Left Join
               Merge Cond: ((((x.fields ->> 'q2'::text))::bigint) = (((a.fields ->> 'q1'::text))::bigint))
               ->  Sort
                     Sort Key: (((x.fields ->> 'q2'::text))::bigint)
                     ->  Foreign Scan on int8_tbl x
               ->  Sort
                     Sort Key: (((a.fields ->> 'q1'::text))::bigint)
                     ->  Foreign Scan on int4_tbl y
(12 rows)

--Testcase 452:
select * from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL a) a,
    (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL x) x left join lateral (select a.q1 from (select (fields->>'f1')::int4 f1 from INT4_TBL y) y) ss(z)
      on x.q2 = ss.z
  order by (a.q1)::int8, (a.q2)::int8, (x.q1)::int8, (x.q2)::int8, (ss.z)::int8;
        q1        |        q2         |        q1        |        q2         |        z         
------------------+-------------------+------------------+-------------------+------------------
              123 |               456 |              123 |               456 |                 
              123 |               456 |              123 |  4567890123456789 |                 
              123 |               456 | 4567890123456789 | -4567890123456789 |                 
              123 |               456 | 4567890123456789 |               123 |              123
              123 |               456 | 4567890123456789 |               123 |              123
              123 |               456 | 4567890123456789 |               123 |              123
              123 |               456 | 4567890123456789 |               123 |              123
              123 |               456 | 4567890123456789 |               123 |              123
              123 |               456 | 4567890123456789 |  4567890123456789 |                 
              123 |  4567890123456789 |              123 |               456 |                 
              123 |  4567890123456789 |              123 |  4567890123456789 |                 
              123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |                 
              123 |  4567890123456789 | 4567890123456789 |               123 |              123
              123 |  4567890123456789 | 4567890123456789 |               123 |              123
              123 |  4567890123456789 | 4567890123456789 |               123 |              123
              123 |  4567890123456789 | 4567890123456789 |               123 |              123
              123 |  4567890123456789 | 4567890123456789 |               123 |              123
              123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |                 
 4567890123456789 | -4567890123456789 |              123 |               456 |                 
 4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 | 4567890123456789 | -4567890123456789 |                 
 4567890123456789 | -4567890123456789 | 4567890123456789 |               123 |                 
 4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 |              123 |               456 |                 
 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 | 4567890123456789 | -4567890123456789 |                 
 4567890123456789 |               123 | 4567890123456789 |               123 |                 
 4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 |              123 |               456 |                 
 4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 |                 
 4567890123456789 |  4567890123456789 | 4567890123456789 |               123 |                 
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
(57 rows)

-- lateral reference to a join alias variable
--Testcase 453:
select * from (select (fields->>'f1')::int4/2 as x from int4_tbl) ss1 join (select (fields->>'f1')::int4 f1 from INT4_TBL) i4 on x::int4 = (f1)::int4,
  lateral (select x) ss2(y);
 x | f1 | y 
---+----+---
 0 |  0 | 0
(1 row)

--Testcase 454:
select * from (select (fields->>'f1')::int4 as x from int4_tbl) ss1 join (select (fields->>'f1')::int4 f1 from INT4_TBL) i4 on x::int4 = (f1)::int4,
  lateral (values(x)) ss2(y);
      x      |     f1      |      y      
-------------+-------------+-------------
 -2147483647 | -2147483647 | -2147483647
     -123456 |     -123456 |     -123456
           0 |           0 |           0
      123456 |      123456 |      123456
  2147483647 |  2147483647 |  2147483647
(5 rows)

--Testcase 455:
select * from ((select (fields->>'f1')::int4/2 as x from int4_tbl) ss1 join (select (fields->>'f1')::int4 f1 from INT4_TBL) i4 on x::int4 = (f1)::int4) j,
  lateral (select x) ss2(y);
 x | f1 | y 
---+----+---
 0 |  0 | 0
(1 row)

-- lateral references requiring pullup
--Testcase 456:
select * from (values(1)) x(lb),
  lateral generate_series(lb,4) x4;
 lb | x4 
----+----
  1 |  1
  1 |  2
  1 |  3
  1 |  4
(4 rows)

--Testcase 457:
select * from (select (fields->>'f1')::int4/1000000000 from int4_tbl) x(lb),
  lateral generate_series(lb,4) x4;
 lb | x4 
----+----
  0 |  0
  0 |  1
  0 |  2
  0 |  3
  0 |  4
  0 |  0
  0 |  1
  0 |  2
  0 |  3
  0 |  4
  0 |  0
  0 |  1
  0 |  2
  0 |  3
  0 |  4
  2 |  2
  2 |  3
  2 |  4
 -2 | -2
 -2 | -1
 -2 |  0
 -2 |  1
 -2 |  2
 -2 |  3
 -2 |  4
(25 rows)

--Testcase 458:
select * from (values(1)) x(lb),
  lateral (values(lb)) y(lbcopy);
 lb | lbcopy 
----+--------
  1 |      1
(1 row)

--Testcase 459:
select * from (values(1)) x(lb),
  lateral (select lb from int4_tbl) y(lbcopy);
 lb | lbcopy 
----+--------
  1 |      1
  1 |      1
  1 |      1
  1 |      1
  1 |      1
(5 rows)

--Testcase 460:
select * from
  (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) x left join (select (fields->>'q1')::int8 q1,coalesce((fields->>'q2')::int8,0) q2 from int8_tbl) y on x.q2 = y.q1,
  lateral (values(x.q1,y.q1,y.q2)) v(xq1,yq1,yq2) ORDER BY xq1, yq1, yq2;
        q1        |        q2         |        q1        |        q2         |       xq1        |       yq1        |        yq2        
------------------+-------------------+------------------+-------------------+------------------+------------------+-------------------
              123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |              123 | 4567890123456789 | -4567890123456789
              123 |  4567890123456789 | 4567890123456789 |               123 |              123 | 4567890123456789 |               123
              123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |              123 | 4567890123456789 |  4567890123456789
              123 |               456 |                  |                   |              123 |                  |                  
 4567890123456789 |               123 |              123 |               456 | 4567890123456789 |              123 |               456
 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789 |              123 |  4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789 | 4567890123456789 | -4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789 | 4567890123456789 |               123
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789 |                  |                   | 4567890123456789 |                  |                  
(10 rows)

--Testcase 461:
select * from
  (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) x left join (select (fields->>'q1')::int8 q1,coalesce((fields->>'q2')::int8,0) q2 from int8_tbl) y on x.q2 = y.q1,
  lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2) ORDER BY xq1, yq1, yq2;
        q1        |        q2         |        q1        |        q2         |       xq1        |       yq1        |        yq2        
------------------+-------------------+------------------+-------------------+------------------+------------------+-------------------
              123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |              123 | 4567890123456789 | -4567890123456789
              123 |  4567890123456789 | 4567890123456789 |               123 |              123 | 4567890123456789 |               123
              123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |              123 | 4567890123456789 |  4567890123456789
              123 |               456 |                  |                   |              123 |                  |                  
 4567890123456789 |               123 |              123 |               456 | 4567890123456789 |              123 |               456
 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789 |              123 |  4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789 | 4567890123456789 | -4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789 | 4567890123456789 |               123
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789 |                  |                   | 4567890123456789 |                  |                  
(10 rows)

--Testcase 462:
select x.* from
  (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) x left join (select (fields->>'q1')::int8 q1,coalesce((fields->>'q2')::int8,0) q2 from int8_tbl) y on x.q2 = y.q1,
  lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2) ORDER BY xq1, yq1, yq2;
        q1        |        q2         
------------------+-------------------
              123 |  4567890123456789
              123 |  4567890123456789
              123 |  4567890123456789
              123 |               456
 4567890123456789 |               123
 4567890123456789 |               123
 4567890123456789 |  4567890123456789
 4567890123456789 |  4567890123456789
 4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789
(10 rows)

--Testcase 463:
select v.* from
  (int8_tbl x left join (select (fields->>'q1')::int8 q1,coalesce((fields->>'q2')::int8,0) q2 from int8_tbl) y on (x.fields->>'q2')::int8 = y.q1)
  left join int4_tbl z on (z.fields->>'f1')::int8 = (x.fields->>'q2')::int8,
  lateral (select (x.fields->>'q1')::int8,(y.q1)::int8 union all select (x.fields->>'q2')::int8,(y.q2)::int8) v(vx,vy);
        vx         |        vy         
-------------------+-------------------
  4567890123456789 |                  
 -4567890123456789 |                  
  4567890123456789 |               123
               123 |               456
  4567890123456789 |               123
               123 |  4567890123456789
               123 |                  
               456 |                  
               123 |  4567890123456789
  4567890123456789 |               123
               123 |  4567890123456789
  4567890123456789 |  4567890123456789
               123 |  4567890123456789
  4567890123456789 | -4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |               123
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 | -4567890123456789
(20 rows)

--Testcase 464:
select v.* from
  (int8_tbl x left join (select (fields->>'q1')::int8 q1,(select coalesce((fields->>'q2')::int8,0)) q2 from int8_tbl) y on (x.fields->>'q2')::int8 = y.q1)
  left join int4_tbl z on (z.fields->>'f1')::int8 = (x.fields->>'q2')::int8,
  lateral (select (x.fields->>'q1')::int8,(y.q1)::int8 union all select (x.fields->>'q2')::int8,(y.q2)::int8) v(vx,vy);
        vx         |        vy         
-------------------+-------------------
  4567890123456789 |                  
 -4567890123456789 |                  
  4567890123456789 |               123
               123 |               456
  4567890123456789 |               123
               123 |  4567890123456789
               123 |                  
               456 |                  
               123 |  4567890123456789
  4567890123456789 |               123
               123 |  4567890123456789
  4567890123456789 |  4567890123456789
               123 |  4567890123456789
  4567890123456789 | -4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |               123
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 | -4567890123456789
(20 rows)

--Testcase 465:
select v.* from
  (int8_tbl x left join (select (fields->>'q1')::int8 q1,(select coalesce((fields->>'q2')::int8,0)) q2 from int8_tbl) y on (x.fields->>'q2')::int8 = y.q1)
  left join int4_tbl z on (z.fields->>'f1')::int8 = (x.fields->>'q2')::int8,
  lateral (select (x.fields->>'q1')::int8,(y.q1)::int8 from onerow  union all select (x.fields->>'q2')::int8,(y.q2)::int8 from onerow) v(vx,vy);
        vx         |        vy         
-------------------+-------------------
  4567890123456789 |                  
 -4567890123456789 |                  
  4567890123456789 |               123
               123 |               456
  4567890123456789 |               123
               123 |  4567890123456789
               123 |                  
               456 |                  
               123 |  4567890123456789
  4567890123456789 |               123
               123 |  4567890123456789
  4567890123456789 |  4567890123456789
               123 |  4567890123456789
  4567890123456789 | -4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |               123
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 | -4567890123456789
(20 rows)

--Testcase 466:
explain (verbose, costs off)
select * from
  (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL a) a left join
  lateral (select *, a.q2 as x from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL b) b) ss on a.q2 = ss.q1;
                                                                                             QUERY PLAN                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Output: ((a.fields ->> 'q1'::text))::bigint, ((a.fields ->> 'q2'::text))::bigint, ((b.fields ->> 'q1'::text))::bigint, ((b.fields ->> 'q2'::text))::bigint, (((a.fields ->> 'q2'::text))::bigint)
   ->  Foreign Scan on public.int8_tbl a
         Output: a.fields
         InfluxDB query: SELECT * FROM "int8_tbl"
   ->  Foreign Scan on public.int8_tbl b
         Output: b.fields, ((a.fields ->> 'q2'::text))::bigint
         InfluxDB query: SELECT * FROM "int8_tbl" WHERE (($1 = "q1"))
(8 rows)

--Testcase 467:
select * from
  (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL a) a left join
  lateral (select *, a.q2 as x from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL b) b) ss on a.q2 = ss.q1;
        q1        |        q2         |        q1        |        q2         |        x         
------------------+-------------------+------------------+-------------------+------------------
              123 |               456 |                  |                   |                 
              123 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
              123 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
              123 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
 4567890123456789 |               123 |              123 |               456 |              123
 4567890123456789 |               123 |              123 |  4567890123456789 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 |                  |                   |                 
(10 rows)

--Testcase 468:
explain (verbose, costs off)
select * from
  (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL a) a left join
  lateral (select *, coalesce((a.q2)::int8, 42) as x from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL b) b) ss on a.q2 = ss.q1;
                                                                                                         QUERY PLAN                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Output: ((a.fields ->> 'q1'::text))::bigint, ((a.fields ->> 'q2'::text))::bigint, ((b.fields ->> 'q1'::text))::bigint, ((b.fields ->> 'q2'::text))::bigint, (COALESCE(((a.fields ->> 'q2'::text))::bigint, '42'::bigint))
   ->  Foreign Scan on public.int8_tbl a
         Output: a.fields
         InfluxDB query: SELECT * FROM "int8_tbl"
   ->  Foreign Scan on public.int8_tbl b
         Output: b.fields, COALESCE(((a.fields ->> 'q2'::text))::bigint, '42'::bigint)
         InfluxDB query: SELECT * FROM "int8_tbl" WHERE (($1 = "q1"))
(8 rows)

--Testcase 469:
select * from
  (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL a) a left join
  lateral (select *, coalesce((a.q2)::int8, 42) as x from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL b) b) ss on a.q2 = ss.q1;
        q1        |        q2         |        q1        |        q2         |        x         
------------------+-------------------+------------------+-------------------+------------------
              123 |               456 |                  |                   |                 
              123 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
              123 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
              123 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
 4567890123456789 |               123 |              123 |               456 |              123
 4567890123456789 |               123 |              123 |  4567890123456789 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 |                  |                   |                 
(10 rows)

-- lateral can result in join conditions appearing below their
-- real semantic level
--Testcase 470:
explain (verbose, costs off)
select * from (select (fields->>'f1')::int4 f1 from INT4_TBL i) i left join
  lateral (select * from (select (fields->>'f1')::int2 f1 from INT2_TBL j) j where i.f1 = j.f1) k on true;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Merge Left Join
   Output: (((i.fields ->> 'f1'::text))::integer), ((j.fields ->> 'f1'::text))::smallint
   Merge Cond: ((((i.fields ->> 'f1'::text))::integer) = (((j.fields ->> 'f1'::text))::smallint))
   ->  Sort
         Output: i.fields, (((i.fields ->> 'f1'::text))::integer)
         Sort Key: (((i.fields ->> 'f1'::text))::integer)
         ->  Foreign Scan on public.int4_tbl i
               Output: i.fields, ((i.fields ->> 'f1'::text))::integer
               InfluxDB query: SELECT * FROM "int4_tbl"
   ->  Sort
         Output: j.fields, (((j.fields ->> 'f1'::text))::smallint)
         Sort Key: (((j.fields ->> 'f1'::text))::smallint)
         ->  Foreign Scan on public.int2_tbl j
               Output: j.fields, ((j.fields ->> 'f1'::text))::smallint
               InfluxDB query: SELECT * FROM "int2_tbl"
(15 rows)

--Testcase 471:
select * from (select (fields->>'f1')::int4 f1 from INT4_TBL i) i left join
  lateral (select * from (select (fields->>'f1')::int2 f1 from INT2_TBL j) j where i.f1 = j.f1) k on true;
     f1      | f1 
-------------+----
 -2147483647 |   
     -123456 |   
           0 |  0
      123456 |   
  2147483647 |   
(5 rows)

--Testcase 472:
explain (verbose, costs off)
select * from (select (fields->>'f1')::int4 f1 from INT4_TBL i) i left join
  lateral (select coalesce(i) from (select (fields->>'f1')::int2 f1 from INT2_TBL j) j where i.f1 = j.f1) k on true;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Output: ((i.fields ->> 'f1'::text))::integer, (COALESCE(ROW(((i.fields ->> 'f1'::text))::integer)))
   ->  Foreign Scan on public.int4_tbl i
         Output: i.fields
         InfluxDB query: SELECT * FROM "int4_tbl"
   ->  Foreign Scan on public.int2_tbl j
         Output: j.fields, COALESCE(ROW(((i.fields ->> 'f1'::text))::integer))
         InfluxDB query: SELECT * FROM "int2_tbl" WHERE (($1 = "f1"))
(8 rows)

--Testcase 473:
select * from (select (fields->>'f1')::int4 f1 from INT4_TBL i) i left join
  lateral (select coalesce(i) from (select (fields->>'f1')::int2 f1 from INT2_TBL j) j where i.f1 = j.f1) k on true;
     f1      | coalesce 
-------------+----------
           0 | (0)
      123456 | 
     -123456 | 
  2147483647 | 
 -2147483647 | 
(5 rows)

--Testcase 474:
explain (verbose, costs off)
select * from (select (fields->>'f1')::int4 f1 from INT4_TBL a) a,
  lateral (
    select * from (select (fields->>'f1')::int4 f1 from INT4_TBL b) b left join (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL c) c on (b.f1 = q1 and a.f1 = q2)
  ) ss;
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: ((a.fields ->> 'f1'::text))::integer, (((b.fields ->> 'f1'::text))::integer), (((c.fields ->> 'q1'::text))::bigint), (((c.fields ->> 'q2'::text))::bigint)
   ->  Foreign Scan on public.int4_tbl a
         Output: a.fields
         InfluxDB query: SELECT * FROM "int4_tbl"
   ->  Hash Left Join
         Output: ((b.fields ->> 'f1'::text))::integer, ((c.fields ->> 'q1'::text))::bigint, ((c.fields ->> 'q2'::text))::bigint
         Hash Cond: (((b.fields ->> 'f1'::text))::integer = ((c.fields ->> 'q1'::text))::bigint)
         ->  Foreign Scan on public.int4_tbl b
               Output: b.fields
               InfluxDB query: SELECT * FROM "int4_tbl"
         ->  Hash
               Output: c.fields
               ->  Foreign Scan on public.int8_tbl c
                     Output: c.fields
                     InfluxDB query: SELECT * FROM "int8_tbl" WHERE (($1 = "q2"))
(16 rows)

--Testcase 475:
select * from (select (fields->>'f1')::int4 f1 from INT4_TBL a) a,
  lateral (
    select * from (select (fields->>'f1')::int4 f1 from INT4_TBL b) b left join (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL c) c on (b.f1 = q1 and a.f1 = q2)
  ) ss;
     f1      |     f1      | q1 | q2 
-------------+-------------+----+----
           0 |           0 |    |   
           0 |      123456 |    |   
           0 |     -123456 |    |   
           0 |  2147483647 |    |   
           0 | -2147483647 |    |   
      123456 |           0 |    |   
      123456 |      123456 |    |   
      123456 |     -123456 |    |   
      123456 |  2147483647 |    |   
      123456 | -2147483647 |    |   
     -123456 |           0 |    |   
     -123456 |      123456 |    |   
     -123456 |     -123456 |    |   
     -123456 |  2147483647 |    |   
     -123456 | -2147483647 |    |   
  2147483647 |           0 |    |   
  2147483647 |      123456 |    |   
  2147483647 |     -123456 |    |   
  2147483647 |  2147483647 |    |   
  2147483647 | -2147483647 |    |   
 -2147483647 |           0 |    |   
 -2147483647 |      123456 |    |   
 -2147483647 |     -123456 |    |   
 -2147483647 |  2147483647 |    |   
 -2147483647 | -2147483647 |    |   
(25 rows)

-- lateral reference in a PlaceHolderVar evaluated at join level
--Testcase 476:
explain (verbose, costs off)
select * from
  (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) a left join lateral
  (select (b.fields->>'q1')::int8 as bq1,  (c.fields->>'q1')::int8 as cq1, least(a.q1,(b.fields->>'q1')::int8,(c.fields->>'q1')::int8) from
   int8_tbl b cross join int8_tbl c) ss
  on a.q2 = ss.bq1;
                                                                                                                                                QUERY PLAN                                                                                                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Output: ((int8_tbl.fields ->> 'q1'::text))::bigint, ((int8_tbl.fields ->> 'q2'::text))::bigint, ((b.fields ->> 'q1'::text))::bigint, ((c.fields ->> 'q1'::text))::bigint, (LEAST(((int8_tbl.fields ->> 'q1'::text))::bigint, ((b.fields ->> 'q1'::text))::bigint, ((c.fields ->> 'q1'::text))::bigint))
   ->  Foreign Scan on public.int8_tbl
         Output: int8_tbl.fields
         InfluxDB query: SELECT * FROM "int8_tbl"
   ->  Nested Loop
         Output: b.fields, c.fields, LEAST(((int8_tbl.fields ->> 'q1'::text))::bigint, ((b.fields ->> 'q1'::text))::bigint, ((c.fields ->> 'q1'::text))::bigint)
         ->  Foreign Scan on public.int8_tbl b
               Output: b.fields
               InfluxDB query: SELECT * FROM "int8_tbl" WHERE (($1 = "q1"))
         ->  Materialize
               Output: c.fields
               ->  Foreign Scan on public.int8_tbl c
                     Output: c.fields
                     InfluxDB query: SELECT * FROM "int8_tbl"
(15 rows)

--Testcase 477:
select * from
  (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) a left join lateral
  (select (b.fields->>'q1')::int8 as bq1, (c.fields->>'q1')::int8 as cq1, least(a.q1,(b.fields->>'q1')::int8,(c.fields->>'q1')::int8) from
   int8_tbl b cross join int8_tbl c) ss
  on a.q2 = ss.bq1;
        q1        |        q2         |       bq1        |       cq1        |      least       
------------------+-------------------+------------------+------------------+------------------
              123 |               456 |                  |                  |                 
              123 |  4567890123456789 | 4567890123456789 |              123 |              123
              123 |  4567890123456789 | 4567890123456789 |              123 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
              123 |  4567890123456789 | 4567890123456789 |              123 |              123
              123 |  4567890123456789 | 4567890123456789 |              123 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
              123 |  4567890123456789 | 4567890123456789 |              123 |              123
              123 |  4567890123456789 | 4567890123456789 |              123 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
 4567890123456789 |               123 |              123 |              123 |              123
 4567890123456789 |               123 |              123 |              123 |              123
 4567890123456789 |               123 |              123 | 4567890123456789 |              123
 4567890123456789 |               123 |              123 | 4567890123456789 |              123
 4567890123456789 |               123 |              123 | 4567890123456789 |              123
 4567890123456789 |               123 |              123 |              123 |              123
 4567890123456789 |               123 |              123 |              123 |              123
 4567890123456789 |               123 |              123 | 4567890123456789 |              123
 4567890123456789 |               123 |              123 | 4567890123456789 |              123
 4567890123456789 |               123 |              123 | 4567890123456789 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 |                  |                  |                 
(42 rows)

-- case requiring nested PlaceHolderVars
--Testcase 478:
explain (verbose, costs off)
select * from
  (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL c) c left join (
    (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL a) a left join (select (fields->>'q1')::int8 q1, coalesce((fields->>'q2')::int8,42) as x from int8_tbl b) ss1
      on a.q2 = ss1.q1
    cross join
    lateral (select (fields->>'q1')::int8 q1, coalesce(ss1.x,(fields->>'q2')::int8) as y from int8_tbl d) ss2
  ) on c.q2 = ss2.q1,
  lateral (select ss2.y offset 0) ss3;
                                                                                                                                                                                                                                                               QUERY PLAN                                                                                                                                                                                                                                                                
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: ((c.fields ->> 'q1'::text))::bigint, ((c.fields ->> 'q2'::text))::bigint, ((a.fields ->> 'q1'::text))::bigint, ((a.fields ->> 'q2'::text))::bigint, ((b.fields ->> 'q1'::text))::bigint, (COALESCE(((b.fields ->> 'q2'::text))::bigint, '42'::bigint)), ((d.fields ->> 'q1'::text))::bigint, (COALESCE((COALESCE(((b.fields ->> 'q2'::text))::bigint, '42'::bigint)), ((d.fields ->> 'q2'::text))::bigint)), ((COALESCE((COALESCE(((b.fields ->> 'q2'::text))::bigint, '42'::bigint)), ((d.fields ->> 'q2'::text))::bigint)))
   ->  Merge Left Join
         Output: c.fields, a.fields, b.fields, d.fields, (COALESCE(((b.fields ->> 'q2'::text))::bigint, '42'::bigint)), (COALESCE((COALESCE(((b.fields ->> 'q2'::text))::bigint, '42'::bigint)), ((d.fields ->> 'q2'::text))::bigint))
         Merge Cond: ((((c.fields ->> 'q2'::text))::bigint) = (((d.fields ->> 'q1'::text))::bigint))
         ->  Sort
               Output: c.fields, (((c.fields ->> 'q2'::text))::bigint)
               Sort Key: (((c.fields ->> 'q2'::text))::bigint)
               ->  Foreign Scan on public.int8_tbl c
                     Output: c.fields, ((c.fields ->> 'q2'::text))::bigint
                     InfluxDB query: SELECT * FROM "int8_tbl"
         ->  Materialize
               Output: a.fields, b.fields, d.fields, (COALESCE(((b.fields ->> 'q2'::text))::bigint, '42'::bigint)), (COALESCE((COALESCE(((b.fields ->> 'q2'::text))::bigint, '42'::bigint)), ((d.fields ->> 'q2'::text))::bigint)), (((d.fields ->> 'q1'::text))::bigint)
               ->  Sort
                     Output: a.fields, b.fields, d.fields, (COALESCE(((b.fields ->> 'q2'::text))::bigint, '42'::bigint)), (COALESCE((COALESCE(((b.fields ->> 'q2'::text))::bigint, '42'::bigint)), ((d.fields ->> 'q2'::text))::bigint)), (((d.fields ->> 'q1'::text))::bigint)
                     Sort Key: (((d.fields ->> 'q1'::text))::bigint)
                     ->  Nested Loop
                           Output: a.fields, b.fields, d.fields, (COALESCE(((b.fields ->> 'q2'::text))::bigint, '42'::bigint)), (COALESCE((COALESCE(((b.fields ->> 'q2'::text))::bigint, '42'::bigint)), ((d.fields ->> 'q2'::text))::bigint)), ((d.fields ->> 'q1'::text))::bigint
                           ->  Merge Right Join
                                 Output: a.fields, b.fields, (COALESCE(((b.fields ->> 'q2'::text))::bigint, '42'::bigint))
                                 Merge Cond: ((((b.fields ->> 'q1'::text))::bigint) = (((a.fields ->> 'q2'::text))::bigint))
                                 ->  Sort
                                       Output: b.fields, (COALESCE(((b.fields ->> 'q2'::text))::bigint, '42'::bigint)), (((b.fields ->> 'q1'::text))::bigint)
                                       Sort Key: (((b.fields ->> 'q1'::text))::bigint)
                                       ->  Foreign Scan on public.int8_tbl b
                                             Output: b.fields, COALESCE(((b.fields ->> 'q2'::text))::bigint, '42'::bigint), ((b.fields ->> 'q1'::text))::bigint
                                             InfluxDB query: SELECT * FROM "int8_tbl"
                                 ->  Sort
                                       Output: a.fields, (((a.fields ->> 'q2'::text))::bigint)
                                       Sort Key: (((a.fields ->> 'q2'::text))::bigint)
                                       ->  Foreign Scan on public.int8_tbl a
                                             Output: a.fields, ((a.fields ->> 'q2'::text))::bigint
                                             InfluxDB query: SELECT * FROM "int8_tbl"
                           ->  Foreign Scan on public.int8_tbl d
                                 Output: d.fields, COALESCE((COALESCE(((b.fields ->> 'q2'::text))::bigint, '42'::bigint)), ((d.fields ->> 'q2'::text))::bigint)
                                 InfluxDB query: SELECT * FROM "int8_tbl"
   ->  Result
         Output: (COALESCE((COALESCE(((b.fields ->> 'q2'::text))::bigint, '42'::bigint)), ((d.fields ->> 'q2'::text))::bigint))
(38 rows)

-- case that breaks the old ph_may_need optimization
--Testcase 479:
explain (verbose, costs off)
select c.*,a.*,ss1.q1,ss2.q1,ss3.* from
  (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL c) c left join (
    (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL a) a left join
      (select q1, coalesce(q2,f1) as x from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL b) b, (select (fields->>'f1')::int4 f1 from INT4_TBL b2) b2
       where (q1)::int8 < (f1)::int4) ss1
      on a.q2 = ss1.q1
    cross join
    lateral (select (fields->>'q1')::int8 q1, coalesce(ss1.x,(fields->>'q2')::int8) as y from int8_tbl d) ss2
  ) on c.q2 = ss2.q1,
  lateral (select * from (select (fields->>'f1')::int4 f1 from INT4_TBL i) i where (ss2.y)::int8 > (f1)::int4) ss3;
                                                                                                                                  QUERY PLAN                                                                                                                                  
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: ((c.fields ->> 'q1'::text))::bigint, ((c.fields ->> 'q2'::text))::bigint, ((a.fields ->> 'q1'::text))::bigint, ((a.fields ->> 'q2'::text))::bigint, ((b.fields ->> 'q1'::text))::bigint, ((d.fields ->> 'q1'::text))::bigint, ((i.fields ->> 'f1'::text))::integer
   Join Filter: ((COALESCE((COALESCE(((b.fields ->> 'q2'::text))::bigint, (((b2.fields ->> 'f1'::text))::integer)::bigint)), ((d.fields ->> 'q2'::text))::bigint)) > ((i.fields ->> 'f1'::text))::integer)
   ->  Merge Left Join
         Output: c.fields, a.fields, b.fields, d.fields, (COALESCE((COALESCE(((b.fields ->> 'q2'::text))::bigint, (((b2.fields ->> 'f1'::text))::integer)::bigint)), ((d.fields ->> 'q2'::text))::bigint))
         Merge Cond: ((((c.fields ->> 'q2'::text))::bigint) = (((d.fields ->> 'q1'::text))::bigint))
         ->  Sort
               Output: c.fields, (((c.fields ->> 'q2'::text))::bigint)
               Sort Key: (((c.fields ->> 'q2'::text))::bigint)
               ->  Foreign Scan on public.int8_tbl c
                     Output: c.fields, ((c.fields ->> 'q2'::text))::bigint
                     InfluxDB query: SELECT * FROM "int8_tbl"
         ->  Materialize
               Output: a.fields, b.fields, d.fields, (COALESCE((COALESCE(((b.fields ->> 'q2'::text))::bigint, (((b2.fields ->> 'f1'::text))::integer)::bigint)), ((d.fields ->> 'q2'::text))::bigint)), (((d.fields ->> 'q1'::text))::bigint)
               ->  Sort
                     Output: a.fields, b.fields, d.fields, (COALESCE((COALESCE(((b.fields ->> 'q2'::text))::bigint, (((b2.fields ->> 'f1'::text))::integer)::bigint)), ((d.fields ->> 'q2'::text))::bigint)), (((d.fields ->> 'q1'::text))::bigint)
                     Sort Key: (((d.fields ->> 'q1'::text))::bigint)
                     ->  Nested Loop
                           Output: a.fields, b.fields, d.fields, (COALESCE((COALESCE(((b.fields ->> 'q2'::text))::bigint, (((b2.fields ->> 'f1'::text))::integer)::bigint)), ((d.fields ->> 'q2'::text))::bigint)), ((d.fields ->> 'q1'::text))::bigint
                           ->  Merge Left Join
                                 Output: a.fields, b.fields, (COALESCE(((b.fields ->> 'q2'::text))::bigint, (((b2.fields ->> 'f1'::text))::integer)::bigint))
                                 Merge Cond: ((((a.fields ->> 'q2'::text))::bigint) = (((b.fields ->> 'q1'::text))::bigint))
                                 ->  Sort
                                       Output: a.fields, (((a.fields ->> 'q2'::text))::bigint)
                                       Sort Key: (((a.fields ->> 'q2'::text))::bigint)
                                       ->  Foreign Scan on public.int8_tbl a
                                             Output: a.fields, ((a.fields ->> 'q2'::text))::bigint
                                             InfluxDB query: SELECT * FROM "int8_tbl"
                                 ->  Materialize
                                       Output: b.fields, (COALESCE(((b.fields ->> 'q2'::text))::bigint, (((b2.fields ->> 'f1'::text))::integer)::bigint)), (((b.fields ->> 'q1'::text))::bigint)
                                       ->  Sort
                                             Output: b.fields, (COALESCE(((b.fields ->> 'q2'::text))::bigint, (((b2.fields ->> 'f1'::text))::integer)::bigint)), (((b.fields ->> 'q1'::text))::bigint)
                                             Sort Key: (((b.fields ->> 'q1'::text))::bigint)
                                             ->  Nested Loop
                                                   Output: b.fields, COALESCE(((b.fields ->> 'q2'::text))::bigint, (((b2.fields ->> 'f1'::text))::integer)::bigint), ((b.fields ->> 'q1'::text))::bigint
                                                   Join Filter: (((b.fields ->> 'q1'::text))::bigint < ((b2.fields ->> 'f1'::text))::integer)
                                                   ->  Foreign Scan on public.int8_tbl b
                                                         Output: b.fields
                                                         InfluxDB query: SELECT * FROM "int8_tbl"
                                                   ->  Materialize
                                                         Output: b2.fields
                                                         ->  Foreign Scan on public.int4_tbl b2
                                                               Output: b2.fields
                                                               InfluxDB query: SELECT * FROM "int4_tbl"
                           ->  Foreign Scan on public.int8_tbl d
                                 Output: d.fields, COALESCE((COALESCE(((b.fields ->> 'q2'::text))::bigint, (((b2.fields ->> 'f1'::text))::integer)::bigint)), ((d.fields ->> 'q2'::text))::bigint)
                                 InfluxDB query: SELECT * FROM "int8_tbl"
   ->  Materialize
         Output: i.fields
         ->  Foreign Scan on public.int4_tbl i
               Output: i.fields
               InfluxDB query: SELECT * FROM "int4_tbl"
(52 rows)

-- check processing of postponed quals (bug #9041)
--Testcase 480:
explain (verbose, costs off)
select * from
  (select 1 as x offset 0) x cross join (select 2 as y offset 0) y
  left join lateral (
    select * from (select 3 as z offset 0) z where z.z = x.x
  ) zz on zz.z = y.y;
                  QUERY PLAN                  
----------------------------------------------
 Nested Loop Left Join
   Output: (1), (2), (3)
   Join Filter: (((3) = (1)) AND ((3) = (2)))
   ->  Nested Loop
         Output: (1), (2)
         ->  Result
               Output: 1
         ->  Result
               Output: 2
   ->  Result
         Output: 3
(11 rows)

-- check dummy rels with lateral references (bug #15694)
--Testcase 481:
explain (verbose, costs off)
select * from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8) i8 left join lateral
  (select *, i8.q2 from (select (fields->>'f1')::int4 f1 from INT4_TBL int4_tbl) int4_tbl where false) ss on true;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Output: ((i8.fields ->> 'q1'::text))::bigint, ((i8.fields ->> 'q2'::text))::bigint, ((fields ->> 'f1'::text))::integer, (((i8.fields ->> 'q2'::text))::bigint)
   ->  Foreign Scan on public.int8_tbl i8
         Output: i8.fields
         InfluxDB query: SELECT * FROM "int8_tbl"
   ->  Result
         Output: fields, ((i8.fields ->> 'q2'::text))::bigint
         One-Time Filter: false
(8 rows)

--Testcase 482:
explain (verbose, costs off)
select * from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL i8) i8 left join lateral
  (select *, i8.q2 from (select (fields->>'f1')::int4 f1 from INT4_TBL i1) i1, (select (fields->>'f1')::int4 f1 from INT4_TBL i2) i2 where false) ss on true;
                                                                                              QUERY PLAN                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Output: ((i8.fields ->> 'q1'::text))::bigint, ((i8.fields ->> 'q2'::text))::bigint, ((fields ->> 'f1'::text))::integer, ((fields ->> 'f1'::text))::integer, (((i8.fields ->> 'q2'::text))::bigint)
   ->  Foreign Scan on public.int8_tbl i8
         Output: i8.fields
         InfluxDB query: SELECT * FROM "int8_tbl"
   ->  Result
         Output: fields, fields, ((i8.fields ->> 'q2'::text))::bigint
         One-Time Filter: false
(8 rows)

-- check handling of nested appendrels inside LATERAL
--Testcase 483:
select * from
  ((select 2 as v) union all (select 3 as v)) as q1
  cross join lateral
  ((select * from
      ((select 4 as v) union all (select 5 as v)) as q3)
   union all
   (select q1.v)
  ) as q2;
 v | v 
---+---
 2 | 4
 2 | 5
 2 | 2
 3 | 4
 3 | 5
 3 | 3
(6 rows)

-- check the number of columns specified
--Testcase 665:
SELECT * FROM ((SELECT fields->>'q1', fields->>'q2' FROM int8_tbl) i cross join (SELECT fields->>'f1' FROM int4_tbl)  j) ss(a,b,c,d);
ERROR:  join expression "ss" has 3 columns available but 4 columns specified
-- check we don't try to do a unique-ified semijoin with LATERAL
--Testcase 484:
explain (verbose, costs off)
select * from
  (values (0,9998), (1,1000)) v(id,x),
  lateral (select (fields->>'f1')::int4 f1 from INT4_TBL
           where (fields->>'f1')::int4 = any (select (fields->>'unique1')::int4 from tenk1
                           where (fields->>'unique2')::int4 = v.x offset 0)) ss;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: "*VALUES*".column1, "*VALUES*".column2, ((int4_tbl.fields ->> 'f1'::text))::integer
   ->  Values Scan on "*VALUES*"
         Output: "*VALUES*".column1, "*VALUES*".column2
   ->  Hash Semi Join
         Output: int4_tbl.fields
         Hash Cond: (((int4_tbl.fields ->> 'f1'::text))::integer = (((tenk1.fields ->> 'unique1'::text))::integer))
         ->  Foreign Scan on public.int4_tbl
               Output: int4_tbl.fields
               InfluxDB query: SELECT * FROM "int4_tbl"
         ->  Hash
               Output: (((tenk1.fields ->> 'unique1'::text))::integer)
               ->  Foreign Scan on public.tenk1
                     Output: ((tenk1.fields ->> 'unique1'::text))::integer
                     InfluxDB query: SELECT "unique1" FROM "tenk" WHERE (("unique2" = $1))
(15 rows)

--Testcase 485:
select * from
  (values (0,9998), (1,1000)) v(id,x),
  lateral (select (fields->>'f1')::int4 f1 from INT4_TBL
           where (fields->>'f1')::int4 = any (select (fields->>'unique1')::int4 from tenk1
                           where (fields->>'unique2')::int4 = v.x offset 0)) ss;
 id |  x   | f1 
----+------+----
  0 | 9998 |  0
(1 row)

-- check proper extParam/allParam handling (this isn't exactly a LATERAL issue,
-- but we can make the test case much more compact with LATERAL)
--Testcase 486:
explain (verbose, costs off)
select * from (values (0), (1)) v(id),
lateral (select * from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) t1,
         lateral (select * from
                    (select * from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) t2
                     where q1 = any (select (fields->>'q2')::int8 from int8_tbl t3
                                     where (fields->>'q2')::int8 = (select greatest(t1.q1,t2.q2))
                                       and (select v.id=0)) offset 0) ss2) ss
         where (t1.q1)::int8 = (ss.q2)::int8) ss0;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: "*VALUES*".column1, ((int8_tbl.fields ->> 'q1'::text))::bigint, ((int8_tbl.fields ->> 'q2'::text))::bigint, ss2.q1, ss2.q2
   ->  Foreign Scan on public.int8_tbl
         Output: int8_tbl.fields
         InfluxDB query: SELECT * FROM "int8_tbl"
   ->  Nested Loop
         Output: "*VALUES*".column1, ss2.q1, ss2.q2
         ->  Values Scan on "*VALUES*"
               Output: "*VALUES*".column1
         ->  Subquery Scan on ss2
               Output: ss2.q1, ss2.q2
               Filter: (((int8_tbl.fields ->> 'q1'::text))::bigint = ss2.q2)
               ->  Foreign Scan on public.int8_tbl int8_tbl_1
                     Output: ((int8_tbl_1.fields ->> 'q1'::text))::bigint, ((int8_tbl_1.fields ->> 'q2'::text))::bigint
                     Filter: (SubPlan 3)
                     InfluxDB query: SELECT "q1", "q2" FROM "int8_tbl"
                     SubPlan 3
                       ->  Result
                             Output: (((t3.fields ->> 'q2'::text))::bigint)
                             One-Time Filter: $4
                             InitPlan 1 (returns $2)
                               ->  Result
                                     Output: GREATEST((($0 ->> 'q1'::text))::bigint, ((int8_tbl_1.fields ->> 'q2'::text))::bigint)
                             InitPlan 2 (returns $4)
                               ->  Result
                                     Output: ($3 = 0)
                             ->  Foreign Scan on public.int8_tbl t3
                                   Output: ((t3.fields ->> 'q2'::text))::bigint
                                   InfluxDB query: SELECT "q2" FROM "int8_tbl" WHERE (("q2" = $1))
(29 rows)

--Testcase 487:
select * from (values (0), (1)) v(id),
lateral (select * from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) t1,
         lateral (select * from
                    (select * from (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) t2
                     where q1 = any (select (fields->>'q2')::int8 from int8_tbl t3
                                     where (fields->>'q2')::int8 = (select greatest(t1.q1,t2.q2))
                                       and (select v.id=0)) offset 0) ss2) ss
         where t1.q1 = ss.q2) ss0;
 id |        q1        |        q2         |        q1        |        q2        
----+------------------+-------------------+------------------+------------------
  0 | 4567890123456789 |               123 | 4567890123456789 | 4567890123456789
  0 | 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789
  0 | 4567890123456789 | -4567890123456789 | 4567890123456789 | 4567890123456789
(3 rows)

-- test some error cases where LATERAL should have been used but wasn't
--Testcase 488:
select (fields->>'f1')::int4 f1,(fields->>'g')::int4 g from int4_tbl a, (select fields->>'f1' as g) ss;
ERROR:  column "fields" does not exist
LINE 1: ...1,(fields->>'g')::int4 g from int4_tbl a, (select fields->>'...
                                                             ^
HINT:  There is a column named "fields" in table "a", but it cannot be referenced from this part of the query.
--Testcase 489:
select (fields->>'f1')::int4 f1,(fields->>'g')::int4 g from int4_tbl a, (select a.fields->>'f1' as g) ss;
ERROR:  invalid reference to FROM-clause entry for table "a"
LINE 1: ...1,(fields->>'g')::int4 g from int4_tbl a, (select a.fields->...
                                                             ^
HINT:  There is an entry for table "a", but it cannot be referenced from this part of the query.
--Testcase 490:
select (fields->>'f1')::int4 f1,(fields->>'g')::int4 g from int4_tbl a cross join (select fields->>'f1' as g) ss;
ERROR:  column "fields" does not exist
LINE 1: ...>>'g')::int4 g from int4_tbl a cross join (select fields->>'...
                                                             ^
HINT:  There is a column named "fields" in table "a", but it cannot be referenced from this part of the query.
--Testcase 491:
select (fields->>'f1')::int4 f1,(fields->>'g')::int4 g from int4_tbl a cross join (select a.fields->>'f1' as g) ss;
ERROR:  invalid reference to FROM-clause entry for table "a"
LINE 1: ...>>'g')::int4 g from int4_tbl a cross join (select a.fields->...
                                                             ^
HINT:  There is an entry for table "a", but it cannot be referenced from this part of the query.
-- SQL:2008 says the left table is in scope but illegal to access here
--Testcase 492:
select (fields->>'f1')::int4 f1,(fields->>'g')::int4 g from int4_tbl a right join lateral generate_series(0, (a.fields->>'f1')::int4) g on true;
ERROR:  invalid reference to FROM-clause entry for table "a"
LINE 1: ...int4_tbl a right join lateral generate_series(0, (a.fields->...
                                                             ^
DETAIL:  The combining JOIN type must be INNER or LEFT for a LATERAL reference.
--Testcase 493:
select (fields->>'f1')::int4 f1,(fields->>'g')::int4 g from int4_tbl a full join lateral generate_series(0, (a.fields->>'f1')::int4) g on true;
ERROR:  invalid reference to FROM-clause entry for table "a"
LINE 1: ... int4_tbl a full join lateral generate_series(0, (a.fields->...
                                                             ^
DETAIL:  The combining JOIN type must be INNER or LEFT for a LATERAL reference.
-- check we complain about ambiguous table references
--Testcase 494:
select * from
  (select (fields->>'q1')::int8 q1, (fields->>'q2')::int8 q2 from INT8_TBL) x cross join ((select (fields->>'f1')::int4 f1 from INT4_TBL) x cross join lateral (select x.f1) ss);
ERROR:  table reference "x" is ambiguous
LINE 2: ...t4 f1 from INT4_TBL) x cross join lateral (select x.f1) ss);
                                                             ^
-- LATERAL can be used to put an aggregate into the FROM clause of its query
--Testcase 495:
select 1 from tenk1 a, lateral (select max((a.fields->>'unique1')::int4) from int4_tbl b) ss;
ERROR:  aggregate functions are not allowed in FROM clause of their own query level
LINE 1: select 1 from tenk1 a, lateral (select max((a.fields->>'uniq...
                                               ^
-- check behavior of LATERAL in UPDATE/DELETE
--Testcase 496:
create temp table xx1 as select fields->>'f1' as x1, -(fields->>'f1')::int4 as x2 from int4_tbl;
-- error, can't do this:
--Testcase 497:
update xx1 set x2 = f1 from (select * from (select (fields->>'f1')::int4 f1 from INT4_TBL) int4_tbl where f1 = x1) ss;
ERROR:  column "x1" does not exist
LINE 1: ...->>'f1')::int4 f1 from INT4_TBL) int4_tbl where f1 = x1) ss;
                                                                ^
HINT:  There is a column named "x1" in table "xx1", but it cannot be referenced from this part of the query.
--Testcase 498:
update xx1 set x2 = f1 from (select * from (select (fields->>'f1')::int4 f1 from INT4_TBL) int4_tbl where f1 = xx1.x1) ss;
ERROR:  invalid reference to FROM-clause entry for table "xx1"
LINE 1: ...'f1')::int4 f1 from INT4_TBL) int4_tbl where f1 = xx1.x1) ss...
                                                             ^
HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
-- can't do it even with LATERAL:
--Testcase 499:
update xx1 set x2 = f1 from lateral (select * from (select (fields->>'f1')::int4 f1 from INT4_TBL) int4_tbl where f1 = x1) ss;
ERROR:  invalid reference to FROM-clause entry for table "xx1"
LINE 1: ...->>'f1')::int4 f1 from INT4_TBL) int4_tbl where f1 = x1) ss;
                                                                ^
HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
-- we might in future allow something like this, but for now it's an error:
--Testcase 500:
update xx1 set x2 = f1 from xx1, lateral (select * from (select (fields->>'f1')::int4 f1 from INT4_TBL) int4_tbl where f1 = x1) ss;
ERROR:  table name "xx1" specified more than once
-- also errors:
--Testcase 501:
delete from xx1 using (select * from (select (fields->>'f1')::int4 f1 from INT4_TBL) int4_tbl where f1 = x1) ss;
ERROR:  column "x1" does not exist
LINE 1: ...->>'f1')::int4 f1 from INT4_TBL) int4_tbl where f1 = x1) ss;
                                                                ^
HINT:  There is a column named "x1" in table "xx1", but it cannot be referenced from this part of the query.
--Testcase 502:
delete from xx1 using (select * from (select (fields->>'f1')::int4 f1 from INT4_TBL) int4_tbl where f1 = xx1.x1) ss;
ERROR:  invalid reference to FROM-clause entry for table "xx1"
LINE 1: ...'f1')::int4 f1 from INT4_TBL) int4_tbl where f1 = xx1.x1) ss...
                                                             ^
HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
--Testcase 503:
delete from xx1 using lateral (select * from (select (fields->>'f1')::int4 f1 from INT4_TBL) int4_tbl where f1 = x1) ss;
ERROR:  invalid reference to FROM-clause entry for table "xx1"
LINE 1: ...->>'f1')::int4 f1 from INT4_TBL) int4_tbl where f1 = x1) ss;
                                                                ^
HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
/*
-- Influx does not support partition table
--
-- test LATERAL reference propagation down a multi-level inheritance hierarchy
-- produced for a multi-level partitioned table hierarchy.
--
create table join_pt1 (a int, b int, c varchar) partition by range(a);
create table join_pt1p1 partition of join_pt1 for values from (0) to (100) partition by range(b);
create table join_pt1p2 partition of join_pt1 for values from (100) to (200);
create table join_pt1p1p1 partition of join_pt1p1 for values from (0) to (100);
insert into join_pt1 values (1, 1, 'x'), (101, 101, 'y');
create table join_ut1 (a int, b int, c varchar);
insert into join_ut1 values (101, 101, 'y'), (2, 2, 'z');
explain (verbose, costs off)
select t1.b, ss.phv from join_ut1 t1 left join lateral
              (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv
					  from join_pt1 t2 join join_ut1 t3 on t2.a = t3.b) ss
              on t1.a = ss.t2a order by t1.a;
select t1.b, ss.phv from join_ut1 t1 left join lateral
              (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv
					  from join_pt1 t2 join join_ut1 t3 on t2.a = t3.b) ss
              on t1.a = ss.t2a order by t1.a;

drop table join_pt1;
drop table join_ut1;

--
-- test estimation behavior with multi-column foreign key and constant qual
--

begin;

create table fkest (x integer, x10 integer, x10b integer, x100 integer);
insert into fkest select x, x/10, x/10, x/100 from generate_series(1,1000) x;
create unique index on fkest(x, x10, x100);
analyze fkest;

explain (costs off)
select * from fkest f1
  join fkest f2 on (f1.x = f2.x and f1.x10 = f2.x10b and f1.x100 = f2.x100)
  join fkest f3 on f1.x = f3.x
  where f1.x100 = 2;

alter table fkest add constraint fk
  foreign key (x, x10b, x100) references fkest (x, x10, x100);

explain (costs off)
select * from fkest f1
  join fkest f2 on (f1.x = f2.x and f1.x10 = f2.x10b and f1.x100 = f2.x100)
  join fkest f3 on f1.x = f3.x
  where f1.x100 = 2;

rollback;
*/
--
-- test that foreign key join estimation performs sanely for outer joins
--
begin;
--Testcase 504:
create foreign table fkest (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 633:
create foreign table fkest_nsc (a int, b int, c int) server influxdb_svr OPTIONS (table 'fkest');
--Testcase 505:
create foreign table fkest1 (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 634:
create foreign table fkest1_nsc (a int, b int) server influxdb_svr OPTIONS (table 'fkest1');
--Testcase 506:
insert into fkest_nsc select x/10, x%10, x from generate_series(1,1000) x;
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 507:
insert into fkest1_nsc select x/10, x%10 from generate_series(1,1000) x;
WARNING:  Modification query is executing in non-autocommit mode. PGSpider might get inconsistent data.
--Testcase 508:
explain (costs off)
select *
from (select (fields->>'a')::int a, (fields->>'b')::int b, (fields->>'c')::int c from fkest f) f
  left join (select (fields->>'a')::int a, (fields->>'b')::int b from fkest1 f1) f1 on (f.a)::int = (f1.a)::int and (f.b)::int = (f1.b)::int
  left join (select (fields->>'a')::int a, (fields->>'b')::int b from fkest1 f2) f2 on (f.a)::int = (f2.a)::int and (f.b)::int = (f2.b)::int
  left join (select (fields->>'a')::int a, (fields->>'b')::int b from fkest1 f3) f3 on (f.a)::int = (f3.a)::int and (f.b)::int = (f3.b)::int
where (f.c)::bigint = 1;
                                                                                              QUERY PLAN                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join
   Hash Cond: ((((f3.fields ->> 'a'::text))::integer = ((f.fields ->> 'a'::text))::integer) AND (((f3.fields ->> 'b'::text))::integer = ((f.fields ->> 'b'::text))::integer))
   ->  Foreign Scan on fkest1 f3
   ->  Hash
         ->  Hash Right Join
               Hash Cond: ((((f2.fields ->> 'a'::text))::integer = ((f.fields ->> 'a'::text))::integer) AND (((f2.fields ->> 'b'::text))::integer = ((f.fields ->> 'b'::text))::integer))
               ->  Foreign Scan on fkest1 f2
               ->  Hash
                     ->  Hash Right Join
                           Hash Cond: ((((f1.fields ->> 'a'::text))::integer = ((f.fields ->> 'a'::text))::integer) AND (((f1.fields ->> 'b'::text))::integer = ((f.fields ->> 'b'::text))::integer))
                           ->  Foreign Scan on fkest1 f1
                           ->  Hash
                                 ->  Foreign Scan on fkest f
                                       Filter: ((((fields ->> 'c'::text))::integer)::bigint = 1)
(14 rows)

rollback;
--
-- test planner's ability to mark joins as unique
--
--Testcase 509:
create foreign table j1 (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 635:
create foreign table j1_nsc (id int) server influxdb_svr OPTIONS (table 'j1');
--Testcase 510:
create foreign table j2 (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 636:
create foreign table j2_nsc (id int) server influxdb_svr OPTIONS (table 'j2');
--Testcase 511:
create foreign table j3 (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 637:
create foreign table j3_nsc (id int) server influxdb_svr OPTIONS (table 'j3');
--Testcase 512:
insert into j1_nsc values(1),(2),(3);
--Testcase 513:
insert into j2_nsc values(1),(2),(3);
--Testcase 514:
insert into j3_nsc values(1),(1);
-- ensure join is properly marked as unique
--Testcase 515:
explain (verbose, costs off)
select * from (select (fields->>'id')::int id from j1) j1 inner join (select (fields->>'id')::int id from j2) j2 on (j1.id)::int = (j2.id)::int;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Merge Join
   Output: (((j1.fields ->> 'id'::text))::integer), (((j2.fields ->> 'id'::text))::integer)
   Merge Cond: ((((j1.fields ->> 'id'::text))::integer) = (((j2.fields ->> 'id'::text))::integer))
   ->  Sort
         Output: j1.fields, (((j1.fields ->> 'id'::text))::integer)
         Sort Key: (((j1.fields ->> 'id'::text))::integer)
         ->  Foreign Scan on public.j1
               Output: j1.fields, ((j1.fields ->> 'id'::text))::integer
               InfluxDB query: SELECT * FROM "j1"
   ->  Sort
         Output: j2.fields, (((j2.fields ->> 'id'::text))::integer)
         Sort Key: (((j2.fields ->> 'id'::text))::integer)
         ->  Foreign Scan on public.j2
               Output: j2.fields, ((j2.fields ->> 'id'::text))::integer
               InfluxDB query: SELECT * FROM "j2"
(15 rows)

-- ensure join is not unique when not an equi-join
--Testcase 516:
explain (verbose, costs off)
select * from (select (fields->>'id')::int id from j1) j1 inner join (select (fields->>'id')::int id from j2) j2 on (j1.id)::int > (j2.id)::int;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Nested Loop
   Output: ((j1.fields ->> 'id'::text))::integer, ((j2.fields ->> 'id'::text))::integer
   Join Filter: (((j1.fields ->> 'id'::text))::integer > ((j2.fields ->> 'id'::text))::integer)
   ->  Foreign Scan on public.j1
         Output: j1.fields
         InfluxDB query: SELECT * FROM "j1"
   ->  Materialize
         Output: j2.fields
         ->  Foreign Scan on public.j2
               Output: j2.fields
               InfluxDB query: SELECT * FROM "j2"
(11 rows)

-- ensure non-unique rel is not chosen as inner
--Testcase 517:
explain (verbose, costs off)
select * from (select (fields->>'id')::int id from j1) j1 inner join (select (fields->>'id')::int id from j3) j3 on (j1.id)::int = (j3.id)::int;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Merge Join
   Output: (((j1.fields ->> 'id'::text))::integer), (((j3.fields ->> 'id'::text))::integer)
   Merge Cond: ((((j1.fields ->> 'id'::text))::integer) = (((j3.fields ->> 'id'::text))::integer))
   ->  Sort
         Output: j1.fields, (((j1.fields ->> 'id'::text))::integer)
         Sort Key: (((j1.fields ->> 'id'::text))::integer)
         ->  Foreign Scan on public.j1
               Output: j1.fields, ((j1.fields ->> 'id'::text))::integer
               InfluxDB query: SELECT * FROM "j1"
   ->  Sort
         Output: j3.fields, (((j3.fields ->> 'id'::text))::integer)
         Sort Key: (((j3.fields ->> 'id'::text))::integer)
         ->  Foreign Scan on public.j3
               Output: j3.fields, ((j3.fields ->> 'id'::text))::integer
               InfluxDB query: SELECT * FROM "j3"
(15 rows)

-- ensure left join is marked as unique
--Testcase 518:
explain (verbose, costs off)
select * from (select (fields->>'id')::int id from j1) j1 left join (select (fields->>'id')::int id from j2) j2 on (j1.id)::int = (j2.id)::int;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Merge Left Join
   Output: (((j1.fields ->> 'id'::text))::integer), ((j2.fields ->> 'id'::text))::integer
   Merge Cond: ((((j1.fields ->> 'id'::text))::integer) = (((j2.fields ->> 'id'::text))::integer))
   ->  Sort
         Output: j1.fields, (((j1.fields ->> 'id'::text))::integer)
         Sort Key: (((j1.fields ->> 'id'::text))::integer)
         ->  Foreign Scan on public.j1
               Output: j1.fields, ((j1.fields ->> 'id'::text))::integer
               InfluxDB query: SELECT * FROM "j1"
   ->  Sort
         Output: j2.fields, (((j2.fields ->> 'id'::text))::integer)
         Sort Key: (((j2.fields ->> 'id'::text))::integer)
         ->  Foreign Scan on public.j2
               Output: j2.fields, ((j2.fields ->> 'id'::text))::integer
               InfluxDB query: SELECT * FROM "j2"
(15 rows)

-- ensure right join is marked as unique
--Testcase 519:
explain (verbose, costs off)
select * from (select (fields->>'id')::int id from j1) j1 right join (select (fields->>'id')::int id from j2) j2 on (j1.id)::int = (j2.id)::int;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Merge Left Join
   Output: ((j1.fields ->> 'id'::text))::integer, (((j2.fields ->> 'id'::text))::integer)
   Merge Cond: ((((j2.fields ->> 'id'::text))::integer) = (((j1.fields ->> 'id'::text))::integer))
   ->  Sort
         Output: j2.fields, (((j2.fields ->> 'id'::text))::integer)
         Sort Key: (((j2.fields ->> 'id'::text))::integer)
         ->  Foreign Scan on public.j2
               Output: j2.fields, ((j2.fields ->> 'id'::text))::integer
               InfluxDB query: SELECT * FROM "j2"
   ->  Sort
         Output: j1.fields, (((j1.fields ->> 'id'::text))::integer)
         Sort Key: (((j1.fields ->> 'id'::text))::integer)
         ->  Foreign Scan on public.j1
               Output: j1.fields, ((j1.fields ->> 'id'::text))::integer
               InfluxDB query: SELECT * FROM "j1"
(15 rows)

-- ensure full join is marked as unique
--Testcase 520:
explain (verbose, costs off)
select * from (select (fields->>'id')::int id from j1) j1 full join (select (fields->>'id')::int id from j2) j2 on (j1.id)::int = (j2.id)::int;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Merge Full Join
   Output: ((j1.fields ->> 'id'::text))::integer, ((j2.fields ->> 'id'::text))::integer
   Merge Cond: ((((j1.fields ->> 'id'::text))::integer) = (((j2.fields ->> 'id'::text))::integer))
   ->  Sort
         Output: j1.fields, (((j1.fields ->> 'id'::text))::integer)
         Sort Key: (((j1.fields ->> 'id'::text))::integer)
         ->  Foreign Scan on public.j1
               Output: j1.fields, ((j1.fields ->> 'id'::text))::integer
               InfluxDB query: SELECT * FROM "j1"
   ->  Sort
         Output: j2.fields, (((j2.fields ->> 'id'::text))::integer)
         Sort Key: (((j2.fields ->> 'id'::text))::integer)
         ->  Foreign Scan on public.j2
               Output: j2.fields, ((j2.fields ->> 'id'::text))::integer
               InfluxDB query: SELECT * FROM "j2"
(15 rows)

-- a clauseless (cross) join can't be unique
--Testcase 521:
explain (verbose, costs off)
select * from (select (fields->>'id')::int id from j1) j1 cross join (select (fields->>'id')::int id from j2) j2;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Nested Loop
   Output: ((j1.fields ->> 'id'::text))::integer, ((j2.fields ->> 'id'::text))::integer
   ->  Foreign Scan on public.j1
         Output: j1.fields
         InfluxDB query: SELECT * FROM "j1"
   ->  Materialize
         Output: j2.fields
         ->  Foreign Scan on public.j2
               Output: j2.fields
               InfluxDB query: SELECT * FROM "j2"
(10 rows)

-- ensure a natural join is marked as unique
--Testcase 522:
explain (verbose, costs off)
select * from (select (fields->>'id')::int id from j1) j1 natural join (select (fields->>'id')::int id from j2) j2;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Merge Join
   Output: (((j1.fields ->> 'id'::text))::integer)
   Merge Cond: ((((j1.fields ->> 'id'::text))::integer) = (((j2.fields ->> 'id'::text))::integer))
   ->  Sort
         Output: j1.fields, (((j1.fields ->> 'id'::text))::integer)
         Sort Key: (((j1.fields ->> 'id'::text))::integer)
         ->  Foreign Scan on public.j1
               Output: j1.fields, ((j1.fields ->> 'id'::text))::integer
               InfluxDB query: SELECT * FROM "j1"
   ->  Sort
         Output: j2.fields, (((j2.fields ->> 'id'::text))::integer)
         Sort Key: (((j2.fields ->> 'id'::text))::integer)
         ->  Foreign Scan on public.j2
               Output: j2.fields, ((j2.fields ->> 'id'::text))::integer
               InfluxDB query: SELECT * FROM "j2"
(15 rows)

-- ensure a distinct clause allows the inner to become unique
--Testcase 523:
explain (verbose, costs off)
select * from (select (fields->>'id')::int id from j1 j1) j1
inner join (select distinct (fields->>'id')::int id from j3 j3) j3 on (j1.id)::int = (j3.id)::int;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Hash Join
   Output: ((j1.fields ->> 'id'::text))::integer, (((j3.fields ->> 'id'::text))::integer)
   Inner Unique: true
   Hash Cond: (((j1.fields ->> 'id'::text))::integer = (((j3.fields ->> 'id'::text))::integer))
   ->  Foreign Scan on public.j1
         Output: j1.fields
         InfluxDB query: SELECT * FROM "j1"
   ->  Hash
         Output: (((j3.fields ->> 'id'::text))::integer)
         ->  HashAggregate
               Output: (((j3.fields ->> 'id'::text))::integer)
               Group Key: ((j3.fields ->> 'id'::text))::integer
               ->  Foreign Scan on public.j3
                     Output: ((j3.fields ->> 'id'::text))::integer
                     InfluxDB query: SELECT "id" FROM "j3"
(15 rows)

-- ensure group by clause allows the inner to become unique
--Testcase 524:
explain (verbose, costs off)
select * from (select (fields->>'id')::int id from j1 j1) j1
inner join (select (fields->>'id')::int id from j3 j3 group by fields->>'id') j3 on (j1.id)::int = (j3.id)::int;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Hash Join
   Output: ((j1.fields ->> 'id'::text))::integer, j3.id
   Hash Cond: (((j1.fields ->> 'id'::text))::integer = j3.id)
   ->  Foreign Scan on public.j1
         Output: j1.fields
         InfluxDB query: SELECT * FROM "j1"
   ->  Hash
         Output: j3.id
         ->  Subquery Scan on j3
               Output: j3.id
               ->  HashAggregate
                     Output: (((j3_1.fields ->> 'id'::text)))::integer, ((j3_1.fields ->> 'id'::text))
                     Group Key: (j3_1.fields ->> 'id'::text)
                     ->  Foreign Scan on public.j3 j3_1
                           Output: (j3_1.fields ->> 'id'::text), j3_1.fields
                           InfluxDB query: SELECT * FROM "j3"
(16 rows)

--Testcase 525:
delete from j1_nsc;
--Testcase 526:
delete from j2_nsc;
--Testcase 527:
delete from j3_nsc;
--Testcase 528:
drop foreign table j1;
--Testcase 638:
drop foreign table j1_nsc;
--Testcase 529:
drop foreign table j2;
--Testcase 639:
drop foreign table j2_nsc;
--Testcase 530:
drop foreign table j3;
--Testcase 640:
drop foreign table j3_nsc;
-- test more complex permutations of unique joins
--Testcase 531:
create foreign table j1 (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 641:
create foreign table j1_nsc (id1 int, id2 int) server influxdb_svr OPTIONS (table 'j1');
--Testcase 532:
create foreign table j2 (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 642:
create foreign table j2_nsc (id1 int, id2 int) server influxdb_svr OPTIONS (table 'j2');
--Testcase 533:
create foreign table j3 (fields jsonb OPTIONS (fields 'true')) server influxdb_svr OPTIONS(schemaless 'true');
--Testcase 643:
create foreign table j3_nsc (id1 int, id2 int) server influxdb_svr OPTIONS (table 'j3');
--Testcase 534:
insert into j1_nsc values(1,1),(1,2);
--Testcase 535:
insert into j2_nsc values(1,1);
--Testcase 536:
insert into j3_nsc values(1,1);
-- ensure there's no unique join when not all columns which are part of the
-- unique index are seen in the join clause
--Testcase 537:
explain (verbose, costs off)
select * from (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j1) j1
inner join (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j2) j2 on (j1.id1)::int = (j2.id1)::int;
                                                                                  QUERY PLAN                                                                                  
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: (((j1.fields ->> 'id1'::text))::integer), ((j1.fields ->> 'id2'::text))::integer, (((j2.fields ->> 'id1'::text))::integer), ((j2.fields ->> 'id2'::text))::integer
   Merge Cond: ((((j1.fields ->> 'id1'::text))::integer) = (((j2.fields ->> 'id1'::text))::integer))
   ->  Sort
         Output: j1.fields, (((j1.fields ->> 'id1'::text))::integer)
         Sort Key: (((j1.fields ->> 'id1'::text))::integer)
         ->  Foreign Scan on public.j1
               Output: j1.fields, ((j1.fields ->> 'id1'::text))::integer
               InfluxDB query: SELECT * FROM "j1"
   ->  Sort
         Output: j2.fields, (((j2.fields ->> 'id1'::text))::integer)
         Sort Key: (((j2.fields ->> 'id1'::text))::integer)
         ->  Foreign Scan on public.j2
               Output: j2.fields, ((j2.fields ->> 'id1'::text))::integer
               InfluxDB query: SELECT * FROM "j2"
(15 rows)

-- ensure proper unique detection with multiple join quals
--Testcase 538:
explain (verbose, costs off)
select * from (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j1) j1
inner join (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j2) j2 on (j1.id1)::int = (j2.id1)::int and (j1.id2)::int = (j2.id2)::int;
                                                                                           QUERY PLAN                                                                                            
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: (((j1.fields ->> 'id1'::text))::integer), (((j1.fields ->> 'id2'::text))::integer), (((j2.fields ->> 'id1'::text))::integer), (((j2.fields ->> 'id2'::text))::integer)
   Merge Cond: (((((j1.fields ->> 'id1'::text))::integer) = (((j2.fields ->> 'id1'::text))::integer)) AND ((((j1.fields ->> 'id2'::text))::integer) = (((j2.fields ->> 'id2'::text))::integer)))
   ->  Sort
         Output: j1.fields, (((j1.fields ->> 'id1'::text))::integer), (((j1.fields ->> 'id2'::text))::integer)
         Sort Key: (((j1.fields ->> 'id1'::text))::integer), (((j1.fields ->> 'id2'::text))::integer)
         ->  Foreign Scan on public.j1
               Output: j1.fields, ((j1.fields ->> 'id1'::text))::integer, ((j1.fields ->> 'id2'::text))::integer
               InfluxDB query: SELECT * FROM "j1"
   ->  Sort
         Output: j2.fields, (((j2.fields ->> 'id1'::text))::integer), (((j2.fields ->> 'id2'::text))::integer)
         Sort Key: (((j2.fields ->> 'id1'::text))::integer), (((j2.fields ->> 'id2'::text))::integer)
         ->  Foreign Scan on public.j2
               Output: j2.fields, ((j2.fields ->> 'id1'::text))::integer, ((j2.fields ->> 'id2'::text))::integer
               InfluxDB query: SELECT * FROM "j2"
(15 rows)

-- ensure we don't detect the join to be unique when quals are not part of the
-- join condition
--Testcase 539:
explain (verbose, costs off)
select * from (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j1) j1
inner join (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j2) j2 on (j1.id1)::int = (j2.id1)::int where (j1.id2)::int = 1;
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join
   Output: ((j1.fields ->> 'id1'::text))::integer, ((j1.fields ->> 'id2'::text))::integer, ((j2.fields ->> 'id1'::text))::integer, ((j2.fields ->> 'id2'::text))::integer
   Hash Cond: (((j2.fields ->> 'id1'::text))::integer = ((j1.fields ->> 'id1'::text))::integer)
   ->  Foreign Scan on public.j2
         Output: j2.fields
         InfluxDB query: SELECT * FROM "j2"
   ->  Hash
         Output: j1.fields
         ->  Foreign Scan on public.j1
               Output: j1.fields
               InfluxDB query: SELECT * FROM "j1" WHERE (("id2" = 1))
(11 rows)

-- as above, but for left joins.
--Testcase 540:
explain (verbose, costs off)
select * from (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j1) j1
left join (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j2) j2 on (j1.id1)::int = (j2.id1)::int where (j1.id2)::int = 1;
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join
   Output: ((j1.fields ->> 'id1'::text))::integer, ((j1.fields ->> 'id2'::text))::integer, ((j2.fields ->> 'id1'::text))::integer, ((j2.fields ->> 'id2'::text))::integer
   Hash Cond: (((j2.fields ->> 'id1'::text))::integer = ((j1.fields ->> 'id1'::text))::integer)
   ->  Foreign Scan on public.j2
         Output: j2.fields
         InfluxDB query: SELECT * FROM "j2"
   ->  Hash
         Output: j1.fields
         ->  Foreign Scan on public.j1
               Output: j1.fields
               InfluxDB query: SELECT * FROM "j1" WHERE (("id2" = 1))
(11 rows)

-- validate logic in merge joins which skips mark and restore.
-- it should only do this if all quals which were used to detect the unique
-- are present as join quals, and not plain quals.
--Testcase 541:
set enable_nestloop to 0;
--Testcase 542:
set enable_hashjoin to 0;
--Testcase 543:
set enable_sort to 0;
-- create indexes that will be preferred over the PKs to perform the join
--create index j1_id1_idx on j1 (id1) where id1 % 1000 = 1;
--create index j2_id1_idx on j2 (id1) where id1 % 1000 = 1;
-- need an additional row in j2, if we want j2_id1_idx to be preferred
--Testcase 544:
insert into j2_nsc values(1,2);
--analyze j2;
--Testcase 545:
explain (costs off) select * from (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j1) j1
inner join (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j2) j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where (j1.id1)::int % 1000 = 1 and (j2.id1)::int % 1000 = 1;
                                                                                        QUERY PLAN                                                                                        
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Join Filter: ((((j1.fields ->> 'id1'::text))::integer = ((j2.fields ->> 'id1'::text))::integer) AND (((j1.fields ->> 'id2'::text))::integer = ((j2.fields ->> 'id2'::text))::integer))
   ->  Foreign Scan on j1
   ->  Materialize
         ->  Foreign Scan on j2
(5 rows)

--Testcase 546:
select * from (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j1) j1
inner join (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j2) j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where (j1.id1)::int % 1000 = 1 and (j2.id1)::int % 1000 = 1;
 id1 | id2 | id1 | id2 
-----+-----+-----+-----
   1 |   1 |   1 |   1
   1 |   2 |   1 |   2
(2 rows)

-- Exercise array keys mark/restore B-Tree code
--Testcase 547:
explain (costs off) select * from (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j1) j1
inner join (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j2) j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where (j1.id1)::int % 1000 = 1 and (j2.id1)::int % 1000 = 1 and (j2.id1)::int = any (array[1]);
                                                                                        QUERY PLAN                                                                                        
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Join Filter: ((((j1.fields ->> 'id1'::text))::integer = ((j2.fields ->> 'id1'::text))::integer) AND (((j1.fields ->> 'id2'::text))::integer = ((j2.fields ->> 'id2'::text))::integer))
   ->  Foreign Scan on j1
   ->  Materialize
         ->  Foreign Scan on j2
(5 rows)

--Testcase 548:
select * from (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j1) j1
inner join (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j2) j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where (j1.id1)::int % 1000 = 1 and (j2.id1)::int % 1000 = 1 and (j2.id1)::int = any (array[1]);
 id1 | id2 | id1 | id2 
-----+-----+-----+-----
   1 |   1 |   1 |   1
   1 |   2 |   1 |   2
(2 rows)

-- Exercise array keys "find extreme element" B-Tree code
--Testcase 549:
explain (costs off) select * from (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j1) j1
inner join (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j2) j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where (j1.id1)::int % 1000 = 1 and (j2.id1)::int % 1000 = 1 and (j2.id1)::int >= any (array[1,5]);
                                                                                        QUERY PLAN                                                                                        
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Join Filter: ((((j1.fields ->> 'id1'::text))::integer = ((j2.fields ->> 'id1'::text))::integer) AND (((j1.fields ->> 'id2'::text))::integer = ((j2.fields ->> 'id2'::text))::integer))
   ->  Foreign Scan on j1
   ->  Materialize
         ->  Foreign Scan on j2
(5 rows)

--Testcase 550:
select * from (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j1) j1
inner join (select (fields->>'id1')::int id1, (fields->>'id2')::int id2 from j2) j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where (j1.id1)::int % 1000 = 1 and (j2.id1)::int % 1000 = 1 and (j2.id1)::int >= any (array[1,5]);
 id1 | id2 | id1 | id2 
-----+-----+-----+-----
   1 |   1 |   1 |   1
   1 |   2 |   1 |   2
(2 rows)

--Testcase 551:
reset enable_nestloop;
--Testcase 552:
reset enable_hashjoin;
--Testcase 553:
reset enable_sort;
--Testcase 554:
delete from j1_nsc;
--Testcase 555:
delete from j2_nsc;
--Testcase 556:
delete from j3_nsc;
--Testcase 557:
drop foreign table j1;
--Testcase 644:
drop foreign table j1_nsc;
--Testcase 558:
drop foreign table j2;
--Testcase 645:
drop foreign table j2_nsc;
--Testcase 559:
drop foreign table j3;
--Testcase 646:
drop foreign table j3_nsc;
-- check that semijoin inner is not seen as unique for a portion of the outerrel
--Testcase 560:
CREATE FOREIGN TABLE onek (
  fields jsonb OPTIONS (fields 'true')
) SERVER influxdb_svr OPTIONS(schemaless 'true');
-- check that semijoin inner is not seen as unique for a portion of the outerrel
--Testcase 561:
explain (verbose, costs off)
select (t1.fields->>'unique1')::int4 unique1, (t2.fields->>'hundred')::int4 hundred
from onek t1, tenk1 t2
where exists (select 1 from tenk1 t3
              where (t3.fields->>'thousand')::int4 = (t1.fields->>'unique1')::int4 and (t3.fields->>'tenthous')::int4 = (t2.fields->>'hundred')::int4)
      and (t1.fields->>'unique1')::int4 < 1;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join
   Output: (((t1.fields ->> 'unique1'::text))::integer), ((t2.fields ->> 'hundred'::text))::integer
   Merge Cond: ((((t1.fields ->> 'unique1'::text))::integer) = (((t3.fields ->> 'thousand'::text))::integer))
   ->  Sort
         Output: t1.fields, (((t1.fields ->> 'unique1'::text))::integer)
         Sort Key: (((t1.fields ->> 'unique1'::text))::integer)
         ->  Foreign Scan on public.onek t1
               Output: t1.fields, ((t1.fields ->> 'unique1'::text))::integer
               InfluxDB query: SELECT * FROM "onek" WHERE (("unique1" < 1))
   ->  Sort
         Output: t2.fields, t3.fields, (((t3.fields ->> 'thousand'::text))::integer)
         Sort Key: (((t3.fields ->> 'thousand'::text))::integer)
         ->  Hash Join
               Output: t2.fields, t3.fields, ((t3.fields ->> 'thousand'::text))::integer
               Hash Cond: (((t2.fields ->> 'hundred'::text))::integer = ((t3.fields ->> 'tenthous'::text))::integer)
               ->  Foreign Scan on public.tenk1 t2
                     Output: t2.fields
                     InfluxDB query: SELECT * FROM "tenk"
               ->  Hash
                     Output: t3.fields
                     ->  HashAggregate
                           Output: t3.fields
                           Group Key: ((t3.fields ->> 'thousand'::text))::integer, ((t3.fields ->> 'tenthous'::text))::integer
                           ->  Foreign Scan on public.tenk1 t3
                                 Output: t3.fields, ((t3.fields ->> 'thousand'::text))::integer, ((t3.fields ->> 'tenthous'::text))::integer
                                 InfluxDB query: SELECT * FROM "tenk"
(26 rows)

-- ... unless it actually is unique
--Testcase 562:
create table j3 as select (fields->>'unique1')::int4 unique1, (fields->>'tenthous')::int4 tenthous from onek;
vacuum analyze j3;
--Testcase 563:
create unique index on j3(unique1, tenthous);
--Testcase 564:
explain (verbose, costs off)
select (t1.fields->>'unique1')::int4 unique1, (t2.fields->>'hundred')::int4 hundred
from onek t1, tenk1 t2
where exists (select 1 from j3
              where j3.unique1 = (t1.fields->>'unique1')::int4 and j3.tenthous = (t2.fields->>'hundred')::int4)
      and (t1.fields->>'unique1')::int4 < 1;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Hash Join
   Output: ((t1.fields ->> 'unique1'::text))::integer, ((t2.fields ->> 'hundred'::text))::integer
   Hash Cond: (((t2.fields ->> 'hundred'::text))::integer = j3.tenthous)
   ->  Foreign Scan on public.tenk1 t2
         Output: t2.fields
         InfluxDB query: SELECT * FROM "tenk"
   ->  Hash
         Output: t1.fields, j3.tenthous
         ->  Hash Join
               Output: t1.fields, j3.tenthous
               Hash Cond: (((t1.fields ->> 'unique1'::text))::integer = j3.unique1)
               ->  Foreign Scan on public.onek t1
                     Output: t1.fields
                     InfluxDB query: SELECT * FROM "onek" WHERE (("unique1" < 1))
               ->  Hash
                     Output: j3.unique1, j3.tenthous
                     ->  Seq Scan on public.j3
                           Output: j3.unique1, j3.tenthous
(18 rows)

--Testcase 565:
drop table j3;
-- Clean up
--Testcase 647:
DELETE FROM t1_nsc;
--Testcase 648:
DELETE FROM t2_nsc;
--Testcase 649:
DELETE FROM t3_nsc;
--Testcase 650:
DELETE FROM tt1_nsc;
--Testcase 651:
DELETE FROM tt2_nsc;
--Testcase 652:
DELETE FROM tt3_nsc;
--Testcase 653:
DELETE FROM tt4_nsc;
--Testcase 654:
DELETE FROM tt5_nsc;
--Testcase 655:
DELETE FROM tt6_nsc;
--Testcase 656:
DELETE FROM xx_nsc;
--Testcase 657:
DELETE FROM yy_nsc;
--Testcase 658:
DELETE FROM zt1_nsc;
--Testcase 659:
DELETE FROM zt2_nsc;
--Testcase 660:
DELETE FROM nt1_nsc;
--Testcase 661:
DELETE FROM nt2_nsc;
--Testcase 662:
DELETE FROM nt3_nsc;
--Testcase 663:
DELETE FROM parent_nsc;
--Testcase 664:
DELETE FROM child_nsc;
DO $d$
declare
  l_rec record;
begin
  for l_rec in (select foreign_table_schema, foreign_table_name 
                from information_schema.foreign_tables) loop
     execute format('drop foreign table %I.%I cascade;', l_rec.foreign_table_schema, l_rec.foreign_table_name);
  end loop;
end;
$d$;
NOTICE:  drop cascades to table t2a
NOTICE:  drop cascades to view zv1
--Testcase 566:
DROP USER MAPPING FOR CURRENT_USER SERVER influxdb_svr;
--Testcase 567:
DROP SERVER influxdb_svr CASCADE;
--Testcase 568:
DROP EXTENSION influxdb_fdw;
