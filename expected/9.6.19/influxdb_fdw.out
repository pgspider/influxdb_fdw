--SET log_min_messages=debug1;
--SET client_min_messages=debug1;
SET datestyle=ISO;
-- timestamp with time zone differs based on this
SET timezone='Japan';
\set ECHO none
--Testcase 1:
CREATE EXTENSION influxdb_fdw;
--Testcase 2:
CREATE SERVER server1 FOREIGN DATA WRAPPER influxdb_fdw OPTIONS
(dbname 'mydb', host :INFLUXDB_HOST, port :INFLUXDB_PORT);
--Testcase 3:
CREATE USER MAPPING FOR CURRENT_USER SERVER server1 OPTIONS (user :INFLUXDB_USER, password :INFLUXDB_PASS);
-- import time column as timestamp and text type
IMPORT FOREIGN SCHEMA public FROM SERVER server1 INTO public OPTIONS(import_time_text 'true');
--Testcase 4:
SELECT * FROM cpu;
          time          |      time_text       |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+----------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | 2015-08-18T00:00:00Z | tag1_A | tag2_A |    100 |    0.5 | str    | t
 2015-08-18 09:00:00+09 | 2015-08-18T00:00:00Z | tag1_B |        |    100 |      2 |        | f
 2015-08-18 09:48:08+09 | 2015-08-18T00:48:08Z |        | tag2_A |        |      2 |        | 
(3 rows)

--Testcase 5:
SELECT tag1, value1 FROM cpu;
  tag1  | value1 
--------+--------
 tag1_A |    100
 tag1_B |    100
(2 rows)

--Testcase 6:
SELECT value1, time, value2 FROM cpu;
 value1 |          time          | value2 
--------+------------------------+--------
    100 | 2015-08-18 09:00:00+09 |    0.5
    100 | 2015-08-18 09:00:00+09 |      2
        | 2015-08-18 09:48:08+09 |      2
(3 rows)

--Testcase 7:
SELECT value1, time_text, value2 FROM cpu;
 value1 |      time_text       | value2 
--------+----------------------+--------
    100 | 2015-08-18T00:00:00Z |    0.5
    100 | 2015-08-18T00:00:00Z |      2
        | 2015-08-18T00:48:08Z |      2
(3 rows)

--Testcase 8:
DROP FOREIGN TABLE cpu;
--Testcase 9:
DROP FOREIGN TABLE t3;
--Testcase 10:
DROP FOREIGN TABLE t4;
--Testcase 11:
DROP FOREIGN TABLE numbers;
-- test EXECPT
IMPORT FOREIGN SCHEMA public EXCEPT (cpu, t3, t4, numbers) FROM SERVER server1 INTO public;
--Testcase 12:
SELECT ftoptions FROM pg_foreign_table;
 ftoptions 
-----------
(0 rows)

-- test LIMIT TO
IMPORT FOREIGN SCHEMA public LIMIT TO (cpu) FROM SERVER server1 INTO public;
--Testcase 13:
SELECT ftoptions FROM pg_foreign_table;
          ftoptions           
------------------------------
 {table=cpu,"tags=tag1,tag2"}
(1 row)

--Testcase 14:
DROP FOREIGN TABLE cpu;
IMPORT FOREIGN SCHEMA public FROM SERVER server1 INTO public OPTIONS(import_time_text 'false');
--Testcase 15:
SELECT * FROM cpu;
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
 2015-08-18 09:00:00+09 | tag1_B |        |    100 |      2 |        | f
 2015-08-18 09:48:08+09 |        | tag2_A |        |      2 |        | 
(3 rows)

--Testcase 16:
SELECT tag1, value1 FROM cpu;
  tag1  | value1 
--------+--------
 tag1_A |    100
 tag1_B |    100
(2 rows)

--Testcase 17:
SELECT value1, time, value2 FROM cpu;
 value1 |          time          | value2 
--------+------------------------+--------
    100 | 2015-08-18 09:00:00+09 |    0.5
    100 | 2015-08-18 09:00:00+09 |      2
        | 2015-08-18 09:48:08+09 |      2
(3 rows)

--Testcase 18:
SELECT tag1 FROM cpu;
  tag1  
--------
 tag1_A
 tag1_B
(2 rows)

--Testcase 19:
SELECT * FROM numbers;
          time          | tag1 | a |  b  
------------------------+------+---+-----
 1970-01-01 09:00:00+09 | a    | 1 | One
 1970-01-01 09:00:01+09 | a    | 2 | Two
(2 rows)

--Testcase 20:
\d cpu;
                 Foreign table "public.cpu"
 Column |           Type           | Modifiers | FDW Options 
--------+--------------------------+-----------+-------------
 time   | timestamp with time zone |           | 
 tag1   | text                     |           | 
 tag2   | text                     |           | 
 value1 | bigint                   |           | 
 value2 | double precision         |           | 
 value3 | text                     |           | 
 value4 | boolean                  |           | 
Server: server1
FDW Options: ("table" 'cpu', tags 'tag1,tag2')

--Testcase 21:
SELECT * FROM cpu WHERE value1=100;
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
 2015-08-18 09:00:00+09 | tag1_B |        |    100 |      2 |        | f
(2 rows)

--Testcase 22:
SELECT * FROM cpu WHERE value2=0.5;
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
(1 row)

--Testcase 23:
SELECT * FROM cpu WHERE value3='str';
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
(1 row)

--Testcase 24:
SELECT * FROM cpu WHERE value4=true;
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
(1 row)

--Testcase 25:
SELECT * FROM cpu WHERE NOT (value4 AND value1=100);
          time          |  tag1  | tag2 | value1 | value2 | value3 | value4 
------------------------+--------+------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_B |      |    100 |      2 |        | f
(1 row)

--Testcase 26:
SELECT * FROM cpu WHERE tag1='tag1_A';
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
(1 row)

--Testcase 27:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT * FROM cpu WHERE value3 IS NULL;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan on public.cpu
   Output: "time", tag1, tag2, value1, value2, value3, value4
   Filter: (cpu.value3 IS NULL)
   InfluxDB query: SELECT "tag1", "tag2", "value1", "value2", "value3", "value4" FROM "cpu"
(4 rows)

--Testcase 28:
SELECT * FROM cpu WHERE value3 IS NULL;
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_B |        |    100 |      2 |        | f
 2015-08-18 09:48:08+09 |        | tag2_A |        |      2 |        | 
(2 rows)

--Testcase 29:
SELECT * FROM cpu WHERE tag2 IS NULL;
          time          |  tag1  | tag2 | value1 | value2 | value3 | value4 
------------------------+--------+------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_B |      |    100 |      2 |        | f
(1 row)

--Testcase 30:
SELECT * FROM cpu WHERE value3 IS NOT NULL;
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
(1 row)

--Testcase 31:
SELECT * FROM cpu WHERE tag2 IS NOT NULL;
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
 2015-08-18 09:48:08+09 |        | tag2_A |        |      2 |        | 
(2 rows)

-- InfluxDB not support compare timestamp with OR condition
--Testcase 32:
SELECT * FROM cpu WHERE time = '2015-08-18 09:48:08+09' OR value2 = 0.5;
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
 2015-08-18 09:48:08+09 |        | tag2_A |        |      2 |        | 
(2 rows)

-- InfluxDB not support compare timestamp with != or <>
--Testcase 33:
SELECT * FROM cpu WHERE time != '2015-08-18 09:48:08+09';
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
 2015-08-18 09:00:00+09 | tag1_B |        |    100 |      2 |        | f
(2 rows)

--Testcase 34:
SELECT * FROM cpu WHERE time <> '2015-08-18 09:48:08+09';
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
 2015-08-18 09:00:00+09 | tag1_B |        |    100 |      2 |        | f
(2 rows)

--Testcase 35:
SELECT * FROM cpu WHERE time = '2015-08-18 09:48:08+09' OR value2 = 0.5;
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
 2015-08-18 09:48:08+09 |        | tag2_A |        |      2 |        | 
(2 rows)

-- There is inconsitency for search of missing values between tag and field
--Testcase 36:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT * FROM cpu WHERE value3 = '';
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.cpu
   Output: "time", tag1, tag2, value1, value2, value3, value4
   InfluxDB query: SELECT "tag1", "tag2", "value1", "value2", "value3", "value4" FROM "cpu" WHERE (("value3" = ''))
(3 rows)

--Testcase 37:
SELECT * FROM cpu WHERE value3 = '';
 time | tag1 | tag2 | value1 | value2 | value3 | value4 
------+------+------+--------+--------+--------+--------
(0 rows)

--Testcase 38:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT * FROM cpu WHERE tag2 = '';
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.cpu
   Output: "time", tag1, tag2, value1, value2, value3, value4
   InfluxDB query: SELECT "tag1", "tag2", "value1", "value2", "value3", "value4" FROM "cpu" WHERE (("tag2" = ''))
(3 rows)

--Testcase 39:
SELECT * FROM cpu WHERE tag2 = '';
          time          |  tag1  | tag2 | value1 | value2 | value3 | value4 
------------------------+--------+------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_B |      |    100 |      2 |        | f
(1 row)

--Testcase 40:
SELECT * FROM cpu WHERE tag1 IN ('tag1_A', 'tag1_B');
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
 2015-08-18 09:00:00+09 | tag1_B |        |    100 |      2 |        | f
(2 rows)

--Testcase 41:
EXPLAIN VERBOSE
SELECT * FROM cpu WHERE tag1 IN ('tag1_A', 'tag1_B');
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.cpu  (cost=10.00..6.00 rows=6 width=121)
   Output: "time", tag1, tag2, value1, value2, value3, value4
   InfluxDB query: SELECT "tag1", "tag2", "value1", "value2", "value3", "value4" FROM "cpu" WHERE ("tag1" = 'tag1_A' OR "tag1" = 'tag1_B')
(3 rows)

-- Rows which have no tag are considered to have empty string
--Testcase 42:
SELECT * FROM cpu WHERE tag1 NOT IN ('tag1_A', 'tag1_B');
          time          | tag1 |  tag2  | value1 | value2 | value3 | value4 
------------------------+------+--------+--------+--------+--------+--------
 2015-08-18 09:48:08+09 |      | tag2_A |        |      2 |        | 
(1 row)

--Testcase 43:
EXPLAIN VERBOSE
SELECT * FROM cpu WHERE tag1 NOT IN ('tag1_A', 'tag1_B');
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.cpu  (cost=10.00..558.00 rows=558 width=121)
   Output: "time", tag1, tag2, value1, value2, value3, value4
   InfluxDB query: SELECT "tag1", "tag2", "value1", "value2", "value3", "value4" FROM "cpu" WHERE ("tag1" <> 'tag1_A' AND "tag1" <> 'tag1_B')
(3 rows)

-- test IN/NOT IN
--Testcase 44:
SELECT * FROM cpu WHERE time IN ('2015-08-18 09:48:08+09','2016-08-28 07:44:00+07');
          time          | tag1 |  tag2  | value1 | value2 | value3 | value4 
------------------------+------+--------+--------+--------+--------+--------
 2015-08-18 09:48:08+09 |      | tag2_A |        |      2 |        | 
(1 row)

--Testcase 45:
SELECT * FROM cpu WHERE time NOT IN ('2015-08-18 09:48:08+09','2016-08-28 07:44:00+07');
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
 2015-08-18 09:00:00+09 | tag1_B |        |    100 |      2 |        | f
(2 rows)

--Testcase 46:
SELECT * FROM cpu WHERE value1 NOT IN (100, 97);
 time | tag1 | tag2 | value1 | value2 | value3 | value4 
------+------+------+--------+--------+--------+--------
(0 rows)

--Testcase 47:
SELECT * FROM cpu WHERE value1 IN (100, 97);
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
 2015-08-18 09:00:00+09 | tag1_B |        |    100 |      2 |        | f
(2 rows)

--Testcase 48:
SELECT * FROM cpu WHERE value2 IN (0.5, 10.9);
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
(1 row)

--Testcase 49:
SELECT * FROM cpu WHERE value2 NOT IN (2, 9.7);
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
(1 row)

--Testcase 50:
SELECT * FROM cpu WHERE value4 NOT IN ('true', 'true');
          time          |  tag1  | tag2 | value1 | value2 | value3 | value4 
------------------------+--------+------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_B |      |    100 |      2 |        | f
(1 row)

--Testcase 51:
SELECT * FROM cpu WHERE time IN ('2015-08-18 09:48:08+09','2016-08-28 07:44:00+07');
          time          | tag1 |  tag2  | value1 | value2 | value3 | value4 
------------------------+------+--------+--------+--------+--------+--------
 2015-08-18 09:48:08+09 |      | tag2_A |        |      2 |        | 
(1 row)

--Testcase 52:
SELECT * FROM cpu WHERE time NOT IN ('2015-08-18 09:48:08+09','2016-08-28 07:44:00+07');
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
 2015-08-18 09:00:00+09 | tag1_B |        |    100 |      2 |        | f
(2 rows)

--Testcase 53:
SELECT * FROM cpu WHERE value1 NOT IN (100, 97);
 time | tag1 | tag2 | value1 | value2 | value3 | value4 
------+------+------+--------+--------+--------+--------
(0 rows)

--Testcase 54:
SELECT * FROM cpu WHERE value1 IN (100, 97);
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
 2015-08-18 09:00:00+09 | tag1_B |        |    100 |      2 |        | f
(2 rows)

--Testcase 55:
SELECT * FROM cpu WHERE value2 IN (0.5, 10.9);
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
(1 row)

--Testcase 56:
SELECT * FROM cpu WHERE value2 NOT IN (2, 9.7);
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
(1 row)

--Testcase 57:
SELECT * FROM cpu WHERE value4 NOT IN ('true', 'true');
          time          |  tag1  | tag2 | value1 | value2 | value3 | value4 
------------------------+--------+------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_B |      |    100 |      2 |        | f
(1 row)

--Testcase 58:
SELECT * FROM cpu WHERE value4 IN ('f', 't');
          time          |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A | tag2_A |    100 |    0.5 | str    | t
 2015-08-18 09:00:00+09 | tag1_B |        |    100 |      2 |        | f
(2 rows)

--Testcase 59:
CREATE FOREIGN TABLE t1(time timestamp with time zone , tag1 text, value1 integer) SERVER server1 OPTIONS (table 'cpu');
--Testcase 60:
CREATE FOREIGN TABLE t2(time timestamp , tag1 text, value1 integer) SERVER server1 OPTIONS (table 'cpu');
--Testcase 61:
SELECT * FROM t1;
          time          |  tag1  | value1 
------------------------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A |    100
 2015-08-18 09:00:00+09 | tag1_B |    100
(2 rows)

--Testcase 62:
SELECT * FROM t2;
        time         |  tag1  | value1 
---------------------+--------+--------
 2015-08-18 00:00:00 | tag1_A |    100
 2015-08-18 00:00:00 | tag1_B |    100
(2 rows)

-- In following four queries, timestamp condition is added to InfluxQL as "time = '2015-08-18 00:00:00'"
--Testcase 63:
SELECT * FROM t1 WHERE time = TIMESTAMP WITH TIME ZONE '2015-08-18 09:00:00+09';
          time          |  tag1  | value1 
------------------------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A |    100
 2015-08-18 09:00:00+09 | tag1_B |    100
(2 rows)

--Testcase 64:
SELECT * FROM t1 WHERE time = TIMESTAMP '2015-08-18 00:00:00';
          time          |  tag1  | value1 
------------------------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A |    100
 2015-08-18 09:00:00+09 | tag1_B |    100
(2 rows)

--Testcase 65:
SELECT * FROM t2 WHERE time = TIMESTAMP WITH TIME ZONE '2015-08-18 09:00:00+09';
        time         |  tag1  | value1 
---------------------+--------+--------
 2015-08-18 00:00:00 | tag1_A |    100
 2015-08-18 00:00:00 | tag1_B |    100
(2 rows)

--Testcase 66:
SELECT * FROM t2 WHERE time = TIMESTAMP '2015-08-18 00:00:00';
        time         |  tag1  | value1 
---------------------+--------+--------
 2015-08-18 00:00:00 | tag1_A |    100
 2015-08-18 00:00:00 | tag1_B |    100
(2 rows)

-- pushdown now()
--Testcase 67:
SELECT * FROM t2 WHERE now() > time;
        time         |  tag1  | value1 
---------------------+--------+--------
 2015-08-18 00:00:00 | tag1_A |    100
 2015-08-18 00:00:00 | tag1_B |    100
(2 rows)

--Testcase 68:
EXPLAIN VERBOSE
SELECT * FROM t2 WHERE now() > time;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.t2  (cost=10.00..401.00 rows=401 width=44)
   Output: "time", tag1, value1
   InfluxDB query: SELECT "tag1", "value1" FROM "cpu" WHERE ((now() > time))
(3 rows)

--Testcase 69:
SELECT * FROM t2 WHERE time = TIMESTAMP WITH TIME ZONE '2015-08-26 05:43:21.1+00' - interval '1 week 1 day 5 hour 43 minute 21 second 100 millisecond';
        time         |  tag1  | value1 
---------------------+--------+--------
 2015-08-18 00:00:00 | tag1_A |    100
 2015-08-18 00:00:00 | tag1_B |    100
(2 rows)

--Testcase 70:
EXPLAIN VERBOSE
SELECT * FROM t2 WHERE time = TIMESTAMP WITH TIME ZONE '2015-08-26 05:43:21.1+00' - interval '1 week 1 day 5 hour 43 minute 21 second 100 millisecond';
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.t2  (cost=10.00..6.00 rows=6 width=44)
   Output: "time", tag1, value1
   InfluxDB query: SELECT "tag1", "value1" FROM "cpu" WHERE ((time = ('2015-08-26 05:43:21.1' - 8d5h43m21s100000u)))
(3 rows)

-- InfluxDB does not seem to support time column + interval, so below query returns empty result
-- SELECT * FROM t2 WHERE time + interval '1 week 1 day 5 hour 43 minute 21 second 100 millisecond' = TIMESTAMP WITH TIME ZONE '2015-08-26 05:43:21.1+00';
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT * FROM t2 WHERE time + interval '1 week 1 day 5 hour 43 minute 21 second 100 millisecond' = TIMESTAMP WITH TIME ZONE '2015-08-26 05:43:21.1+00';
-- InfluxDB does not support month or year interval, so not push down
--Testcase 71:
SELECT * FROM t2 WHERE time = TIMESTAMP '2015-09-18 00:00:00' - interval '1 months';
        time         |  tag1  | value1 
---------------------+--------+--------
 2015-08-18 00:00:00 | tag1_A |    100
 2015-08-18 00:00:00 | tag1_B |    100
(2 rows)

--Testcase 72:
EXPLAIN VERBOSE
SELECT * FROM t2 WHERE time = TIMESTAMP '2015-09-18 00:00:00' - interval '1 months';
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan on public.t2  (cost=10.00..6.00 rows=6 width=44)
   Output: "time", tag1, value1
   InfluxDB query: SELECT "tag1", "value1" FROM "cpu" WHERE ((time = '2015-08-18 00:00:00'))
(3 rows)

--Testcase 73:
SELECT * FROM t2 WHERE value1 = ANY (ARRAY(SELECT value1 FROM t1 WHERE value1 < 1000));
        time         |  tag1  | value1 
---------------------+--------+--------
 2015-08-18 00:00:00 | tag1_A |    100
 2015-08-18 00:00:00 | tag1_B |    100
(2 rows)

-- ANY with ARRAY expression
--Testcase 74:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a = ANY(ARRAY[1, a + 1]);
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..13.00 rows=13 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE (("a" = 1) OR ("a" = ("a" + 1)))
(3 rows)

--Testcase 75:
SELECT a, b FROM numbers WHERE a = ANY(ARRAY[1, a + 1]);
 a |  b  
---+-----
 1 | One
(1 row)

--Testcase 76:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a <> ANY(ARRAY[1, a + 1]);
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..1280.00 rows=1280 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE (("a" <> 1) OR ("a" <> ("a" + 1)))
(3 rows)

--Testcase 77:
SELECT a, b FROM numbers WHERE a <> ANY(ARRAY[1, a + 1]);
 a |  b  
---+-----
 1 | One
 2 | Two
(2 rows)

--Testcase 78:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a >= ANY(ARRAY[1, a + 1]);
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..711.00 rows=711 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE (("a" >= 1) OR ("a" >= ("a" + 1)))
(3 rows)

--Testcase 79:
SELECT a, b FROM numbers WHERE a >= ANY(ARRAY[1, a + 1]);
 a |  b  
---+-----
 1 | One
 2 | Two
(2 rows)

--Testcase 80:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a <= ANY(ARRAY[1, a + 1]);
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..711.00 rows=711 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE (("a" <= 1) OR ("a" <= ("a" + 1)))
(3 rows)

--Testcase 81:
SELECT a, b FROM numbers WHERE a <= ANY(ARRAY[1, a + 1]);
 a |  b  
---+-----
 1 | One
 2 | Two
(2 rows)

--Testcase 82:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a > ANY(ARRAY[1, a + 1]);
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..711.00 rows=711 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE (("a" > 1) OR ("a" > ("a" + 1)))
(3 rows)

--Testcase 83:
SELECT a, b FROM numbers WHERE a > ANY(ARRAY[1, a + 1]);
 a |  b  
---+-----
 2 | Two
(1 row)

--Testcase 84:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a < ANY(ARRAY[1, a + 1]);
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..711.00 rows=711 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE (("a" < 1) OR ("a" < ("a" + 1)))
(3 rows)

--Testcase 85:
SELECT a, b FROM numbers WHERE a < ANY(ARRAY[1, a + 1]);
 a |  b  
---+-----
 1 | One
 2 | Two
(2 rows)

-- ANY with ARRAY const
--Testcase 86:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a = ANY(ARRAY[1, 2]);
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..13.00 rows=13 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE ("a" = 1 OR "a" = 2)
(3 rows)

--Testcase 87:
SELECT a, b FROM numbers WHERE a = ANY(ARRAY[1, 2]);
 a |  b  
---+-----
 1 | One
 2 | Two
(2 rows)

--Testcase 88:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a <> ANY(ARRAY[1, 2]);
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..1280.00 rows=1280 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE ("a" <> 1 OR "a" <> 2)
(3 rows)

--Testcase 89:
SELECT a, b FROM numbers WHERE a <> ANY(ARRAY[1, 2]);
 a |  b  
---+-----
 1 | One
 2 | Two
(2 rows)

--Testcase 90:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a >= ANY(ARRAY[1, 2]);
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..711.00 rows=711 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE ("a" >= 1 OR "a" >= 2)
(3 rows)

--Testcase 91:
SELECT a, b FROM numbers WHERE a >= ANY(ARRAY[1, 2]);
 a |  b  
---+-----
 1 | One
 2 | Two
(2 rows)

--Testcase 92:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a <= ANY(ARRAY[1, 2]);
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..711.00 rows=711 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE ("a" <= 1 OR "a" <= 2)
(3 rows)

--Testcase 93:
SELECT a, b FROM numbers WHERE a <= ANY(ARRAY[1, 2]);
 a |  b  
---+-----
 1 | One
 2 | Two
(2 rows)

--Testcase 94:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a > ANY(ARRAY[1, 2]);
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..711.00 rows=711 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE ("a" > 1 OR "a" > 2)
(3 rows)

--Testcase 95:
SELECT a, b FROM numbers WHERE a > ANY(ARRAY[1, 2]);
 a |  b  
---+-----
 2 | Two
(1 row)

--Testcase 96:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a < ANY(ARRAY[1, 2]);
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..711.00 rows=711 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE ("a" < 1 OR "a" < 2)
(3 rows)

--Testcase 97:
SELECT a, b FROM numbers WHERE a < ANY(ARRAY[1, 2]);
 a |  b  
---+-----
 1 | One
(1 row)

--Testcase 98:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a = ANY('{1, 2, 3}');
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..19.00 rows=19 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE ("a" = 1 OR "a" = 2 OR "a" = 3)
(3 rows)

--Testcase 99:
SELECT a, b FROM numbers WHERE a = ANY('{1, 2, 3}');
 a |  b  
---+-----
 1 | One
 2 | Two
(2 rows)

--Testcase 100:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a <> ANY('{1, 2, 3}');
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..1280.00 rows=1280 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE ("a" <> 1 OR "a" <> 2 OR "a" <> 3)
(3 rows)

--Testcase 101:
SELECT a, b FROM numbers WHERE a <> ANY('{1, 2, 3}');
 a |  b  
---+-----
 1 | One
 2 | Two
(2 rows)

-- ALL with ARRAY expression
--Testcase 102:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a = ALL(ARRAY[1, a * 1]);
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..1.00 rows=1 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE (("a" = 1) AND ("a" = ("a" * 1)))
(3 rows)

--Testcase 103:
SELECT a, b FROM numbers WHERE a = ALL(ARRAY[1, a * 1]);
 a |  b  
---+-----
 1 | One
(1 row)

--Testcase 104:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a <> ALL(ARRAY[1, a + 1]);
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..1267.00 rows=1267 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE (("a" <> 1) AND ("a" <> ("a" + 1)))
(3 rows)

--Testcase 105:
SELECT a, b FROM numbers WHERE a <> ALL(ARRAY[1, a + 1]);
 a |  b  
---+-----
 2 | Two
(1 row)

--Testcase 106:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a >= ALL(ARRAY[1, a / 1]);
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..142.00 rows=142 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE (("a" >= 1) AND ("a" >= ("a" / 1)))
(3 rows)

--Testcase 107:
SELECT a, b FROM numbers WHERE a >= ALL(ARRAY[1, a / 1]);
 a |  b  
---+-----
 1 | One
 2 | Two
(2 rows)

--Testcase 108:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a <= ALL(ARRAY[1, a + 1]);
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..142.00 rows=142 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE (("a" <= 1) AND ("a" <= ("a" + 1)))
(3 rows)

--Testcase 109:
SELECT a, b FROM numbers WHERE a <= ALL(ARRAY[1, a + 1]);
 a |  b  
---+-----
 1 | One
(1 row)

--Testcase 110:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a > ALL(ARRAY[1, a - 1]);
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..142.00 rows=142 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE (("a" > 1) AND ("a" > ("a" - 1)))
(3 rows)

--Testcase 111:
SELECT a, b FROM numbers WHERE a > ALL(ARRAY[1, a - 1]);
 a |  b  
---+-----
 2 | Two
(1 row)

--Testcase 112:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a < ALL(ARRAY[2, a + 1]);
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..142.00 rows=142 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE (("a" < 2) AND ("a" < ("a" + 1)))
(3 rows)

--Testcase 113:
SELECT a, b FROM numbers WHERE a < ALL(ARRAY[2, a + 1]);
 a |  b  
---+-----
 1 | One
(1 row)

-- ALL with ARRAY const
--Testcase 114:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a = ALL(ARRAY[1, 1]);
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..1.00 rows=1 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE ("a" = 1 AND "a" = 1)
(3 rows)

--Testcase 115:
SELECT a, b FROM numbers WHERE a = ALL(ARRAY[1, 1]);
 a |  b  
---+-----
 1 | One
(1 row)

--Testcase 116:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a <> ALL(ARRAY[1, 3]);
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..1267.00 rows=1267 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE ("a" <> 1 AND "a" <> 3)
(3 rows)

--Testcase 117:
SELECT a, b FROM numbers WHERE a <> ALL(ARRAY[1, 3]);
 a |  b  
---+-----
 2 | Two
(1 row)

--Testcase 118:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a >= ALL(ARRAY[1, 2]);
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..142.00 rows=142 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE ("a" >= 1 AND "a" >= 2)
(3 rows)

--Testcase 119:
SELECT a, b FROM numbers WHERE a >= ALL(ARRAY[1, 2]);
 a |  b  
---+-----
 2 | Two
(1 row)

--Testcase 120:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a <= ALL(ARRAY[1, 2]);
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..142.00 rows=142 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE ("a" <= 1 AND "a" <= 2)
(3 rows)

--Testcase 121:
SELECT a, b FROM numbers WHERE a <= ALL(ARRAY[1, 2]);
 a |  b  
---+-----
 1 | One
(1 row)

--Testcase 122:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a > ALL(ARRAY[0, 1]);
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..142.00 rows=142 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE ("a" > 0 AND "a" > 1)
(3 rows)

--Testcase 123:
SELECT a, b FROM numbers WHERE a > ALL(ARRAY[0, 1]);
 a |  b  
---+-----
 2 | Two
(1 row)

--Testcase 124:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE a < ALL(ARRAY[2, 3]);
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..142.00 rows=142 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE ("a" < 2 AND "a" < 3)
(3 rows)

--Testcase 125:
SELECT a, b FROM numbers WHERE a < ALL(ARRAY[2, 3]);
 a |  b  
---+-----
 1 | One
(1 row)

-- ANY/ALL with TEXT ARRAY const
--Testcase 126:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE b = ANY(ARRAY['One', 'Two']);
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..13.00 rows=13 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE ("b" = 'One' OR "b" = 'Two')
(3 rows)

--Testcase 127:
SELECT a, b FROM numbers WHERE b = ANY(ARRAY['One', 'Two']);
 a |  b  
---+-----
 1 | One
 2 | Two
(2 rows)

--Testcase 128:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE b <> ALL(ARRAY['One', 'Four']);
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..1267.00 rows=1267 width=40)
   Output: a, b
   InfluxDB query: SELECT "a", "b" FROM "numbers" WHERE ("b" <> 'One' AND "b" <> 'Four')
(3 rows)

--Testcase 129:
SELECT a, b FROM numbers WHERE b <> ALL(ARRAY['One', 'Four']);
 a |  b  
---+-----
 2 | Two
(1 row)

--Testcase 130:
EXPLAIN VERBOSE
SELECT a, b FROM numbers WHERE b > ANY(ARRAY['One', 'Two']);
                               QUERY PLAN                               
------------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..711.00 rows=711 width=40)
   Output: a, b
   Filter: (numbers.b > ANY ('{One,Two}'::text[]))
   InfluxDB query: SELECT "a", "b" FROM "numbers"
(4 rows)

--Testcase 131:
SELECT a, b FROM numbers WHERE b > ANY(ARRAY['One', 'Two']);
 a |  b  
---+-----
 2 | Two
(1 row)

--Testcase 132:
EXPLAIN VERBOSE
SELECT * FROM numbers WHERE b > ALL(ARRAY['Four', 'Five']);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Foreign Scan on public.numbers  (cost=10.00..87.00 rows=87 width=80)
   Output: "time", tag1, a, b
   Filter: (numbers.b > ALL ('{Four,Five}'::text[]))
   InfluxDB query: SELECT "tag1", "a", "b" FROM "numbers"
(4 rows)

--Testcase 133:
SELECT a, b FROM numbers WHERE b > ALL(ARRAY['Four', 'Five']);
 a |  b  
---+-----
 1 | One
 2 | Two
(2 rows)

--Testcase 134:
DROP FOREIGN TABLE numbers;
ALTER SERVER server1 OPTIONS (SET dbname 'no such database');
--Testcase 135:
SELECT * FROM t1;
ERROR:  influxdb_fdw : database not found: no such database
ALTER SERVER server1 OPTIONS (SET dbname 'mydb');
--Testcase 136:
SELECT * FROM t1;
          time          |  tag1  | value1 
------------------------+--------+--------
 2015-08-18 09:00:00+09 | tag1_A |    100
 2015-08-18 09:00:00+09 | tag1_B |    100
(2 rows)

-- map time column to both timestamp and text
--Testcase 137:
CREATE FOREIGN TABLE t5(t timestamp OPTIONS (column_name 'time'), tag1 text OPTIONS (column_name 'time'), v1 integer OPTIONS (column_name 'value1')) SERVER server1 OPTIONS (table 'cpu');
--Testcase 138:
SELECT * FROM t5;
          t          |         tag1         | v1  
---------------------+----------------------+-----
 2015-08-18 00:00:00 | 2015-08-18T00:00:00Z | 100
 2015-08-18 00:00:00 | 2015-08-18T00:00:00Z | 100
(2 rows)

--Test pushdown LIMIT...OFFSET
--Testcase 139:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT tableoid::regclass, * FROM t1 LIMIT 1 OFFSET 0;
                         QUERY PLAN                         
------------------------------------------------------------
 Limit
   Output: ((tableoid)::regclass), "time", tag1, value1
   ->  Foreign Scan on public.t1
         Output: (tableoid)::regclass, "time", tag1, value1
         InfluxDB query: SELECT "tag1", "value1" FROM "cpu"
(5 rows)

--Testcase 140:
SELECT tableoid::regclass, * FROM t1 LIMIT 1 OFFSET 0;
 tableoid |          time          |  tag1  | value1 
----------+------------------------+--------+--------
 t1       | 2015-08-18 09:00:00+09 | tag1_A |    100
(1 row)

--Testcase 141:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT tableoid::regclass, * FROM t1 LIMIT 1 OFFSET 1;
                         QUERY PLAN                         
------------------------------------------------------------
 Limit
   Output: ((tableoid)::regclass), "time", tag1, value1
   ->  Foreign Scan on public.t1
         Output: (tableoid)::regclass, "time", tag1, value1
         InfluxDB query: SELECT "tag1", "value1" FROM "cpu"
(5 rows)

--Testcase 142:
SELECT tableoid::regclass, * FROM t1 LIMIT 1 OFFSET 1;
 tableoid |          time          |  tag1  | value1 
----------+------------------------+--------+--------
 t1       | 2015-08-18 09:00:00+09 | tag1_B |    100
(1 row)

--Testcase 143:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT ctid, * FROM t1 LIMIT 1 OFFSET 0;
                         QUERY PLAN                         
------------------------------------------------------------
 Limit
   Output: ctid, "time", tag1, value1
   ->  Foreign Scan on public.t1
         Output: ctid, "time", tag1, value1
         InfluxDB query: SELECT "tag1", "value1" FROM "cpu"
(5 rows)

--Testcase 144:
SELECT ctid, * FROM t1 LIMIT 1 OFFSET 0;
      ctid      |          time          |  tag1  | value1 
----------------+------------------------+--------+--------
 (4294967295,0) | 2015-08-18 09:00:00+09 | tag1_A |    100
(1 row)

--Testcase 145:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT ctid, * FROM t2 LIMIT 10 OFFSET 20;
                         QUERY PLAN                         
------------------------------------------------------------
 Limit
   Output: ctid, "time", tag1, value1
   ->  Foreign Scan on public.t2
         Output: ctid, "time", tag1, value1
         InfluxDB query: SELECT "tag1", "value1" FROM "cpu"
(5 rows)

--Testcase 146:
SELECT ctid, * FROM t2 LIMIT 10 OFFSET 20;
 ctid | time | tag1 | value1 
------+------+------+--------
(0 rows)

--Testcase 147:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT * FROM
  t1
  LEFT JOIN t2
  ON t2.value1 = 123,
  LATERAL (SELECT t2.value1, t1.tag1 FROM t1 LIMIT 1 OFFSET 0) AS ss
WHERE t1.value1 = ss.value1;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Nested Loop
   Output: t1."time", t1.tag1, t1.value1, t2."time", t2.tag1, t2.value1, (t2.value1), t1_1.tag1
   Join Filter: (t1.value1 = (t2.value1))
   ->  Nested Loop Left Join
         Output: t1."time", t1.tag1, t1.value1, t2."time", t2.tag1, t2.value1
         ->  Foreign Scan on public.t1
               Output: t1."time", t1.tag1, t1.value1
               InfluxDB query: SELECT "tag1", "value1" FROM "cpu"
         ->  Materialize
               Output: t2."time", t2.tag1, t2.value1
               ->  Foreign Scan on public.t2
                     Output: t2."time", t2.tag1, t2.value1
                     InfluxDB query: SELECT "tag1", "value1" FROM "cpu" WHERE (("value1" = 123))
   ->  Limit
         Output: (t2.value1), t1_1.tag1
         ->  Foreign Scan on public.t1 t1_1
               Output: t2.value1, t1_1.tag1
               InfluxDB query: SELECT "tag1" FROM "cpu"
(18 rows)

--Testcase 148:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT * FROM
  t1
  LEFT JOIN t2
  ON t2.value1 = 123,
  LATERAL (SELECT t2.value1, t1.tag1 FROM t1 LIMIT 1 OFFSET 0) AS ss1,
  LATERAL (SELECT ss1.* from t3 LIMIT 1 OFFSET 20) AS ss2
WHERE t1.value1 = ss2.value1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: t1."time", t1.tag1, t1.value1, t2."time", t2.tag1, t2.value1, (t2.value1), t1_1.tag1, ((t2.value1)), (t1_1.tag1)
   Join Filter: (t1.value1 = ((t2.value1)))
   ->  Nested Loop
         Output: t1."time", t1.tag1, t1.value1, t2."time", t2.tag1, t2.value1, (t2.value1), t1_1.tag1
         ->  Nested Loop Left Join
               Output: t1."time", t1.tag1, t1.value1, t2."time", t2.tag1, t2.value1
               ->  Foreign Scan on public.t1
                     Output: t1."time", t1.tag1, t1.value1
                     InfluxDB query: SELECT "tag1", "value1" FROM "cpu"
               ->  Materialize
                     Output: t2."time", t2.tag1, t2.value1
                     ->  Foreign Scan on public.t2
                           Output: t2."time", t2.tag1, t2.value1
                           InfluxDB query: SELECT "tag1", "value1" FROM "cpu" WHERE (("value1" = 123))
         ->  Limit
               Output: (t2.value1), t1_1.tag1
               ->  Foreign Scan on public.t1 t1_1
                     Output: t2.value1, t1_1.tag1
                     InfluxDB query: SELECT "tag1" FROM "cpu"
   ->  Limit
         Output: ((t2.value1)), (t1_1.tag1)
         ->  Foreign Scan on public.t3
               Output: (t2.value1), t1_1.tag1
               InfluxDB query: SELECT * FROM "t3"
(25 rows)

--Testcase 149:
DROP FOREIGN TABLE cpu;
--Testcase 150:
DROP FOREIGN TABLE t1;
--Testcase 151:
DROP FOREIGN TABLE t2;
--Testcase 152:
DROP FOREIGN TABLE t3;
--Testcase 153:
DROP FOREIGN TABLE t4;
--Testcase 154:
DROP FOREIGN TABLE t5;
-- test INSERT, DELETE
IMPORT FOREIGN SCHEMA public FROM SERVER server1 INTO public OPTIONS(import_time_text 'true');
--Testcase 155:
SELECT * FROM cpu;
          time          |      time_text       |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+----------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | 2015-08-18T00:00:00Z | tag1_A | tag2_A |    100 |    0.5 | str    | t
 2015-08-18 09:00:00+09 | 2015-08-18T00:00:00Z | tag1_B |        |    100 |      2 |        | f
 2015-08-18 09:48:08+09 | 2015-08-18T00:48:08Z |        | tag2_A |        |      2 |        | 
(3 rows)

--Testcase 156:
EXPLAIN VERBOSE
INSERT INTO cpu(time, tag1, tag2, value1, value2, value3, value4) VALUES('2021-01-01 00:00:01+09', 'tag1_K', 'tag2_H', 200, 5.5, 'test1', true);
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Insert on public.cpu  (cost=0.00..0.01 rows=1 width=153)
   ->  Result  (cost=0.00..0.01 rows=1 width=153)
         Output: '2021-01-01 00:00:01+09'::timestamp with time zone, NULL::text, 'tag1_K'::text, 'tag2_H'::text, '200'::bigint, '5.5'::double precision, 'test1'::text, true
(3 rows)

--Testcase 157:
INSERT INTO cpu(time, tag1, tag2, value1, value2, value3, value4) VALUES('2021-01-01 00:00:01+09', 'tag1_K', 'tag2_H', 200, 5.5, 'test', true);
--Testcase 158:
SELECT * FROM cpu;
          time          |      time_text       |  tag1  |  tag2  | value1 | value2 | value3 | value4 
------------------------+----------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | 2015-08-18T00:00:00Z | tag1_A | tag2_A |    100 |    0.5 | str    | t
 2015-08-18 09:00:00+09 | 2015-08-18T00:00:00Z | tag1_B |        |    100 |      2 |        | f
 2015-08-18 09:48:08+09 | 2015-08-18T00:48:08Z |        | tag2_A |        |      2 |        | 
 2021-01-01 00:00:01+09 | 2020-12-31T15:00:01Z | tag1_K | tag2_H |    200 |    5.5 | test   | t
(4 rows)

--Testcase 159:
EXPLAIN VERBOSE
INSERT INTO cpu(time, tag1, tag2, value1, value2, value3, value4) VALUES('2021-01-02 00:00:02+05', 'tag1_I', 'tag2_E', 300, 15.5, 'test2', false),
  ('2029-02-02 00:02:02+04', 'tag1_U', 'tag2_DZ', (SELECT 350), (SELECT i FROM (VALUES(6.9)) AS foo (i)), 'funny', true);
                                                                               QUERY PLAN                                                                               
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Insert on public.cpu  (cost=0.02..0.04 rows=2 width=153)
   InitPlan 1 (returns $0)
     ->  Result  (cost=0.00..0.01 rows=1 width=4)
           Output: 350
   InitPlan 2 (returns $1)
     ->  Result  (cost=0.00..0.01 rows=1 width=32)
           Output: 6.9
   ->  Values Scan on "*VALUES*"  (cost=0.00..0.03 rows=2 width=153)
         Output: "*VALUES*".column1, NULL::text, "*VALUES*".column2, "*VALUES*".column3, "*VALUES*".column4, "*VALUES*".column5, "*VALUES*".column6, "*VALUES*".column7
(9 rows)

--Testcase 160:
INSERT INTO cpu(time, tag1, tag2, value1, value2, value3, value4) VALUES('2021-01-02 00:00:02+05', 'tag1_I', 'tag2_E', 300, 15.5, 'test2', false),
  ('2029-02-02 00:02:02+04', 'tag1_U', 'tag2_DZ', (SELECT 350), (SELECT i FROM (VALUES(6.9)) AS foo (i)), 'funny', true);
--Testcase 161:
SELECT * FROM cpu;
          time          |      time_text       |  tag1  |  tag2   | value1 | value2 | value3 | value4 
------------------------+----------------------+--------+---------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | 2015-08-18T00:00:00Z | tag1_A | tag2_A  |    100 |    0.5 | str    | t
 2015-08-18 09:00:00+09 | 2015-08-18T00:00:00Z | tag1_B |         |    100 |      2 |        | f
 2015-08-18 09:48:08+09 | 2015-08-18T00:48:08Z |        | tag2_A  |        |      2 |        | 
 2021-01-01 00:00:01+09 | 2020-12-31T15:00:01Z | tag1_K | tag2_H  |    200 |    5.5 | test   | t
 2021-01-02 04:00:02+09 | 2021-01-01T19:00:02Z | tag1_I | tag2_E  |    300 |   15.5 | test2  | f
 2029-02-02 05:02:02+09 | 2029-02-01T20:02:02Z | tag1_U | tag2_DZ |    350 |    6.9 | funny  | t
(6 rows)

--Testcase 162:
INSERT INTO cpu(tag2, value1) VALUES('tag2_KH', 400);
--Testcase 163:
SELECT tag1, tag2, value1, value2, value3, value4 FROM cpu;
  tag1  |  tag2   | value1 | value2 | value3 | value4 
--------+---------+--------+--------+--------+--------
 tag1_A | tag2_A  |    100 |    0.5 | str    | t
 tag1_B |         |    100 |      2 |        | f
        | tag2_A  |        |      2 |        | 
 tag1_K | tag2_H  |    200 |    5.5 | test   | t
 tag1_I | tag2_E  |    300 |   15.5 | test2  | f
        | tag2_KH |    400 |        |        | 
 tag1_U | tag2_DZ |    350 |    6.9 | funny  | t
(7 rows)

--Testcase 164:
EXPLAIN VERBOSE
DELETE FROM cpu WHERE tag2 = 'tag2_KH';
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Delete on public.cpu  (cost=10.00..3.00 rows=3 width=104)
   ->  Foreign Delete on public.cpu  (cost=10.00..3.00 rows=3 width=104)
         InfluxDB query: DELETE FROM "cpu" WHERE (("tag2" = 'tag2_KH'))
(3 rows)

--Testcase 165:
DELETE FROM cpu WHERE tag2 = 'tag2_KH';
--Testcase 166:
SELECT tag1, tag2, value1, value2, value3, value4 FROM cpu;
  tag1  |  tag2   | value1 | value2 | value3 | value4 
--------+---------+--------+--------+--------+--------
 tag1_A | tag2_A  |    100 |    0.5 | str    | t
 tag1_B |         |    100 |      2 |        | f
        | tag2_A  |        |      2 |        | 
 tag1_K | tag2_H  |    200 |    5.5 | test   | t
 tag1_I | tag2_E  |    300 |   15.5 | test2  | f
 tag1_U | tag2_DZ |    350 |    6.9 | funny  | t
(6 rows)

--Testcase 167:
EXPLAIN VERBOSE
DELETE FROM cpu WHERE time = '2021-01-02 04:00:02+09';
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Delete on public.cpu  (cost=10.00..3.00 rows=3 width=104)
   ->  Foreign Delete on public.cpu  (cost=10.00..3.00 rows=3 width=104)
         InfluxDB query: DELETE FROM "cpu" WHERE ((time = '2021-01-01 19:00:02'))
(3 rows)

--Testcase 168:
DELETE FROM cpu WHERE time = '2021-01-02 04:00:02+09';
--Testcase 169:
SELECT * FROM cpu;
          time          |      time_text       |  tag1  |  tag2   | value1 | value2 | value3 | value4 
------------------------+----------------------+--------+---------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | 2015-08-18T00:00:00Z | tag1_A | tag2_A  |    100 |    0.5 | str    | t
 2015-08-18 09:00:00+09 | 2015-08-18T00:00:00Z | tag1_B |         |    100 |      2 |        | f
 2015-08-18 09:48:08+09 | 2015-08-18T00:48:08Z |        | tag2_A  |        |      2 |        | 
 2021-01-01 00:00:01+09 | 2020-12-31T15:00:01Z | tag1_K | tag2_H  |    200 |    5.5 | test   | t
 2029-02-02 05:02:02+09 | 2029-02-01T20:02:02Z | tag1_U | tag2_DZ |    350 |    6.9 | funny  | t
(5 rows)

--Testcase 170:
EXPLAIN VERBOSE
DELETE FROM cpu WHERE time < '2018-07-07' AND tag1 != 'tag1_B';
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Delete on public.cpu  (cost=10.00..212.00 rows=212 width=104)
   ->  Foreign Delete on public.cpu  (cost=10.00..212.00 rows=212 width=104)
         InfluxDB query: DELETE FROM "cpu" WHERE ((time < '2018-07-06 15:00:00')) AND (("tag1" <> 'tag1_B'))
(3 rows)

--Testcase 171:
DELETE FROM cpu WHERE time < '2018-07-07' AND tag1 != 'tag1_B';
--Testcase 172:
SELECT * FROM cpu;
          time          |      time_text       |  tag1  |  tag2   | value1 | value2 | value3 | value4 
------------------------+----------------------+--------+---------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | 2015-08-18T00:00:00Z | tag1_B |         |    100 |      2 |        | f
 2021-01-01 00:00:01+09 | 2020-12-31T15:00:01Z | tag1_K | tag2_H  |    200 |    5.5 | test   | t
 2029-02-02 05:02:02+09 | 2029-02-01T20:02:02Z | tag1_U | tag2_DZ |    350 |    6.9 | funny  | t
(3 rows)

-- Test INSERT, DELETE with time_text column
--Testcase 173:
INSERT INTO cpu(time_text, tag1, tag2, value1, value2, value3, value4) VALUES('2021-02-02T00:00:00Z', 'tag1_D', 'tag2_E', 600, 20.2, 'test3', true);
--Testcase 174:
SELECT * FROM cpu;
          time          |      time_text       |  tag1  |  tag2   | value1 | value2 | value3 | value4 
------------------------+----------------------+--------+---------+--------+--------+--------+--------
 2015-08-18 09:00:00+09 | 2015-08-18T00:00:00Z | tag1_B |         |    100 |      2 |        | f
 2021-01-01 00:00:01+09 | 2020-12-31T15:00:01Z | tag1_K | tag2_H  |    200 |    5.5 | test   | t
 2021-02-02 09:00:00+09 | 2021-02-02T00:00:00Z | tag1_D | tag2_E  |    600 |   20.2 | test3  | t
 2029-02-02 05:02:02+09 | 2029-02-01T20:02:02Z | tag1_U | tag2_DZ |    350 |    6.9 | funny  | t
(4 rows)

--Testcase 175:
INSERT INTO cpu(time_text, tag1, value2) VALUES('2021-02-02T00:00:00.123456789Z', 'tag1_P', 25.8);
--Testcase 176:
SELECT * FROM cpu;
             time              |           time_text            |  tag1  |  tag2   | value1 | value2 | value3 | value4 
-------------------------------+--------------------------------+--------+---------+--------+--------+--------+--------
 2015-08-18 09:00:00+09        | 2015-08-18T00:00:00Z           | tag1_B |         |    100 |      2 |        | f
 2021-01-01 00:00:01+09        | 2020-12-31T15:00:01Z           | tag1_K | tag2_H  |    200 |    5.5 | test   | t
 2021-02-02 09:00:00+09        | 2021-02-02T00:00:00Z           | tag1_D | tag2_E  |    600 |   20.2 | test3  | t
 2021-02-02 09:00:00.123457+09 | 2021-02-02T00:00:00.123456789Z | tag1_P |         |        |   25.8 |        | 
 2029-02-02 05:02:02+09        | 2029-02-01T20:02:02Z           | tag1_U | tag2_DZ |    350 |    6.9 | funny  | t
(5 rows)

--Testcase 177:
INSERT INTO cpu(time_text, tag1, value2) VALUES('2021-02-02 00:00:01', 'tag1_J', 37.1);
--Testcase 178:
SELECT * FROM cpu;
             time              |           time_text            |  tag1  |  tag2   | value1 | value2 | value3 | value4 
-------------------------------+--------------------------------+--------+---------+--------+--------+--------+--------
 2015-08-18 09:00:00+09        | 2015-08-18T00:00:00Z           | tag1_B |         |    100 |      2 |        | f
 2021-01-01 00:00:01+09        | 2020-12-31T15:00:01Z           | tag1_K | tag2_H  |    200 |    5.5 | test   | t
 2021-02-02 09:00:00+09        | 2021-02-02T00:00:00Z           | tag1_D | tag2_E  |    600 |   20.2 | test3  | t
 2021-02-02 09:00:00.123457+09 | 2021-02-02T00:00:00.123456789Z | tag1_P |         |        |   25.8 |        | 
 2021-02-02 09:00:01+09        | 2021-02-02T00:00:01Z           | tag1_J |         |        |   37.1 |        | 
 2029-02-02 05:02:02+09        | 2029-02-01T20:02:02Z           | tag1_U | tag2_DZ |    350 |    6.9 | funny  | t
(6 rows)

--Testcase 179:
INSERT INTO cpu(time, time_text, tag1, tag2, value1, value2, value3, value4) VALUES('2021-02-02 00:00:01+05', '2021-02-02T00:00:02.123456789Z', 'tag1_A', 'tag2_B', 200, 5.5, 'test', true);
WARNING:  Inserting value has both 'time_text' and 'time' columns specified. The 'time' will be ignored.
--Testcase 180:
SELECT * FROM cpu;
             time              |           time_text            |  tag1  |  tag2   | value1 | value2 | value3 | value4 
-------------------------------+--------------------------------+--------+---------+--------+--------+--------+--------
 2015-08-18 09:00:00+09        | 2015-08-18T00:00:00Z           | tag1_B |         |    100 |      2 |        | f
 2021-01-01 00:00:01+09        | 2020-12-31T15:00:01Z           | tag1_K | tag2_H  |    200 |    5.5 | test   | t
 2021-02-02 09:00:00+09        | 2021-02-02T00:00:00Z           | tag1_D | tag2_E  |    600 |   20.2 | test3  | t
 2021-02-02 09:00:00.123457+09 | 2021-02-02T00:00:00.123456789Z | tag1_P |         |        |   25.8 |        | 
 2021-02-02 09:00:01+09        | 2021-02-02T00:00:01Z           | tag1_J |         |        |   37.1 |        | 
 2021-02-02 09:00:02.123457+09 | 2021-02-02T00:00:02.123456789Z | tag1_A | tag2_B  |    200 |    5.5 | test   | t
 2029-02-02 05:02:02+09        | 2029-02-01T20:02:02Z           | tag1_U | tag2_DZ |    350 |    6.9 | funny  | t
(7 rows)

--Testcase 181:
INSERT INTO cpu(time_text, time, tag1, tag2, value1, value2, value3, value4) VALUES('2021-02-03T00:00:03.123456789Z', '2021-03-03 00:00:01+07', 'tag1_C', 'tag2_D', 200, 5.5, 'test', true);
WARNING:  Inserting value has both 'time_text' and 'time' columns specified. The 'time' will be ignored.
--Testcase 182:
SELECT * FROM cpu;
             time              |           time_text            |  tag1  |  tag2   | value1 | value2 | value3 | value4 
-------------------------------+--------------------------------+--------+---------+--------+--------+--------+--------
 2015-08-18 09:00:00+09        | 2015-08-18T00:00:00Z           | tag1_B |         |    100 |      2 |        | f
 2021-01-01 00:00:01+09        | 2020-12-31T15:00:01Z           | tag1_K | tag2_H  |    200 |    5.5 | test   | t
 2021-02-02 09:00:00+09        | 2021-02-02T00:00:00Z           | tag1_D | tag2_E  |    600 |   20.2 | test3  | t
 2021-02-02 09:00:00.123457+09 | 2021-02-02T00:00:00.123456789Z | tag1_P |         |        |   25.8 |        | 
 2021-02-02 09:00:01+09        | 2021-02-02T00:00:01Z           | tag1_J |         |        |   37.1 |        | 
 2021-02-02 09:00:02.123457+09 | 2021-02-02T00:00:02.123456789Z | tag1_A | tag2_B  |    200 |    5.5 | test   | t
 2021-02-03 09:00:03.123457+09 | 2021-02-03T00:00:03.123456789Z | tag1_C | tag2_D  |    200 |    5.5 | test   | t
 2029-02-02 05:02:02+09        | 2029-02-01T20:02:02Z           | tag1_U | tag2_DZ |    350 |    6.9 | funny  | t
(8 rows)

--Testcase 183:
EXPLAIN VERBOSE
DELETE FROM cpu WHERE time_text = '2021-02-02T00:00:00.123456789Z';
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Delete on public.cpu  (cost=10.00..3.00 rows=3 width=104)
   ->  Foreign Delete on public.cpu  (cost=10.00..3.00 rows=3 width=104)
         InfluxDB query: DELETE FROM "cpu" WHERE ((time = '2021-02-02T00:00:00.123456789Z'))
(3 rows)

--Testcase 184:
DELETE FROM cpu WHERE time_text = '2021-02-02T00:00:00.123456789Z';
--Testcase 185:
SELECT * FROM cpu;
             time              |           time_text            |  tag1  |  tag2   | value1 | value2 | value3 | value4 
-------------------------------+--------------------------------+--------+---------+--------+--------+--------+--------
 2015-08-18 09:00:00+09        | 2015-08-18T00:00:00Z           | tag1_B |         |    100 |      2 |        | f
 2021-01-01 00:00:01+09        | 2020-12-31T15:00:01Z           | tag1_K | tag2_H  |    200 |    5.5 | test   | t
 2021-02-02 09:00:00+09        | 2021-02-02T00:00:00Z           | tag1_D | tag2_E  |    600 |   20.2 | test3  | t
 2021-02-02 09:00:01+09        | 2021-02-02T00:00:01Z           | tag1_J |         |        |   37.1 |        | 
 2021-02-02 09:00:02.123457+09 | 2021-02-02T00:00:02.123456789Z | tag1_A | tag2_B  |    200 |    5.5 | test   | t
 2021-02-03 09:00:03.123457+09 | 2021-02-03T00:00:03.123456789Z | tag1_C | tag2_D  |    200 |    5.5 | test   | t
 2029-02-02 05:02:02+09        | 2029-02-01T20:02:02Z           | tag1_U | tag2_DZ |    350 |    6.9 | funny  | t
(7 rows)

--Testcase 186:
EXPLAIN VERBOSE
DELETE FROM cpu WHERE time_text = '2021-02-02T00:00:01Z' AND tag1 = 'tag1_J';
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Delete on public.cpu  (cost=10.00..1.00 rows=1 width=104)
   ->  Foreign Delete on public.cpu  (cost=10.00..1.00 rows=1 width=104)
         InfluxDB query: DELETE FROM "cpu" WHERE ((time = '2021-02-02T00:00:01Z')) AND (("tag1" = 'tag1_J'))
(3 rows)

--Testcase 187:
DELETE FROM cpu WHERE time_text = '2021-02-02T00:00:01Z' AND tag1 = 'tag1_J';
--Testcase 188:
SELECT * FROM cpu;
             time              |           time_text            |  tag1  |  tag2   | value1 | value2 | value3 | value4 
-------------------------------+--------------------------------+--------+---------+--------+--------+--------+--------
 2015-08-18 09:00:00+09        | 2015-08-18T00:00:00Z           | tag1_B |         |    100 |      2 |        | f
 2021-01-01 00:00:01+09        | 2020-12-31T15:00:01Z           | tag1_K | tag2_H  |    200 |    5.5 | test   | t
 2021-02-02 09:00:00+09        | 2021-02-02T00:00:00Z           | tag1_D | tag2_E  |    600 |   20.2 | test3  | t
 2021-02-02 09:00:02.123457+09 | 2021-02-02T00:00:02.123456789Z | tag1_A | tag2_B  |    200 |    5.5 | test   | t
 2021-02-03 09:00:03.123457+09 | 2021-02-03T00:00:03.123456789Z | tag1_C | tag2_D  |    200 |    5.5 | test   | t
 2029-02-02 05:02:02+09        | 2029-02-01T20:02:02Z           | tag1_U | tag2_DZ |    350 |    6.9 | funny  | t
(6 rows)

--Testcase 189:
EXPLAIN VERBOSE
DELETE FROM cpu WHERE time_text = '2021-02-02 00:00:00' OR time ='2029-02-02 05:02:02+09';
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Delete on public.cpu  (cost=10.00..6.00 rows=6 width=104)
   ->  Foreign Scan on public.cpu  (cost=10.00..6.00 rows=6 width=104)
         Output: "time", time_text, tag1, tag2
         Filter: ((cpu.time_text = '2021-02-02 00:00:00'::text) OR (cpu."time" = '2029-02-02 05:02:02+09'::timestamp with time zone))
         InfluxDB query: SELECT "tag1", "tag2", "value1" FROM "cpu"
(5 rows)

--Testcase 190:
DELETE FROM cpu WHERE time_text = '2021-02-02 00:00:00' OR time ='2029-02-02 05:02:02+09';
--Testcase 191:
SELECT * FROM cpu;
             time              |           time_text            |  tag1  |  tag2  | value1 | value2 | value3 | value4 
-------------------------------+--------------------------------+--------+--------+--------+--------+--------+--------
 2015-08-18 09:00:00+09        | 2015-08-18T00:00:00Z           | tag1_B |        |    100 |      2 |        | f
 2021-01-01 00:00:01+09        | 2020-12-31T15:00:01Z           | tag1_K | tag2_H |    200 |    5.5 | test   | t
 2021-02-02 09:00:00+09        | 2021-02-02T00:00:00Z           | tag1_D | tag2_E |    600 |   20.2 | test3  | t
 2021-02-02 09:00:02.123457+09 | 2021-02-02T00:00:02.123456789Z | tag1_A | tag2_B |    200 |    5.5 | test   | t
 2021-02-03 09:00:03.123457+09 | 2021-02-03T00:00:03.123456789Z | tag1_C | tag2_D |    200 |    5.5 | test   | t
(5 rows)

--Testcase 192:
DROP USER MAPPING FOR CURRENT_USER SERVER server1;
--Testcase 193:
DROP SERVER server1 CASCADE;
NOTICE:  drop cascades to 4 other objects
DETAIL:  drop cascades to foreign table cpu
drop cascades to foreign table numbers
drop cascades to foreign table t3
drop cascades to foreign table t4
--Testcase 194:
DROP EXTENSION influxdb_fdw CASCADE;
