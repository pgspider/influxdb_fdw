--Testcase 1:
SET datestyle=ISO;
--Testcase 2:
SET timezone='Japan';
\set ECHO none
--Testcase 3:
CREATE EXTENSION influxdb_fdw;
--Testcase 4:
CREATE SERVER server1 FOREIGN DATA WRAPPER influxdb_fdw OPTIONS
(dbname 'mydb2', :SERVER);
--Testcase 5:
CREATE USER MAPPING FOR CURRENT_USER SERVER server1 OPTIONS (:AUTHENTICATION);
--IMPORT FOREIGN SCHEMA public FROM SERVER server1 INTO public OPTIONS(import_time_text 'false');
--Testcase 6:
CREATE FOREIGN TABLE s3(time timestamp with time zone, tags jsonb OPTIONS (tags 'true'), fields jsonb OPTIONS (fields 'true')) SERVER server1 OPTIONS(table 's3', tags 'tag1', schemaless 'true');
-- s3 (value1 as float8, value2 as bigint)
--Testcase 7:
\d s3;
                              Foreign table "public.s3"
 Column |           Type           | Collation | Nullable | Default |   FDW options   
--------+--------------------------+-----------+----------+---------+-----------------
 time   | timestamp with time zone |           |          |         | 
 tags   | jsonb                    |           |          |         | (tags 'true')
 fields | jsonb                    |           |          |         | (fields 'true')
Server: server1
FDW options: ("table" 's3', tags 'tag1', schemaless 'true')

--Testcase 8:
SELECT * FROM s3;
          time          |     tags      |                                 fields                                 
------------------------+---------------+------------------------------------------------------------------------
 1970-01-01 09:00:00+09 | {"tag1": "a"} | {"value1": "0.1", "value2": "100", "value3": "-0.1", "value4": "-100"}
 1970-01-01 09:00:01+09 | {"tag1": "a"} | {"value1": "0.2", "value2": "100", "value3": "-0.2", "value4": "-100"}
 1970-01-01 09:00:02+09 | {"tag1": "a"} | {"value1": "0.3", "value2": "100", "value3": "-0.3", "value4": "-100"}
 1970-01-01 09:00:03+09 | {"tag1": "b"} | {"value1": "1.1", "value2": "200", "value3": "-1.1", "value4": "-200"}
 1970-01-01 09:00:04+09 | {"tag1": "b"} | {"value1": "2.2", "value2": "200", "value3": "-2.2", "value4": "-200"}
 1970-01-01 09:00:05+09 | {"tag1": "b"} | {"value1": "3.3", "value2": "200", "value3": "-3.3", "value4": "-200"}
(6 rows)

-- select float8() (not pushdown, remove float8, explain)
--Testcase 9:
EXPLAIN VERBOSE
SELECT float8(fields->>'value1'), float8(fields->>'value2'), float8(fields->>'value3'), float8(fields->>'value4') FROM s3;
                                                                                                  QUERY PLAN                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1505.86 rows=1462 width=32)
   Output: ((fields ->> 'value1'::text))::double precision, ((fields ->> 'value2'::text))::double precision, ((fields ->> 'value3'::text))::double precision, ((fields ->> 'value4'::text))::double precision
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

-- select float8() (not pushdown, remove float8, result)
--Testcase 10:
SELECT float8(fields->>'value1'), float8(fields->>'value2'), float8(fields->>'value3'), float8(fields->>'value4') FROM s3;
 float8 | float8 | float8 | float8 
--------+--------+--------+--------
    0.1 |    100 |   -0.1 |   -100
    0.2 |    100 |   -0.2 |   -100
    0.3 |    100 |   -0.3 |   -100
    1.1 |    200 |   -1.1 |   -200
    2.2 |    200 |   -2.2 |   -200
    3.3 |    200 |   -3.3 |   -200
(6 rows)

-- select sqrt (builtin function, explain)
--Testcase 11:
EXPLAIN VERBOSE
SELECT sqrt((fields->>'value1')::float), sqrt((fields->>'value2')::bigint) FROM s3;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1494.89 rows=1462 width=16)
   Output: sqrt(((fields ->> 'value1'::text))::double precision), sqrt((((fields ->> 'value2'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2" FROM "s3"
(3 rows)

-- select sqrt (builtin function, result)
--Testcase 12:
SELECT sqrt((fields->>'value1')::float), sqrt((fields->>'value2')::bigint) FROM s3;
        sqrt         |        sqrt        
---------------------+--------------------
 0.31622776601683794 |                 10
  0.4472135954999579 |                 10
  0.5477225575051661 |                 10
  1.0488088481701516 | 14.142135623730951
  1.4832396974191326 | 14.142135623730951
   1.816590212458495 | 14.142135623730951
(6 rows)

-- select sqrt (builtin function, not pushdown constraints, explain)
--Testcase 13:
EXPLAIN VERBOSE
SELECT sqrt((fields->>'value1')::float), sqrt((fields->>'value2')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1487.74 rows=1455 width=16)
   Output: sqrt(((fields ->> 'value1'::text))::double precision), sqrt((((fields ->> 'value2'::text))::bigint)::double precision)
   Filter: (to_hex(((s3.fields ->> 'value2'::text))::bigint) <> '64'::text)
   InfluxDB query: SELECT "value1", "value2" FROM "s3"
(4 rows)

-- select sqrt (builtin function, not pushdown constraints, result)
--Testcase 14:
SELECT sqrt((fields->>'value1')::float), sqrt((fields->>'value2')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
        sqrt        |        sqrt        
--------------------+--------------------
 1.0488088481701516 | 14.142135623730951
 1.4832396974191326 | 14.142135623730951
  1.816590212458495 | 14.142135623730951
(3 rows)

-- select sqrt (builtin function, pushdown constraints, explain)
--Testcase 15:
EXPLAIN VERBOSE
SELECT sqrt((fields->>'value1')::float), sqrt((fields->>'value2')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1487.74 rows=1455 width=16)
   Output: sqrt(((fields ->> 'value1'::text))::double precision), sqrt((((fields ->> 'value2'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2" FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select sqrt (builtin function, pushdown constraints, result)
--Testcase 16:
SELECT sqrt((fields->>'value1')::float), sqrt((fields->>'value2')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
        sqrt         | sqrt 
---------------------+------
 0.31622776601683794 |   10
  0.4472135954999579 |   10
  0.5477225575051661 |   10
(3 rows)

-- select sqrt(*) (stub agg function, explain)
--Testcase 17:
EXPLAIN VERBOSE
SELECT sqrt_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: sqrt_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select sqrt(*) (stub agg function, result)
--Testcase 18:
SELECT sqrt_all() from s3;
ERROR:  stub sqrt_all() is called
CONTEXT:  PL/pgSQL function sqrt_all() line 3 at RAISE
-- select sqrt(*) (stub agg function and group by tag only) (explain)
--Testcase 19:
EXPLAIN VERBOSE
SELECT sqrt_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (sqrt_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT sqrt(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select sqrt(*) (stub agg function and group by tag only) (result)
--Testcase 20:
SELECT sqrt_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 sqrt_all                                                                 
------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.31622776601683794\",\"value2\" : \"10\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.4472135954999579\",\"value2\" : \"10\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.5477225575051661\",\"value2\" : \"10\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.0488088481701516\",\"value2\" : \"14.142135623730951\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1.4832396974191326\",\"value2\" : \"14.142135623730951\",\"value3\" : null,\"value4\" : null }")
(5 rows)

-- select abs (builtin function, explain)
--Testcase 21:
EXPLAIN VERBOSE
SELECT abs((fields->>'value1')::float), abs((fields->>'value2')::bigint), abs((fields->>'value3')::float), abs((fields->>'value4')::bigint) FROM s3;
                                                                                                  QUERY PLAN                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.48 rows=1462 width=32)
   Output: abs(((fields ->> 'value1'::text))::double precision), abs(((fields ->> 'value2'::text))::bigint), abs(((fields ->> 'value3'::text))::double precision), abs(((fields ->> 'value4'::text))::bigint)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

-- ABS() returns negative values if integer (https://github.com/influxdata/influxdb/issues/10261)
-- select abs (builtin function, result)
--Testcase 22:
SELECT abs((fields->>'value1')::float), abs((fields->>'value2')::bigint), abs((fields->>'value3')::float), abs((fields->>'value4')::bigint) FROM s3;
 abs | abs | abs | abs 
-----+-----+-----+-----
 0.1 | 100 | 0.1 | 100
 0.2 | 100 | 0.2 | 100
 0.3 | 100 | 0.3 | 100
 1.1 | 200 | 1.1 | 200
 2.2 | 200 | 2.2 | 200
 3.3 | 200 | 3.3 | 200
(6 rows)

-- select abs (builtin function, not pushdown constraints, explain)
--Testcase 23:
EXPLAIN VERBOSE
SELECT abs((fields->>'value1')::float), abs((fields->>'value2')::bigint), abs((fields->>'value3')::float), abs((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
                                                                                                  QUERY PLAN                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1513.20 rows=1455 width=32)
   Output: abs(((fields ->> 'value1'::text))::double precision), abs(((fields ->> 'value2'::text))::bigint), abs(((fields ->> 'value3'::text))::double precision), abs(((fields ->> 'value4'::text))::bigint)
   Filter: (to_hex(((s3.fields ->> 'value2'::text))::bigint) <> '64'::text)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(4 rows)

-- select abs (builtin function, not pushdown constraints, result)
--Testcase 24:
SELECT abs((fields->>'value1')::float), abs((fields->>'value2')::bigint), abs((fields->>'value3')::float), abs((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
 abs | abs | abs | abs 
-----+-----+-----+-----
 1.1 | 200 | 1.1 | 200
 2.2 | 200 | 2.2 | 200
 3.3 | 200 | 3.3 | 200
(3 rows)

-- select abs (builtin function, pushdown constraints, explain)
--Testcase 25:
EXPLAIN VERBOSE
SELECT abs((fields->>'value1')::float), abs((fields->>'value2')::bigint), abs((fields->>'value3')::float), abs((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                                                                  QUERY PLAN                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1513.20 rows=1455 width=32)
   Output: abs(((fields ->> 'value1'::text))::double precision), abs(((fields ->> 'value2'::text))::bigint), abs(((fields ->> 'value3'::text))::double precision), abs(((fields ->> 'value4'::text))::bigint)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select abs (builtin function, pushdown constraints, result)
--Testcase 26:
SELECT abs((fields->>'value1')::float), abs((fields->>'value2')::bigint), abs((fields->>'value3')::float), abs((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
 abs | abs | abs | abs 
-----+-----+-----+-----
 0.1 | 100 | 0.1 | 100
 0.2 | 100 | 0.2 | 100
 0.3 | 100 | 0.3 | 100
(3 rows)

-- select log (builtin function, need to swap arguments, numeric cast, explain)
-- log_<base>(v) : postgresql (base, v), influxdb (v, base)
--Testcase 27:
EXPLAIN VERBOSE
SELECT log((fields->>'value1')::numeric, (fields->>'value2')::numeric) FROM s3 WHERE (fields->>'value1')::float != 1;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1480.46 rows=1455 width=32)
   Output: log(((fields ->> 'value1'::text))::numeric, ((fields ->> 'value2'::text))::numeric)
   InfluxDB query: SELECT "value1", "value2" FROM "s3" WHERE (("value1" <> 1))
(3 rows)

-- select log (builtin function, need to swap arguments, numeric cast, result)
--Testcase 28:
SELECT log((fields->>'value1')::numeric, (fields->>'value2')::numeric) FROM s3 WHERE (fields->>'value1')::float != 1;
         log         
---------------------
 -2.0000000000000000
 -2.8613531161467861
 -3.8249785787863969
  55.590256753535330
  6.7198527566540755
  4.4377398922117404
(6 rows)

-- select log (builtin function, need to swap arguments, float8, explain)
--Testcase 29:
EXPLAIN VERBOSE
SELECT log((fields->>'value1')::numeric, 0.1) FROM s3 WHERE (fields->>'value1')::float != 1;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1469.55 rows=1455 width=32)
   Output: log(((fields ->> 'value1'::text))::numeric, 0.1)
   InfluxDB query: SELECT "value1" FROM "s3" WHERE (("value1" <> 1))
(3 rows)

-- select log (builtin function, need to swap arguments, float8, result)
--Testcase 30:
SELECT log((fields->>'value1')::numeric, 0.1) FROM s3 WHERE (fields->>'value1')::float != 1;
         log         
---------------------
  1.0000000000000000
  1.4306765580733931
  1.9124892893931984
 -24.158857928096806
 -2.9203673004336506
 -1.9285884584617046
(6 rows)

-- select log (builtin function, need to swap arguments, bigint, explain)
--Testcase 31:
EXPLAIN VERBOSE
SELECT log((fields->>'value2')::numeric, 3::numeric) FROM s3 WHERE (fields->>'value1')::float != 1;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1469.55 rows=1455 width=32)
   Output: log(((fields ->> 'value2'::text))::numeric, '3'::numeric)
   InfluxDB query: SELECT "value2" FROM "s3" WHERE (("value1" <> 1))
(3 rows)

-- select log (builtin function, need to swap arguments, bigint, result)
--Testcase 32:
SELECT log((fields->>'value2')::numeric, 3::numeric) FROM s3 WHERE (fields->>'value1')::float != 1;
        log         
--------------------
 0.2385606273598312
 0.2385606273598312
 0.2385606273598312
 0.2073511669203535
 0.2073511669203535
 0.2073511669203535
(6 rows)

-- select log (builtin function, need to swap arguments, mix type, explain)
--Testcase 33:
EXPLAIN VERBOSE
SELECT log((fields->>'value1')::numeric, (fields->>'value2')::numeric) FROM s3 WHERE (fields->>'value1')::float != 1;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1480.46 rows=1455 width=32)
   Output: log(((fields ->> 'value1'::text))::numeric, ((fields ->> 'value2'::text))::numeric)
   InfluxDB query: SELECT "value1", "value2" FROM "s3" WHERE (("value1" <> 1))
(3 rows)

-- select log (builtin function, need to swap arguments, mix type, result)
--Testcase 34:
SELECT log((fields->>'value1')::numeric, (fields->>'value2')::numeric) FROM s3 WHERE (fields->>'value1')::float != 1;
         log         
---------------------
 -2.0000000000000000
 -2.8613531161467861
 -3.8249785787863969
  55.590256753535330
  6.7198527566540755
  4.4377398922117404
(6 rows)

-- select log(*) (stub agg function, explain)
--Testcase 35:
EXPLAIN VERBOSE
SELECT log_all(50) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: log_all('50'::double precision)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select log(*) (stub agg function, result)
--Testcase 36:
SELECT log_all(50) FROM s3;
ERROR:  stub log_all(float8) is called
CONTEXT:  PL/pgSQL function log_all(double precision) line 3 at RAISE
-- select log(*) (stub agg function, explain)
--Testcase 37:
EXPLAIN VERBOSE
SELECT log_all(70.5) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: log_all('70.5'::double precision)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select log(*) (stub agg function, result)
--Testcase 38:
SELECT log_all(70.5) FROM s3;
ERROR:  stub log_all(float8) is called
CONTEXT:  PL/pgSQL function log_all(double precision) line 3 at RAISE
-- select log(*) (stub agg function and group by tag only) (explain)
--Testcase 39:
EXPLAIN VERBOSE
SELECT log_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (log_all('50'::double precision)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT log(*, 50) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select log(*) (stub agg function and group by tag only) (result)
--Testcase 40:
SELECT log_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                  log_all                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"-0.5885919100677789\",\"value2\" : \"1.177183820135558\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"-0.41140808993222105\",\"value2\" : \"1.177183820135558\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"-0.3077621994183976\",\"value2\" : \"1.177183820135558\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"0.024363399620113902\",\"value2\" : \"1.3543676402711158\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"0.20154721975567183\",\"value2\" : \"1.3543676402711158\",\"value3\" : null,\"value4\" : null }")
(5 rows)

-- select multiple star functions (do not push down, raise warning and stub error) (result)
--Testcase 41:
SELECT ln_all(),log10_all(),log_all(50) FROM s3;
ERROR:  stub ln_all() is called
CONTEXT:  PL/pgSQL function ln_all() line 3 at RAISE
-- select log2 (stub function, explain)
--Testcase 42:
EXPLAIN VERBOSE
SELECT log2((fields->>'value1')::float),log2((fields->>'value2')::bigint) FROM s3;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2218.59 rows=1462 width=16)
   Output: log2(((fields ->> 'value1'::text))::double precision), log2((((fields ->> 'value2'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2" FROM "s3"
(3 rows)

-- select log2 (stub function, result)
--Testcase 43:
SELECT log2((fields->>'value1')::float),log2((fields->>'value2')::bigint) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select log2(*) (stub agg function, explain)
--Testcase 44:
EXPLAIN VERBOSE
SELECT log2_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: log2_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select log2(*) (stub agg function, result)
--Testcase 45:
SELECT log2_all() from s3;
ERROR:  stub log2_all() is called
CONTEXT:  PL/pgSQL function log2_all() line 3 at RAISE
-- select log2(*) (stub agg function and group by tag only) (explain)
--Testcase 46:
EXPLAIN VERBOSE
SELECT log2_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (log2_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT log2(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select log2(*) (stub agg function and group by tag only) (result)
--Testcase 47:
SELECT log2_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 log2_all                                                                 
------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"-3.321928094887362\",\"value2\" : \"6.643856189774724\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"-2.321928094887362\",\"value2\" : \"6.643856189774724\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"-1.736965594166206\",\"value2\" : \"6.643856189774724\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"0.13750352374993502\",\"value2\" : \"7.643856189774724\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1.1375035237499351\",\"value2\" : \"7.643856189774724\",\"value3\" : null,\"value4\" : null }")
(5 rows)

-- select log10 (stub function, explain)
--Testcase 48:
EXPLAIN VERBOSE
SELECT log10((fields->>'value1')::float),log10((fields->>'value2')::bigint) FROM s3;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1494.89 rows=1462 width=16)
   Output: log10(((fields ->> 'value1'::text))::double precision), log10((((fields ->> 'value2'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2" FROM "s3"
(3 rows)

-- select log10 (stub function, result)
--Testcase 49:
SELECT log10((fields->>'value1')::float),log10((fields->>'value2')::bigint) FROM s3;
        log10        |       log10        
---------------------+--------------------
                  -1 |                  2
 -0.6989700043360187 |                  2
 -0.5228787452803376 |                  2
 0.04139268515822507 | 2.3010299956639813
  0.3424226808222063 | 2.3010299956639813
  0.5185139398778874 | 2.3010299956639813
(6 rows)

-- select log10(*) (stub agg function, explain)
--Testcase 50:
EXPLAIN VERBOSE
SELECT log10_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: log10_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select log10(*) (stub agg function, result)
--Testcase 51:
SELECT log10_all() from s3;
ERROR:  stub log10_all() is called
CONTEXT:  PL/pgSQL function log10_all() line 3 at RAISE
-- select log10(*) (stub agg function and group by tag only) (explain)
--Testcase 52:
EXPLAIN VERBOSE
SELECT log10_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (log10_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT log10(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select log10(*) (stub agg function and group by tag only) (result)
--Testcase 53:
SELECT log10_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                log10_all                                                                 
------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"-0.9999999999999999\",\"value2\" : \"2\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"-0.6989700043360187\",\"value2\" : \"2\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"-0.5228787452803376\",\"value2\" : \"2\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"0.04139268515822507\",\"value2\" : \"2.301029995663981\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"0.3424226808222063\",\"value2\" : \"2.301029995663981\",\"value3\" : null,\"value4\" : null }")
(5 rows)

-- select multiple star functions (do not push down, raise warning and stub error) (result)
--Testcase 54:
SELECT log2_all(), log10_all() FROM s3;
ERROR:  stub log2_all() is called
CONTEXT:  PL/pgSQL function log2_all() line 3 at RAISE
-- select spread (stub agg function, explain)
--Testcase 55:
EXPLAIN VERBOSE
SELECT spread((fields->>'value1')::float),spread((fields->>'value2')::bigint),spread((fields->>'value3')::float),spread((fields->>'value4')::bigint) FROM s3;
                                                                                                            QUERY PLAN                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (spread(((fields ->> 'value1'::text))::double precision)), (spread(((fields ->> 'value2'::text))::bigint)), (spread(((fields ->> 'value3'::text))::double precision)), (spread(((fields ->> 'value4'::text))::bigint))
   InfluxDB query: SELECT spread("value1"), spread("value2"), spread("value3"), spread("value4") FROM "s3"
(3 rows)

-- select spread (stub agg function, result)
--Testcase 56:
SELECT spread((fields->>'value1')::float),spread((fields->>'value2')::bigint),spread((fields->>'value3')::float),spread((fields->>'value4')::bigint) FROM s3;
       spread       | spread |       spread       | spread 
--------------------+--------+--------------------+--------
 3.1999999999999997 |    100 | 3.1999999999999997 |    100
(1 row)

-- select spread (stub agg function, raise exception if not expected type)
--Testcase 57:
SELECT spread((fields->>'value1')::numeric),spread((fields->>'value2')::numeric),spread((fields->>'value3')::numeric),spread((fields->>'value4')::numeric) FROM s3;
ERROR:  stub spread_sfunc(double precision, float8) is called
CONTEXT:  PL/pgSQL function spread_sfunc(double precision,double precision) line 3 at RAISE
-- select abs as nest function with agg (pushdown, explain)
--Testcase 58:
EXPLAIN VERBOSE
SELECT sum((fields->>'value3')::float),abs(sum((fields->>'value3')::float)) FROM s3;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=16)
   Output: (sum(((fields ->> 'value3'::text))::double precision)), (abs(sum(((fields ->> 'value3'::text))::double precision)))
   InfluxDB query: SELECT sum("value3"), abs(sum("value3")) FROM "s3"
(3 rows)

-- select abs as nest function with agg (pushdown, result)
--Testcase 59:
SELECT sum((fields->>'value3')::float),abs(sum((fields->>'value3')::float)) FROM s3;
        sum         |        abs        
--------------------+-------------------
 -7.199999999999999 | 7.199999999999999
(1 row)

-- select abs as nest with log2 (pushdown, explain)
--Testcase 60:
EXPLAIN VERBOSE
SELECT abs(log2((fields->>'value1')::float)),abs(log2(1/(fields->>'value1')::float)) FROM s3;
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2225.89 rows=1462 width=16)
   Output: abs(log2(((fields ->> 'value1'::text))::double precision)), abs(log2(('1'::double precision / ((fields ->> 'value1'::text))::double precision)))
   InfluxDB query: SELECT "value1" FROM "s3"
(3 rows)

-- select abs as nest with log2 (pushdown, result)
--Testcase 61:
SELECT abs(log2((fields->>'value1')::float)),abs(log2(1/(fields->>'value1')::float)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select abs with non pushdown func and explicit constant (explain)
--Testcase 62:
EXPLAIN VERBOSE
SELECT abs((fields->>'value3')::float), pi(), 4.1 FROM s3;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1476.62 rows=1462 width=48)
   Output: abs(((fields ->> 'value3'::text))::double precision), '3.141592653589793'::double precision, 4.1
   InfluxDB query: SELECT "value3" FROM "s3"
(3 rows)

-- select abs with non pushdown func and explicit constant (result)
--Testcase 63:
SELECT abs((fields->>'value3')::float), pi(), 4.1 FROM s3;
 abs |        pi         | ?column? 
-----+-------------------+----------
 0.1 | 3.141592653589793 |      4.1
 0.2 | 3.141592653589793 |      4.1
 0.3 | 3.141592653589793 |      4.1
 1.1 | 3.141592653589793 |      4.1
 2.2 | 3.141592653589793 |      4.1
 3.3 | 3.141592653589793 |      4.1
(6 rows)

-- select sqrt as nest function with agg and explicit constant (pushdown, explain)
--Testcase 64:
EXPLAIN VERBOSE
SELECT sqrt(count((fields->>'value1')::float)), pi(), 4.1 FROM s3;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=48)
   Output: (sqrt((count(((fields ->> 'value1'::text))::double precision))::double precision)), '3.141592653589793'::double precision, 4.1
   InfluxDB query: SELECT sqrt(count("value1")) FROM "s3"
(3 rows)

-- select sqrt as nest function with agg and explicit constant (pushdown, result)
--Testcase 65:
SELECT sqrt(count((fields->>'value1')::float)), pi(), 4.1 FROM s3;
       sqrt        |        pi         | ?column? 
-------------------+-------------------+----------
 2.449489742783178 | 3.141592653589793 |      4.1
(1 row)

-- select sqrt as nest function with agg and explicit constant and tag (error, explain)
--Testcase 66:
EXPLAIN VERBOSE
SELECT sqrt(count((fields->>'value1')::float)), pi(), 4.1, tags->>'tag1' tag1 FROM s3;
ERROR:  column "s3.tags" must appear in the GROUP BY clause or be used in an aggregate function
LINE 2: ...rt(count((fields->>'value1')::float)), pi(), 4.1, tags->>'ta...
                                                             ^
-- select spread (stub agg function and group by influx_time() and tag) (explain)
--Testcase 67:
EXPLAIN VERBOSE
SELECT spread((fields->>'value1')::float),influx_time(time, interval '1s'),tags->>'tag1' tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=48)
   Output: (spread(((fields ->> 'value1'::text))::double precision)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT spread("value1") FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select spread (stub agg function and group by influx_time() and tag) (result)
--Testcase 68:
SELECT spread((fields->>'value1')::float),influx_time(time, interval '1s'),tags->>'tag1' tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
 spread |      influx_time       | tag1 
--------+------------------------+------
      0 | 1970-01-01 09:00:00+09 | a
      0 | 1970-01-01 09:00:01+09 | a
      0 | 1970-01-01 09:00:02+09 | a
        | 1970-01-01 09:00:03+09 | a
        | 1970-01-01 09:00:04+09 | a
        | 1970-01-01 09:00:00+09 | b
        | 1970-01-01 09:00:01+09 | b
        | 1970-01-01 09:00:02+09 | b
      0 | 1970-01-01 09:00:03+09 | b
      0 | 1970-01-01 09:00:04+09 | b
(10 rows)

-- select spread (stub agg function and group by tag only) (result)
--Testcase 69:
SELECT tags->>'tag1' tag1,spread((fields->>'value1')::float) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
 tag1 |       spread        
------+---------------------
 a    | 0.19999999999999998
 b    |                 1.1
(2 rows)

-- select spread (stub agg function and other aggs) (result)
--Testcase 70:
SELECT sum((fields->>'value1')::float),spread((fields->>'value1')::float),count((fields->>'value1')::float) FROM s3;
        sum        |       spread       | count 
-------------------+--------------------+-------
 7.199999999999999 | 3.1999999999999997 |     6
(1 row)

-- select abs with order by (explain)
--Testcase 71:
EXPLAIN VERBOSE
SELECT (fields->>'value1')::float value1, abs(1-(fields->>'value1')::float) FROM s3 order by abs(1-(fields->>'value1')::float);
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1568.10..1571.75 rows=1462 width=16)
   Output: (((fields ->> 'value1'::text))::double precision), (abs(('1'::double precision - ((fields ->> 'value1'::text))::double precision)))
   Sort Key: (abs(('1'::double precision - ((s3.fields ->> 'value1'::text))::double precision)))
   ->  Foreign Scan on public.s3  (cost=10.00..1491.24 rows=1462 width=16)
         Output: ((fields ->> 'value1'::text))::double precision, abs(('1'::double precision - ((fields ->> 'value1'::text))::double precision))
         InfluxDB query: SELECT "value1" FROM "s3"
(6 rows)

-- select abs with order by (result)
--Testcase 72:
SELECT (fields->>'value1')::float value1, abs(1-(fields->>'value1')::float) FROM s3 order by abs(1-(fields->>'value1')::float);
 value1 |         abs         
--------+---------------------
    1.1 | 0.10000000000000009
    0.3 |                 0.7
    0.2 |                 0.8
    0.1 |                 0.9
    2.2 |  1.2000000000000002
    3.3 |                 2.3
(6 rows)

-- select abs with order by index (result)
--Testcase 73:
SELECT (fields->>'value1')::float value1, abs(1-(fields->>'value1')::float) FROM s3 order by 2,1;
 value1 |         abs         
--------+---------------------
    1.1 | 0.10000000000000009
    0.3 |                 0.7
    0.2 |                 0.8
    0.1 |                 0.9
    2.2 |  1.2000000000000002
    3.3 |                 2.3
(6 rows)

-- select abs with order by index (result)
--Testcase 74:
SELECT (fields->>'value1')::float value1, abs(1-(fields->>'value1')::float) FROM s3 order by 1,2;
 value1 |         abs         
--------+---------------------
    0.1 |                 0.9
    0.2 |                 0.8
    0.3 |                 0.7
    1.1 | 0.10000000000000009
    2.2 |  1.2000000000000002
    3.3 |                 2.3
(6 rows)

-- select abs and as
--Testcase 75:
SELECT abs((fields->>'value3')::float) as abs1 FROM s3;
 abs1 
------
  0.1
  0.2
  0.3
  1.1
  2.2
  3.3
(6 rows)

-- select abs(*) (stub agg function, explain)
--Testcase 76:
EXPLAIN VERBOSE
SELECT abs_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: abs_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select abs(*) (stub agg function, result)
--Testcase 77:
SELECT abs_all() from s3;
ERROR:  stub abs_all() is called
CONTEXT:  PL/pgSQL function abs_all() line 3 at RAISE
-- select abs(*) (stub agg function and group by tag only) (explain)
--Testcase 78:
EXPLAIN VERBOSE
SELECT abs_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (abs_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT abs(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select abs(*) (stub agg function and group by tag only) (result)
--Testcase 79:
SELECT abs_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                     abs_all                                                      
------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"0.1\",\"value4\" : \"100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"0.2\",\"value4\" : \"100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"0.3\",\"value4\" : \"100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"1.1\",\"value4\" : \"200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"2.2\",\"value4\" : \"200\" }")
(5 rows)

-- select abs(*) (stub agg function, expose data, explain)
--Testcase 80:
EXPLAIN VERBOSE
SELECT (abs_all()::s3).* from s3;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((abs_all())::s3)."time", ((abs_all())::s3).tags, ((abs_all())::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select abs(*) (stub agg function, expose data, result)
--Testcase 81:
SELECT (abs_all()::s3).* from s3;
ERROR:  stub abs_all() is called
CONTEXT:  PL/pgSQL function abs_all() line 3 at RAISE
-- select spread over join query (explain)
--Testcase 82:
EXPLAIN VERBOSE
SELECT spread((t1.fields->>'value1')::float), spread((t2.fields->>'value1')::float) FROM s3 t1 INNER JOIN s3 t2 ON ((t1.fields->>'value1')::float = (t2.fields->>'value1')::float) where (t1.fields->>'value1')::float = 0.1;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=39.87..39.88 rows=1 width=16)
   Output: spread(((t1.fields ->> 'value1'::text))::double precision), spread(((t2.fields ->> 'value1'::text))::double precision)
   ->  Nested Loop  (cost=20.00..14.63 rows=49 width=64)
         Output: t1.fields, t2.fields
         ->  Foreign Scan on public.s3 t1  (cost=10.00..7.00 rows=7 width=32)
               Output: t1."time", t1.tags, t1.fields
               InfluxDB query: SELECT * FROM "s3" WHERE (("value1" = 0.1))
         ->  Materialize  (cost=10.00..7.04 rows=7 width=32)
               Output: t2.fields
               ->  Foreign Scan on public.s3 t2  (cost=10.00..7.00 rows=7 width=32)
                     Output: t2.fields
                     InfluxDB query: SELECT * FROM "s3" WHERE (("value1" = 0.1))
(12 rows)

-- select spread over join query (result, stub call error)
--Testcase 83:
SELECT spread((t1.fields->>'value1')::float), spread((t2.fields->>'value1')::float) FROM s3 t1 INNER JOIN s3 t2 ON ((t1.fields->>'value1')::float = (t2.fields->>'value1')::float) where (t1.fields->>'value1')::float = 0.1;
ERROR:  stub spread_sfunc(double precision, float8) is called
CONTEXT:  PL/pgSQL function spread_sfunc(double precision,double precision) line 3 at RAISE
-- select spread with having (explain)
--Testcase 84:
EXPLAIN VERBOSE
SELECT spread((fields->>'value1')::float) FROM s3 HAVING spread((fields->>'value1')::float) > 100;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Aggregate  (cost=2214.93..2214.94 rows=1 width=8)
   Output: spread(((fields ->> 'value1'::text))::double precision)
   Filter: (spread(((s3.fields ->> 'value1'::text))::double precision) > '100'::double precision)
   ->  Foreign Scan on public.s3  (cost=10.00..1462.00 rows=1462 width=32)
         Output: "time", tags, fields
         InfluxDB query: SELECT * FROM "s3"
(6 rows)

-- select spread with having (result, not pushdown, stub call error)
--Testcase 85:
SELECT spread((fields->>'value1')::float) FROM s3 HAVING spread((fields->>'value1')::float) > 100;
ERROR:  stub spread_sfunc(double precision, float8) is called
CONTEXT:  PL/pgSQL function spread_sfunc(double precision,double precision) line 3 at RAISE
-- select spread(*) (stub agg function, explain)
--Testcase 86:
EXPLAIN VERBOSE
SELECT spread_all(*) from s3;
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (spread_all(*))
   InfluxDB query: SELECT spread(*) FROM "s3"
(3 rows)

-- select spread(*) (stub agg function, result)
--Testcase 87:
SELECT spread_all(*) from s3;
                                                                   spread_all                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"3.1999999999999997\",\"value2\" : \"100\",\"value3\" : \"3.1999999999999997\",\"value4\" : \"100\" }")
(1 row)

-- select spread(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 88:
EXPLAIN VERBOSE
SELECT spread_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (spread_all(*)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT spread(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select spread(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 89:
SELECT spread_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                spread_all                                                
----------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0\",\"value2\" : \"0\",\"value3\" : \"0\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0\",\"value2\" : \"0\",\"value3\" : \"0\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0\",\"value2\" : \"0\",\"value3\" : \"0\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"0\",\"value2\" : \"0\",\"value3\" : \"0\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"0\",\"value2\" : \"0\",\"value3\" : \"0\",\"value4\" : \"0\" }")
(10 rows)

-- select spread(*) (stub agg function and group by tag only) (explain)
--Testcase 90:
EXPLAIN VERBOSE
SELECT spread_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (spread_all(*)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT spread(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select spread(*) (stub agg function and group by tag only) (result)
--Testcase 91:
SELECT spread_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                  spread_all                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.19999999999999998\",\"value2\" : \"0\",\"value3\" : \"0.19999999999999998\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.1\",\"value2\" : \"0\",\"value3\" : \"1.1\",\"value4\" : \"0\" }")
(2 rows)

-- select spread(*) (stub agg function, expose data, explain)
--Testcase 92:
EXPLAIN VERBOSE
SELECT (spread_all(*)::s3).* from s3;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((spread_all(*)))::s3)."time", (((spread_all(*)))::s3).tags, (((spread_all(*)))::s3).fields
   InfluxDB query: SELECT spread(*) FROM "s3"
(3 rows)

-- select spread(*) (stub agg function, expose data, result)
--Testcase 93:
SELECT (spread_all(*)::s3).* from s3;
          time          | tags |                                               fields                                               
------------------------+------+----------------------------------------------------------------------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "3.1999999999999997", "value2": "100", "value3": "3.1999999999999997", "value4": "100"}
(1 row)

-- select spread(regex) (stub agg function, explain)
--Testcase 94:
EXPLAIN VERBOSE
SELECT spread('/value[1,4]/') from s3;
                       QUERY PLAN                        
---------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (spread('/value[1,4]/'::text))
   InfluxDB query: SELECT spread(/value[1,4]/) FROM "s3"
(3 rows)

-- select spread(regex) (stub agg function, result)
--Testcase 95:
SELECT spread('/value[1,4]/') from s3;
                                        spread                                         
---------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"3.1999999999999997\",\"value4\" : \"100\" }")
(1 row)

-- select spread(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 96:
EXPLAIN VERBOSE
SELECT spread('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (spread('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT spread(/^v.*/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select spread(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 97:
SELECT spread('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                  spread                                                  
----------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0\",\"value2\" : \"0\",\"value3\" : \"0\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0\",\"value2\" : \"0\",\"value3\" : \"0\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0\",\"value2\" : \"0\",\"value3\" : \"0\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"0\",\"value2\" : \"0\",\"value3\" : \"0\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"0\",\"value2\" : \"0\",\"value3\" : \"0\",\"value4\" : \"0\" }")
(10 rows)

-- select spread(regex) (stub agg function and group by tag only) (explain)
--Testcase 98:
EXPLAIN VERBOSE
SELECT spread('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (spread('/value[1,4]/'::text)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT spread(/value[1,4]/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select spread(regex) (stub agg function and group by tag only) (result)
--Testcase 99:
SELECT spread('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                        spread                                        
--------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.19999999999999998\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.1\",\"value4\" : \"0\" }")
(2 rows)

-- select spread(regex) (stub agg function, expose data, explain)
--Testcase 100:
EXPLAIN VERBOSE
SELECT (spread('/value[1,4]/')::s3).* from s3;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((spread('/value[1,4]/'::text)))::s3)."time", (((spread('/value[1,4]/'::text)))::s3).tags, (((spread('/value[1,4]/'::text)))::s3).fields
   InfluxDB query: SELECT spread(/value[1,4]/) FROM "s3"
(3 rows)

-- select spread(regex) (stub agg function, expose data, result)
--Testcase 101:
SELECT (spread('/value[1,4]/')::s3).* from s3;
          time          | tags |                      fields                       
------------------------+------+---------------------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "3.1999999999999997", "value4": "100"}
(1 row)

-- select abs with arithmetic and tag in the middle (explain)
--Testcase 102:
EXPLAIN VERBOSE
SELECT abs((fields->>'value1')::float) + 1, (fields->>'value2')::bigint value2, tags->>'tag1' tag1, sqrt((fields->>'value2')::bigint) FROM s3;
                                                                                                        QUERY PLAN                                                                                                         
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..962.55 rows=930 width=56)
   Output: (abs(((fields ->> 'value1'::text))::double precision) + '1'::double precision), ((fields ->> 'value2'::text))::bigint, (tags ->> 'tag1'::text), sqrt((((fields ->> 'value2'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2", "tag1" FROM "s3"
(3 rows)

-- select abs with arithmetic and tag in the middle (result)
--Testcase 103:
SELECT abs((fields->>'value1')::float) + 1, (fields->>'value2')::bigint value2, tags->>'tag1' tag1, sqrt((fields->>'value2')::bigint) FROM s3;
 ?column? | value2 | tag1 |        sqrt        
----------+--------+------+--------------------
      1.1 |    100 | a    |                 10
      1.2 |    100 | a    |                 10
      1.3 |    100 | a    |                 10
      2.1 |    200 | b    | 14.142135623730951
      3.2 |    200 | b    | 14.142135623730951
      4.3 |    200 | b    | 14.142135623730951
(6 rows)

-- select with order by limit (explain)
--Testcase 104:
EXPLAIN VERBOSE
SELECT abs((fields->>'value1')::float), abs((fields->>'value3')::float), sqrt((fields->>'value2')::bigint) FROM s3 ORDER BY abs((fields->>'value3')::float) LIMIT 1;
                                                                                            QUERY PLAN                                                                                             
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=1516.83..1516.83 rows=1 width=24)
   Output: (abs(((fields ->> 'value1'::text))::double precision)), (abs(((fields ->> 'value3'::text))::double precision)), (sqrt((((fields ->> 'value2'::text))::bigint)::double precision))
   ->  Sort  (cost=1516.83..1520.48 rows=1462 width=24)
         Output: (abs(((fields ->> 'value1'::text))::double precision)), (abs(((fields ->> 'value3'::text))::double precision)), (sqrt((((fields ->> 'value2'::text))::bigint)::double precision))
         Sort Key: (abs(((s3.fields ->> 'value3'::text))::double precision))
         ->  Foreign Scan on public.s3  (cost=10.00..1509.52 rows=1462 width=24)
               Output: abs(((fields ->> 'value1'::text))::double precision), abs(((fields ->> 'value3'::text))::double precision), sqrt((((fields ->> 'value2'::text))::bigint)::double precision)
               InfluxDB query: SELECT "value1", "value3", "value2" FROM "s3"
(8 rows)

-- select with order by limit (result)
--Testcase 105:
SELECT abs((fields->>'value1')::float), abs((fields->>'value3')::float), sqrt((fields->>'value2')::bigint) FROM s3 ORDER BY abs((fields->>'value3')::float) LIMIT 1;
 abs | abs | sqrt 
-----+-----+------
 0.1 | 0.1 |   10
(1 row)

-- select mixing with non pushdown func (all not pushdown, explain)
--Testcase 106:
EXPLAIN VERBOSE
SELECT abs((fields->>'value1')::float), sqrt((fields->>'value2')::bigint), upper(tags->>'tag1') FROM s3;
                                                                           QUERY PLAN                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..955.58 rows=930 width=48)
   Output: abs(((fields ->> 'value1'::text))::double precision), sqrt((((fields ->> 'value2'::text))::bigint)::double precision), upper((tags ->> 'tag1'::text))
   InfluxDB query: SELECT "value1", "value2", "tag1" FROM "s3"
(3 rows)

-- select mixing with non pushdown func (result)
--Testcase 107:
SELECT abs((fields->>'value1')::float), sqrt((fields->>'value2')::bigint), upper(tags->>'tag1') FROM s3;
 abs |        sqrt        | upper 
-----+--------------------+-------
 0.1 |                 10 | A
 0.2 |                 10 | A
 0.3 |                 10 | A
 1.1 | 14.142135623730951 | B
 2.2 | 14.142135623730951 | B
 3.3 | 14.142135623730951 | B
(6 rows)

-- nested function in where clause (explain)
--Testcase 108:
EXPLAIN VERBOSE
SELECT sqrt(abs((fields->>'value3')::float)),min((fields->>'value1')::float) FROM s3 GROUP BY fields->>'value3' HAVING sqrt(abs((fields->>'value3')::float)) > 0 ORDER BY 1,2;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=506.25..506.72 rows=190 width=48)
   Output: (sqrt(abs((((fields ->> 'value3'::text)))::double precision))), (min(((fields ->> 'value1'::text))::double precision)), ((fields ->> 'value3'::text))
   Sort Key: (sqrt(abs((((s3.fields ->> 'value3'::text)))::double precision))), (min(((s3.fields ->> 'value1'::text))::double precision))
   ->  HashAggregate  (cost=494.30..499.05 rows=190 width=48)
         Output: sqrt(abs((((fields ->> 'value3'::text)))::double precision)), min(((fields ->> 'value1'::text))::double precision), ((fields ->> 'value3'::text))
         Group Key: (s3.fields ->> 'value3'::text)
         ->  Foreign Scan on public.s3  (cost=10.00..488.22 rows=487 width=64)
               Output: (fields ->> 'value3'::text), fields
               Filter: (sqrt(abs(((s3.fields ->> 'value3'::text))::double precision)) > '0'::double precision)
               InfluxDB query: SELECT * FROM "s3"
(10 rows)

-- nested function in where clause (result)
--Testcase 109:
SELECT sqrt(abs((fields->>'value3')::float)),min((fields->>'value1')::float) FROM s3 GROUP BY fields->>'value3' HAVING sqrt(abs((fields->>'value3')::float)) > 0 ORDER BY 1,2;
        sqrt         | min 
---------------------+-----
 0.31622776601683794 | 0.1
  0.4472135954999579 | 0.2
  0.5477225575051661 | 0.3
  1.0488088481701516 | 1.1
  1.4832396974191326 | 2.2
   1.816590212458495 | 3.3
(6 rows)

--Testcase 110:
EXPLAIN VERBOSE
SELECT first(time, (fields->>'value1')::float), first(time, (fields->>'value2')::bigint), first(time, (fields->>'value3')::float), first(time, (fields->>'value4')::bigint) FROM s3;
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (first("time", ((fields ->> 'value1'::text))::double precision)), (first("time", ((fields ->> 'value2'::text))::bigint)), (first("time", ((fields ->> 'value3'::text))::double precision)), (first("time", ((fields ->> 'value4'::text))::bigint))
   InfluxDB query: SELECT first("value1"), first("value2"), first("value3"), first("value4") FROM "s3"
(3 rows)

--Testcase 111:
SELECT first(time, (fields->>'value1')::float), first(time, (fields->>'value2')::bigint), first(time, (fields->>'value3')::float), first(time, (fields->>'value4')::bigint) FROM s3;
 first | first | first | first 
-------+-------+-------+-------
   0.1 |   100 |  -0.1 |  -100
(1 row)

-- select first(*) (stub agg function, explain)
--Testcase 112:
EXPLAIN VERBOSE
SELECT first_all(*) from s3;
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (first_all(*))
   InfluxDB query: SELECT first(*) FROM "s3"
(3 rows)

-- select first(*) (stub agg function, result)
--Testcase 113:
SELECT first_all(*) from s3;
                                                     first_all                                                      
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
(1 row)

-- select first(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 114:
EXPLAIN VERBOSE
SELECT first_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                           QUERY PLAN                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (first_all(*)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT first(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select first(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 115:
SELECT first_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                     first_all                                                      
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select first(*) (stub agg function and group by tag only) (explain)
--Testcase 116:
EXPLAIN VERBOSE
SELECT first_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (first_all(*)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT first(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select first(*) (stub agg function and group by tag only) (result)
--Testcase 117:
SELECT first_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                     first_all                                                      
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
(2 rows)

-- select first(*) (stub agg function, expose data, explain)
--Testcase 118:
EXPLAIN VERBOSE
SELECT (first_all(*)::s3).* from s3;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((first_all(*)))::s3)."time", (((first_all(*)))::s3).tags, (((first_all(*)))::s3).fields
   InfluxDB query: SELECT first(*) FROM "s3"
(3 rows)

-- select first(*) (stub agg function, expose data, result)
--Testcase 119:
SELECT (first_all(*)::s3).* from s3;
          time          | tags |                                 fields                                 
------------------------+------+------------------------------------------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "0.1", "value2": "100", "value3": "-0.1", "value4": "-100"}
(1 row)

-- select first(regex) (stub function, explain)
--Testcase 120:
EXPLAIN VERBOSE
SELECT first('/value[1,4]/') from s3;
                       QUERY PLAN                       
--------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (first('/value[1,4]/'::text))
   InfluxDB query: SELECT first(/value[1,4]/) FROM "s3"
(3 rows)

-- select first(regex) (stub function, explain)
--Testcase 121:
SELECT first('/value[1,4]/') from s3;
                                  first                                  
-------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value4\" : \"-100\" }")
(1 row)

-- select multiple regex functions (do not push down, raise warning and stub error) (explain)
--Testcase 122:
EXPLAIN VERBOSE
SELECT first('/value[1,4]/'), first('/^v.*/') from s3;
WARNING:  Selecting multiple functions with regular expression or star is not supported.
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Aggregate  (cost=5119.50..5119.51 rows=1 width=64)
   Output: first('/value[1,4]/'::text), first('/^v.*/'::text)
   ->  Foreign Scan on public.s3  (cost=10.00..3413.00 rows=3413 width=0)
         Output: "time", tags, fields
         InfluxDB query: SELECT * FROM "s3"
(5 rows)

-- select multiple regex functions (do not push down, raise warning and stub error) (result)
--Testcase 123:
SELECT first('/value[1,4]/'), first('/^v.*/') from s3;
WARNING:  Selecting multiple functions with regular expression or star is not supported.
ERROR:  stub first_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function first_sfunc(text,text) line 3 at RAISE
-- select first(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 124:
EXPLAIN VERBOSE
SELECT first('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (first('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT first(/^v.*/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select first(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 125:
SELECT first('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                       first                                                        
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select first(regex) (stub agg function and group by tag only) (explain)
--Testcase 126:
EXPLAIN VERBOSE
SELECT first('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (first('/value[1,4]/'::text)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT first(/value[1,4]/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select first(regex) (stub agg function and group by tag only) (result)
--Testcase 127:
SELECT first('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                  first                                  
-------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.1\",\"value4\" : \"-200\" }")
(2 rows)

-- select first(regex) (stub agg function, expose data, explain)
--Testcase 128:
EXPLAIN VERBOSE
SELECT (first('/value[1,4]/')::s3).* from s3;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((first('/value[1,4]/'::text)))::s3)."time", (((first('/value[1,4]/'::text)))::s3).tags, (((first('/value[1,4]/'::text)))::s3).fields
   InfluxDB query: SELECT first(/value[1,4]/) FROM "s3"
(3 rows)

-- select first(regex) (stub agg function, expose data, result)
--Testcase 129:
SELECT (first('/value[1,4]/')::s3).* from s3;
          time          | tags |               fields                
------------------------+------+-------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "0.1", "value4": "-100"}
(1 row)

--Testcase 130:
EXPLAIN VERBOSE
SELECT last(time, (fields->>'value1')::float), last(time, (fields->>'value2')::bigint), last(time, (fields->>'value3')::float), last(time, (fields->>'value4')::bigint) FROM s3;
                                                                                                                        QUERY PLAN                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (last("time", ((fields ->> 'value1'::text))::double precision)), (last("time", ((fields ->> 'value2'::text))::bigint)), (last("time", ((fields ->> 'value3'::text))::double precision)), (last("time", ((fields ->> 'value4'::text))::bigint))
   InfluxDB query: SELECT last("value1"), last("value2"), last("value3"), last("value4") FROM "s3"
(3 rows)

--Testcase 131:
SELECT last(time, (fields->>'value1')::float), last(time, (fields->>'value2')::bigint), last(time, (fields->>'value3')::float), last(time, (fields->>'value4')::bigint) FROM s3;
 last | last | last | last 
------+------+------+------
  3.3 |  200 | -3.3 | -200
(1 row)

-- select last(*) (stub agg function, explain)
--Testcase 132:
EXPLAIN VERBOSE
SELECT last_all(*) from s3;
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (last_all(*))
   InfluxDB query: SELECT last(*) FROM "s3"
(3 rows)

-- select last(*) (stub agg function, result)
--Testcase 133:
SELECT last_all(*) from s3;
                                                      last_all                                                      
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"3.3\",\"value2\" : \"200\",\"value3\" : \"-3.3\",\"value4\" : \"-200\" }")
(1 row)

-- select last(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 134:
EXPLAIN VERBOSE
SELECT last_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (last_all(*)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT last(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select last(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 135:
SELECT last_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                      last_all                                                      
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select last(*) (stub agg function and group by tag only) (explain)
--Testcase 136:
EXPLAIN VERBOSE
SELECT last_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (last_all(*)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT last(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select last(*) (stub agg function and group by tag only) (result)
--Testcase 137:
SELECT last_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                      last_all                                                      
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(2 rows)

-- select last(*) (stub agg function, expose data, explain)
--Testcase 138:
EXPLAIN VERBOSE
SELECT (last_all(*)::s3).* from s3;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((last_all(*)))::s3)."time", (((last_all(*)))::s3).tags, (((last_all(*)))::s3).fields
   InfluxDB query: SELECT last(*) FROM "s3"
(3 rows)

-- select last(*) (stub agg function, expose data, result)
--Testcase 139:
SELECT (last_all(*)::s3).* from s3;
          time          | tags |                                 fields                                 
------------------------+------+------------------------------------------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "3.3", "value2": "200", "value3": "-3.3", "value4": "-200"}
(1 row)

-- select last(regex) (stub function, explain)
--Testcase 140:
EXPLAIN VERBOSE
SELECT last('/value[1,4]/') from s3;
                      QUERY PLAN                       
-------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (last('/value[1,4]/'::text))
   InfluxDB query: SELECT last(/value[1,4]/) FROM "s3"
(3 rows)

-- select last(regex) (stub function, result)
--Testcase 141:
SELECT last('/value[1,4]/') from s3;
                                  last                                   
-------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"3.3\",\"value4\" : \"-200\" }")
(1 row)

-- select multiple regex functions (do not push down, raise warning and stub error) (explain)
--Testcase 142:
EXPLAIN VERBOSE
SELECT first('/value[1,4]/'), first('/^v.*/') from s3;
WARNING:  Selecting multiple functions with regular expression or star is not supported.
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Aggregate  (cost=5119.50..5119.51 rows=1 width=64)
   Output: first('/value[1,4]/'::text), first('/^v.*/'::text)
   ->  Foreign Scan on public.s3  (cost=10.00..3413.00 rows=3413 width=0)
         Output: "time", tags, fields
         InfluxDB query: SELECT * FROM "s3"
(5 rows)

-- select multiple regex functions (do not push down, raise warning and stub error) (result)
--Testcase 143:
SELECT first('/value[1,4]/'), first('/^v.*/') from s3;
WARNING:  Selecting multiple functions with regular expression or star is not supported.
ERROR:  stub first_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function first_sfunc(text,text) line 3 at RAISE
-- select last(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 144:
EXPLAIN VERBOSE
SELECT last('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (last('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT last(/^v.*/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select last(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 145:
SELECT last('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                        last                                                        
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select last(regex) (stub agg function and group by tag only) (explain)
--Testcase 146:
EXPLAIN VERBOSE
SELECT last('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (last('/value[1,4]/'::text)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT last(/value[1,4]/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select last(regex) (stub agg function and group by tag only) (result)
--Testcase 147:
SELECT last('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                  last                                   
-------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"2.2\",\"value4\" : \"-200\" }")
(2 rows)

-- select last(regex) (stub agg function, expose data, explain)
--Testcase 148:
EXPLAIN VERBOSE
SELECT (last('/value[1,4]/')::s3).* from s3;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((last('/value[1,4]/'::text)))::s3)."time", (((last('/value[1,4]/'::text)))::s3).tags, (((last('/value[1,4]/'::text)))::s3).fields
   InfluxDB query: SELECT last(/value[1,4]/) FROM "s3"
(3 rows)

-- select last(regex) (stub agg function, expose data, result)
--Testcase 149:
SELECT (last('/value[1,4]/')::s3).* from s3;
          time          | tags |               fields                
------------------------+------+-------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "3.3", "value4": "-200"}
(1 row)

--Testcase 150:
EXPLAIN VERBOSE
SELECT sample((fields->>'value2')::bigint, 3) FROM s3 WHERE (fields->>'value2')::bigint < 200;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=8)
   Output: (sample(((fields ->> 'value2'::text))::bigint, 3))
   InfluxDB query: SELECT sample("value2", 3) FROM "s3" WHERE (("value2" < 200))
(3 rows)

--Testcase 151:
SELECT sample((fields->>'value2')::bigint, 3) FROM s3 WHERE (fields->>'value2')::bigint < 200;
 sample 
--------
    100
    100
    100
(3 rows)

--Testcase 152:
EXPLAIN VERBOSE
SELECT sample((fields->>'value2')::bigint, 1) FROM s3 WHERE time >= to_timestamp(0) AND time <= to_timestamp(5) GROUP BY influx_time(time, interval '3s');
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=16)
   Output: (sample(((fields ->> 'value2'::text))::bigint, 1)), (influx_time("time", '@ 3 secs'::interval))
   InfluxDB query: SELECT sample("value2", 1) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:05')) GROUP BY (time(0d0h0m3s0u))
(3 rows)

--Testcase 153:
SELECT sample((fields->>'value2')::bigint, 1) FROM s3 WHERE time >= to_timestamp(0) AND time <= to_timestamp(5) GROUP BY influx_time(time, interval '3s');
 sample 
--------
    100
    200
(2 rows)

-- select sample(*, int) (stub agg function, explain)
--Testcase 154:
EXPLAIN VERBOSE
SELECT sample_all(50) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: sample_all(50)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select sample(*, int) (stub agg function, result)
--Testcase 155:
SELECT sample_all(50) from s3;
ERROR:  stub sample_all(int) is called
CONTEXT:  PL/pgSQL function sample_all(integer) line 3 at RAISE
-- select sample(*, int) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 156:
EXPLAIN VERBOSE
SELECT sample_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (sample_all(50)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT sample(*, 50) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select sample(*, int) (stub agg function and group by influx_time() and tag) (result)
--Testcase 157:
SELECT sample_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                     sample_all                                                     
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(5 rows)

-- select sample(*, int) (stub agg function and group by tag only) (explain)
--Testcase 158:
EXPLAIN VERBOSE
SELECT sample_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (sample_all(50)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT sample(*, 50) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select sample(*, int) (stub agg function and group by tag only) (result)
--Testcase 159:
SELECT sample_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                     sample_all                                                     
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(5 rows)

-- select sample(*, int) (stub agg function, expose data, explain)
--Testcase 160:
EXPLAIN VERBOSE
SELECT (sample_all(50)::s3).* from s3;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((sample_all(50))::s3)."time", ((sample_all(50))::s3).tags, ((sample_all(50))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select sample(*, int) (stub agg function, expose data, result)
--Testcase 161:
SELECT (sample_all(50)::s3).* from s3;
ERROR:  stub sample_all(int) is called
CONTEXT:  PL/pgSQL function sample_all(integer) line 3 at RAISE
-- select sample(regex) (stub agg function, explain)
--Testcase 162:
EXPLAIN VERBOSE
SELECT sample('/value[1,4]/', 50) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: sample('/value[1,4]/'::text, 50)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select sample(regex) (stub agg function, result)
--Testcase 163:
SELECT sample('/value[1,4]/', 50) from s3;
ERROR:  stub sample(text, int) is called
CONTEXT:  PL/pgSQL function sample(text,integer) line 3 at RAISE
-- select sample(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 164:
EXPLAIN VERBOSE
SELECT sample('/^v.*/', 50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (sample('/^v.*/'::text, 50)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT sample(/^v.*/, 50) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select sample(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 165:
SELECT sample('/^v.*/', 50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                       sample                                                       
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(5 rows)

-- select sample(regex) (stub agg function and group by tag only) (explain)
--Testcase 166:
EXPLAIN VERBOSE
SELECT sample('/value[1,4]/', 50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (sample('/value[1,4]/'::text, 50)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT sample(/value[1,4]/, 50) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select sample(regex) (stub agg function and group by tag only) (result)
--Testcase 167:
SELECT sample('/value[1,4]/', 50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                 sample                                  
-------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value4\" : \"-200\" }")
(5 rows)

-- select sample(regex) (stub agg function, expose data, explain)
--Testcase 168:
EXPLAIN VERBOSE
SELECT (sample('/value[1,4]/', 50)::s3).* from s3;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((sample('/value[1,4]/'::text, 50))::s3)."time", ((sample('/value[1,4]/'::text, 50))::s3).tags, ((sample('/value[1,4]/'::text, 50))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select sample(regex) (stub agg function, expose data, result)
--Testcase 169:
SELECT (sample('/value[1,4]/', 50)::s3).* from s3;
ERROR:  stub sample(text, int) is called
CONTEXT:  PL/pgSQL function sample(text,integer) line 3 at RAISE
--Testcase 170:
EXPLAIN VERBOSE
SELECT cumulative_sum((fields->>'value1')::float),cumulative_sum((fields->>'value2')::bigint),cumulative_sum((fields->>'value3')::float),cumulative_sum((fields->>'value4')::bigint) FROM s3;
                                                                                                                        QUERY PLAN                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: cumulative_sum(((fields ->> 'value1'::text))::double precision), cumulative_sum(((fields ->> 'value2'::text))::bigint), cumulative_sum(((fields ->> 'value3'::text))::double precision), cumulative_sum(((fields ->> 'value4'::text))::bigint)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 171:
SELECT cumulative_sum((fields->>'value1')::float),cumulative_sum((fields->>'value2')::bigint),cumulative_sum((fields->>'value3')::float),cumulative_sum((fields->>'value4')::bigint) FROM s3;
ERROR:  stub cumulative_sum(float8) is called
CONTEXT:  PL/pgSQL function cumulative_sum(double precision) line 3 at RAISE
-- select cumulative_sum(*) (stub function, explain)
--Testcase 172:
EXPLAIN VERBOSE
SELECT cumulative_sum_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: cumulative_sum_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select cumulative_sum(*) (stub function, result)
--Testcase 173:
SELECT cumulative_sum_all() from s3;
ERROR:  stub cumulative_sum_all() is called
CONTEXT:  PL/pgSQL function cumulative_sum_all() line 3 at RAISE
-- select cumulative_sum(regex) (stub function, result)
--Testcase 174:
SELECT cumulative_sum('/value[1,4]/') from s3;
ERROR:  stub cumulative_sum(text) is called
CONTEXT:  PL/pgSQL function cumulative_sum(text) line 3 at RAISE
-- select cumulative_sum(regex) (stub function, result)
--Testcase 175:
SELECT cumulative_sum('/value[1,4]/') from s3;
ERROR:  stub cumulative_sum(text) is called
CONTEXT:  PL/pgSQL function cumulative_sum(text) line 3 at RAISE
-- select multiple star and regex functions (do not push down, raise warning and stub error) (result)
--Testcase 176:
EXPLAIN VERBOSE
SELECT cumulative_sum_all(), cumulative_sum('/value[1,4]/') from s3;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..5119.50 rows=3413 width=64)
   Output: cumulative_sum_all(), cumulative_sum('/value[1,4]/'::text)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select multiple star and regex functions (do not push down, raise warning and stub error) (result)
--Testcase 177:
SELECT cumulative_sum_all(), cumulative_sum('/value[1,4]/') from s3;
ERROR:  stub cumulative_sum_all() is called
CONTEXT:  PL/pgSQL function cumulative_sum_all() line 3 at RAISE
-- select cumulative_sum(*) (stub function and group by tag only) (explain)
--Testcase 178:
EXPLAIN VERBOSE
SELECT cumulative_sum_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (cumulative_sum_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT cumulative_sum(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select cumulative_sum(*) (stub function and group by tag only) (result)
--Testcase 179:
SELECT cumulative_sum_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 cumulative_sum_all                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.30000000000000004\",\"value2\" : \"200\",\"value3\" : \"-0.30000000000000004\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.6000000000000001\",\"value2\" : \"300\",\"value3\" : \"-0.6000000000000001\",\"value4\" : \"-300\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"3.3000000000000003\",\"value2\" : \"400\",\"value3\" : \"-3.3000000000000003\",\"value4\" : \"-400\" }")
(5 rows)

-- select cumulative_sum(regex) (stub function and group by tag only) (explain)
--Testcase 180:
EXPLAIN VERBOSE
SELECT cumulative_sum('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                           QUERY PLAN                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (cumulative_sum('/value[1,4]/'::text)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT cumulative_sum(/value[1,4]/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select cumulative_sum(regex) (stub function and group by tag only) (result)
--Testcase 181:
SELECT cumulative_sum('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                     cumulative_sum                                      
-----------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.30000000000000004\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.6000000000000001\",\"value4\" : \"-300\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"3.3000000000000003\",\"value4\" : \"-400\" }")
(5 rows)

-- select cumulative_sum(*), cumulative_sum(regex) (stub agg function, expose data, explain)
--Testcase 182:
EXPLAIN VERBOSE
SELECT (cumulative_sum_all()::s3).*, (cumulative_sum('/value[1,4]/')::s3).* from s3;
                                                                                                                                     QUERY PLAN                                                                                                                                     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..8634.89 rows=3413 width=144)
   Output: ((cumulative_sum_all())::s3)."time", ((cumulative_sum_all())::s3).tags, ((cumulative_sum_all())::s3).fields, ((cumulative_sum('/value[1,4]/'::text))::s3)."time", ((cumulative_sum('/value[1,4]/'::text))::s3).tags, ((cumulative_sum('/value[1,4]/'::text))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select cumulative_sum(*), cumulative_sum(regex) (stub agg function, expose data, result)
--Testcase 183:
SELECT (cumulative_sum_all()::s3).*, (cumulative_sum('/value[1,4]/')::s3).* from s3;
ERROR:  stub cumulative_sum_all() is called
CONTEXT:  PL/pgSQL function cumulative_sum_all() line 3 at RAISE
--Testcase 184:
EXPLAIN VERBOSE
SELECT derivative((fields->>'value1')::float),derivative((fields->>'value2')::bigint),derivative((fields->>'value3')::float),derivative((fields->>'value4')::bigint) FROM s3;
                                                                                                                QUERY PLAN                                                                                                                
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: derivative(((fields ->> 'value1'::text))::double precision), derivative(((fields ->> 'value2'::text))::bigint), derivative(((fields ->> 'value3'::text))::double precision), derivative(((fields ->> 'value4'::text))::bigint)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 185:
SELECT derivative((fields->>'value1')::float),derivative((fields->>'value2')::bigint),derivative((fields->>'value3')::float),derivative((fields->>'value4')::bigint) FROM s3;
ERROR:  stub derivative(anyelement) is called
CONTEXT:  PL/pgSQL function derivative(anyelement) line 3 at RAISE
--Testcase 186:
EXPLAIN VERBOSE
SELECT derivative((fields->>'value1')::float, interval '0.5s'),derivative((fields->>'value2')::bigint, interval '0.2s'),derivative((fields->>'value3')::float, interval '0.1s'),derivative((fields->>'value4')::bigint, interval '2s') FROM s3;
                                                                                                                                                               QUERY PLAN                                                                                                                                                               
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: derivative(((fields ->> 'value1'::text))::double precision, '@ 0.5 secs'::interval), derivative(((fields ->> 'value2'::text))::bigint, '@ 0.2 secs'::interval), derivative(((fields ->> 'value3'::text))::double precision, '@ 0.1 secs'::interval), derivative(((fields ->> 'value4'::text))::bigint, '@ 2 secs'::interval)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 187:
SELECT derivative((fields->>'value1')::float, interval '0.5s'),derivative((fields->>'value2')::bigint, interval '0.2s'),derivative((fields->>'value3')::float, interval '0.1s'),derivative((fields->>'value4')::bigint, interval '2s') FROM s3;
ERROR:  stub derivative(anyelement, interval) is called
CONTEXT:  PL/pgSQL function derivative(anyelement,interval) line 3 at RAISE
-- select derivative(*) (stub function, explain)
--Testcase 188:
EXPLAIN VERBOSE
SELECT derivative_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: derivative_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select derivative(*) (stub function, result)
--Testcase 189:
SELECT derivative_all() from s3;
ERROR:  stub derivative_all() is called
CONTEXT:  PL/pgSQL function derivative_all() line 3 at RAISE
-- select derivative(regex) (stub function, explain)
--Testcase 190:
EXPLAIN VERBOSE
SELECT derivative('/value[1,4]/') from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: derivative('/value[1,4]/'::text)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select derivative(regex) (stub function, result)
--Testcase 191:
SELECT derivative('/value[1,4]/') from s3;
ERROR:  stub derivative(text) is called
CONTEXT:  PL/pgSQL function derivative(text) line 3 at RAISE
-- select multiple star and regex functions (do not push down, raise warning and stub error) (explain)
--Testcase 192:
EXPLAIN VERBOSE
SELECT derivative_all(), derivative('/value[1,4]/') from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..5119.50 rows=3413 width=64)
   Output: derivative_all(), derivative('/value[1,4]/'::text)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select multiple star and regex functions (do not push down, raise warning and stub error) (explain)
--Testcase 193:
SELECT derivative_all(), derivative('/value[1,4]/') from s3;
ERROR:  stub derivative_all() is called
CONTEXT:  PL/pgSQL function derivative_all() line 3 at RAISE
-- select derivative(*) (stub function and group by tag only) (explain)
--Testcase 194:
EXPLAIN VERBOSE
SELECT derivative_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (derivative_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT derivative(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select derivative(*) (stub function and group by tag only) (result)
--Testcase 195:
SELECT derivative_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                derivative_all                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.1\",\"value2\" : \"0\",\"value3\" : \"-0.1\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.09999999999999998\",\"value2\" : \"0\",\"value3\" : \"-0.09999999999999998\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1.1\",\"value2\" : \"0\",\"value3\" : \"-1.1\",\"value4\" : \"0\" }")
(3 rows)

-- select derivative(regex) (stub function and group by tag only) (explain)
--Testcase 196:
EXPLAIN VERBOSE
SELECT derivative('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (derivative('/value[1,4]/'::text)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT derivative(/value[1,4]/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select derivative(regex) (stub function and group by tag only) (result)
--Testcase 197:
SELECT derivative('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                      derivative                                      
--------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.1\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.09999999999999998\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1.1\",\"value4\" : \"0\" }")
(3 rows)

-- select derivative(*) (stub agg function, expose data, explain)
--Testcase 198:
EXPLAIN VERBOSE
SELECT (derivative_all()::s3).* from s3;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((derivative_all())::s3)."time", ((derivative_all())::s3).tags, ((derivative_all())::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select derivative(*) (stub agg function, expose data, result)
--Testcase 199:
SELECT (derivative_all()::s3).* from s3;
ERROR:  stub derivative_all() is called
CONTEXT:  PL/pgSQL function derivative_all() line 3 at RAISE
-- select derivative(regex) (stub agg function, expose data, explain)
--Testcase 200:
EXPLAIN VERBOSE
SELECT (derivative('/value[1,4]/')::s3).* from s3;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((derivative('/value[1,4]/'::text))::s3)."time", ((derivative('/value[1,4]/'::text))::s3).tags, ((derivative('/value[1,4]/'::text))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select derivative(regex) (stub agg function, expose data, result)
--Testcase 201:
SELECT (derivative('/value[1,4]/')::s3).* from s3;
ERROR:  stub derivative(text) is called
CONTEXT:  PL/pgSQL function derivative(text) line 3 at RAISE
--Testcase 202:
EXPLAIN VERBOSE
SELECT non_negative_derivative((fields->>'value1')::float),non_negative_derivative((fields->>'value2')::bigint),non_negative_derivative((fields->>'value3')::float),non_negative_derivative((fields->>'value4')::bigint) FROM s3;
                                                                                                                                          QUERY PLAN                                                                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: non_negative_derivative(((fields ->> 'value1'::text))::double precision), non_negative_derivative(((fields ->> 'value2'::text))::bigint), non_negative_derivative(((fields ->> 'value3'::text))::double precision), non_negative_derivative(((fields ->> 'value4'::text))::bigint)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 203:
SELECT non_negative_derivative((fields->>'value1')::float),non_negative_derivative((fields->>'value2')::bigint),non_negative_derivative((fields->>'value3')::float),non_negative_derivative((fields->>'value4')::bigint) FROM s3;
ERROR:  stub non_negative_derivative(anyelement) is called
CONTEXT:  PL/pgSQL function non_negative_derivative(anyelement) line 3 at RAISE
--Testcase 204:
EXPLAIN VERBOSE
SELECT non_negative_derivative((fields->>'value1')::float, interval '0.5s'),non_negative_derivative((fields->>'value2')::bigint, interval '0.2s'),non_negative_derivative((fields->>'value3')::float, interval '0.1s'),non_negative_derivative((fields->>'value4')::bigint, interval '2s') FROM s3;
                                                                                                                                                                                         QUERY PLAN                                                                                                                                                                                         
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: non_negative_derivative(((fields ->> 'value1'::text))::double precision, '@ 0.5 secs'::interval), non_negative_derivative(((fields ->> 'value2'::text))::bigint, '@ 0.2 secs'::interval), non_negative_derivative(((fields ->> 'value3'::text))::double precision, '@ 0.1 secs'::interval), non_negative_derivative(((fields ->> 'value4'::text))::bigint, '@ 2 secs'::interval)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 205:
SELECT non_negative_derivative((fields->>'value1')::float, interval '0.5s'),non_negative_derivative((fields->>'value2')::bigint, interval '0.2s'),non_negative_derivative((fields->>'value3')::float, interval '0.1s'),non_negative_derivative((fields->>'value4')::bigint, interval '2s') FROM s3;
ERROR:  stub non_negative_derivative(anyelement, interval) is called
CONTEXT:  PL/pgSQL function non_negative_derivative(anyelement,interval) line 3 at RAISE
-- select non_negative_derivative(*) (stub function, explain)
--Testcase 206:
EXPLAIN VERBOSE
SELECT non_negative_derivative_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: non_negative_derivative_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select non_negative_derivative(*) (stub function, result)
--Testcase 207:
SELECT non_negative_derivative_all() from s3;
ERROR:  stub non_negative_derivative_all() is called
CONTEXT:  PL/pgSQL function non_negative_derivative_all() line 3 at RAISE
-- select non_negative_derivative(regex) (stub function, explain)
--Testcase 208:
EXPLAIN VERBOSE
SELECT non_negative_derivative('/value[1,4]/') from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: non_negative_derivative('/value[1,4]/'::text)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select non_negative_derivative(regex) (stub function, result)
--Testcase 209:
SELECT non_negative_derivative('/value[1,4]/') from s3;
ERROR:  stub non_negative_derivative(text) is called
CONTEXT:  PL/pgSQL function non_negative_derivative(text) line 3 at RAISE
-- select non_negative_derivative(*) (stub function and group by tag only) (explain)
--Testcase 210:
EXPLAIN VERBOSE
SELECT non_negative_derivative_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (non_negative_derivative_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT non_negative_derivative(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select non_negative_derivative(*) (stub function and group by tag only) (result)
--Testcase 211:
SELECT non_negative_derivative_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                non_negative_derivative_all                                                
---------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.1\",\"value2\" : \"0\",\"value3\" : null,\"value4\" : \"0\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.09999999999999998\",\"value2\" : \"0\",\"value3\" : null,\"value4\" : \"0\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1.1\",\"value2\" : \"0\",\"value3\" : null,\"value4\" : \"0\" }")
(3 rows)

-- select non_negative_derivative(regex) (stub function and group by tag only) (explain)
--Testcase 212:
EXPLAIN VERBOSE
SELECT non_negative_derivative('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (non_negative_derivative('/value[1,4]/'::text)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT non_negative_derivative(/value[1,4]/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select non_negative_derivative(regex) (stub agg function and group by tag only) (result)
--Testcase 213:
SELECT non_negative_derivative('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                               non_negative_derivative                                
--------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.1\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.09999999999999998\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1.1\",\"value4\" : \"0\" }")
(3 rows)

-- select non_negative_derivative(*) (stub function, expose data, explain)
--Testcase 214:
EXPLAIN VERBOSE
SELECT (non_negative_derivative_all()::s3).* from s3;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((non_negative_derivative_all())::s3)."time", ((non_negative_derivative_all())::s3).tags, ((non_negative_derivative_all())::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select non_negative_derivative(*) (stub agg function, expose data, result)
--Testcase 215:
SELECT (non_negative_derivative_all()::s3).* from s3;
ERROR:  stub non_negative_derivative_all() is called
CONTEXT:  PL/pgSQL function non_negative_derivative_all() line 3 at RAISE
-- select non_negative_derivative(regex) (stub function, expose data, explain)
--Testcase 216:
EXPLAIN VERBOSE
SELECT (non_negative_derivative('/value[1,4]/')::s3).* from s3;
                                                                                            QUERY PLAN                                                                                            
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((non_negative_derivative('/value[1,4]/'::text))::s3)."time", ((non_negative_derivative('/value[1,4]/'::text))::s3).tags, ((non_negative_derivative('/value[1,4]/'::text))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select non_negative_derivative(regex) (stub agg function, expose data, result)
--Testcase 217:
SELECT (non_negative_derivative('/value[1,4]/')::s3).* from s3;
ERROR:  stub non_negative_derivative(text) is called
CONTEXT:  PL/pgSQL function non_negative_derivative(text) line 3 at RAISE
--Testcase 218:
EXPLAIN VERBOSE
SELECT difference((fields->>'value1')::float),difference((fields->>'value2')::bigint),difference((fields->>'value3')::float),difference((fields->>'value4')::bigint) FROM s3;
                                                                                                                QUERY PLAN                                                                                                                
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: difference(((fields ->> 'value1'::text))::double precision), difference(((fields ->> 'value2'::text))::bigint), difference(((fields ->> 'value3'::text))::double precision), difference(((fields ->> 'value4'::text))::bigint)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 219:
SELECT difference((fields->>'value1')::float),difference((fields->>'value2')::bigint),difference((fields->>'value3')::float),difference((fields->>'value4')::bigint) FROM s3;
ERROR:  stub difference(float8) is called
CONTEXT:  PL/pgSQL function difference(double precision) line 3 at RAISE
-- select difference(*) (stub function, explain)
--Testcase 220:
EXPLAIN VERBOSE
SELECT difference_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: difference_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select difference(*) (stub function, result)
--Testcase 221:
SELECT difference_all() from s3;
ERROR:  stub difference_all() is called
CONTEXT:  PL/pgSQL function difference_all() line 3 at RAISE
-- select difference(regex) (stub function, explain)
--Testcase 222:
EXPLAIN VERBOSE
SELECT difference('/value[1,4]/') from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: difference('/value[1,4]/'::text)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select difference(regex) (stub function, result)
--Testcase 223:
SELECT difference('/value[1,4]/') from s3;
ERROR:  stub difference(text) is called
CONTEXT:  PL/pgSQL function difference(text) line 3 at RAISE
-- select difference(*) (stub agg function and group by tag only) (explain)
--Testcase 224:
EXPLAIN VERBOSE
SELECT difference_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (difference_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT difference(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select difference(*) (stub agg function and group by tag only) (result)
--Testcase 225:
SELECT difference_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                difference_all                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.1\",\"value2\" : \"0\",\"value3\" : \"-0.1\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.09999999999999998\",\"value2\" : \"0\",\"value3\" : \"-0.09999999999999998\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1.1\",\"value2\" : \"0\",\"value3\" : \"-1.1\",\"value4\" : \"0\" }")
(3 rows)

-- select difference(regex) (stub agg function and group by tag only) (explain)
--Testcase 226:
EXPLAIN VERBOSE
SELECT difference('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (difference('/value[1,4]/'::text)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT difference(/value[1,4]/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select difference(regex) (stub agg function and group by tag only) (result)
--Testcase 227:
SELECT difference('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                      difference                                      
--------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.1\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.09999999999999998\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1.1\",\"value4\" : \"0\" }")
(3 rows)

-- select difference(*) (stub function, expose data, explain)
--Testcase 228:
EXPLAIN VERBOSE
SELECT (difference_all()::s3).* from s3;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((difference_all())::s3)."time", ((difference_all())::s3).tags, ((difference_all())::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select difference(*) (stub function, expose data, result)
--Testcase 229:
SELECT (difference_all()::s3).* from s3;
ERROR:  stub difference_all() is called
CONTEXT:  PL/pgSQL function difference_all() line 3 at RAISE
-- select difference(regex) (stub function, expose data, explain)
--Testcase 230:
EXPLAIN VERBOSE
SELECT (difference('/value[1,4]/')::s3).* from s3;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((difference('/value[1,4]/'::text))::s3)."time", ((difference('/value[1,4]/'::text))::s3).tags, ((difference('/value[1,4]/'::text))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select difference(regex) (stub function, expose data, result)
--Testcase 231:
SELECT (difference('/value[1,4]/')::s3).* from s3;
ERROR:  stub difference(text) is called
CONTEXT:  PL/pgSQL function difference(text) line 3 at RAISE
--Testcase 232:
EXPLAIN VERBOSE
SELECT non_negative_difference((fields->>'value1')::float),non_negative_difference((fields->>'value2')::bigint),non_negative_difference((fields->>'value3')::float),non_negative_difference((fields->>'value4')::bigint) FROM s3;
                                                                                                                                          QUERY PLAN                                                                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: non_negative_difference(((fields ->> 'value1'::text))::double precision), non_negative_difference(((fields ->> 'value2'::text))::bigint), non_negative_difference(((fields ->> 'value3'::text))::double precision), non_negative_difference(((fields ->> 'value4'::text))::bigint)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 233:
SELECT non_negative_difference((fields->>'value1')::float),non_negative_difference((fields->>'value2')::bigint),non_negative_difference((fields->>'value3')::float),non_negative_difference((fields->>'value4')::bigint) FROM s3;
ERROR:  stub non_negative_difference(float8) is called
CONTEXT:  PL/pgSQL function non_negative_difference(double precision) line 3 at RAISE
-- select non_negative_difference(*) (stub function, explain)
--Testcase 234:
EXPLAIN VERBOSE
SELECT non_negative_difference_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: non_negative_difference_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select non_negative_difference(*) (stub function, result)
--Testcase 235:
SELECT non_negative_difference_all() from s3;
ERROR:  stub non_negative_difference_all() is called
CONTEXT:  PL/pgSQL function non_negative_difference_all() line 3 at RAISE
-- select non_negative_difference(regex) (stub agg function, explain)
--Testcase 236:
EXPLAIN VERBOSE
SELECT non_negative_difference('/value[1,4]/') from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: non_negative_difference('/value[1,4]/'::text)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select non_negative_difference(*), non_negative_difference(regex) (stub function, result)
--Testcase 237:
SELECT non_negative_difference('/value[1,4]/') from s3;
ERROR:  stub non_negative_difference(text) is called
CONTEXT:  PL/pgSQL function non_negative_difference(text) line 3 at RAISE
-- select non_negative_difference(*) (stub function and group by tag only) (explain)
--Testcase 238:
EXPLAIN VERBOSE
SELECT non_negative_difference_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (non_negative_difference_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT non_negative_difference(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select non_negative_difference(*) (stub function and group by tag only) (result)
--Testcase 239:
SELECT non_negative_difference_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                non_negative_difference_all                                                
---------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.1\",\"value2\" : \"0\",\"value3\" : null,\"value4\" : \"0\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.09999999999999998\",\"value2\" : \"0\",\"value3\" : null,\"value4\" : \"0\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1.1\",\"value2\" : \"0\",\"value3\" : null,\"value4\" : \"0\" }")
(3 rows)

-- select non_negative_difference(regex) (stub function and group by tag only) (explain)
--Testcase 240:
EXPLAIN VERBOSE
SELECT non_negative_difference('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (non_negative_difference('/value[1,4]/'::text)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT non_negative_difference(/value[1,4]/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select non_negative_difference(regex) (stub function and group by tag only) (result)
--Testcase 241:
SELECT non_negative_difference('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                               non_negative_difference                                
--------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.1\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.09999999999999998\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1.1\",\"value4\" : \"0\" }")
(3 rows)

-- select non_negative_difference(*) (stub function, expose data, explain)
--Testcase 242:
EXPLAIN VERBOSE
SELECT (non_negative_difference_all()::s3).* from s3;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((non_negative_difference_all())::s3)."time", ((non_negative_difference_all())::s3).tags, ((non_negative_difference_all())::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select non_negative_difference(*) (stub function, expose data, result)
--Testcase 243:
SELECT (non_negative_difference_all()::s3).* from s3;
ERROR:  stub non_negative_difference_all() is called
CONTEXT:  PL/pgSQL function non_negative_difference_all() line 3 at RAISE
-- select non_negative_difference(regex) (stub function, expose data, explain)
--Testcase 244:
EXPLAIN VERBOSE
SELECT (non_negative_difference('/value[1,4]/')::s3).* from s3;
                                                                                            QUERY PLAN                                                                                            
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((non_negative_difference('/value[1,4]/'::text))::s3)."time", ((non_negative_difference('/value[1,4]/'::text))::s3).tags, ((non_negative_difference('/value[1,4]/'::text))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select non_negative_difference(regex) (stub function, expose data, result)
--Testcase 245:
SELECT (non_negative_difference('/value[1,4]/')::s3).* from s3;
ERROR:  stub non_negative_difference(text) is called
CONTEXT:  PL/pgSQL function non_negative_difference(text) line 3 at RAISE
--Testcase 246:
EXPLAIN VERBOSE
SELECT elapsed((fields->>'value1')::float),elapsed((fields->>'value2')::bigint),elapsed((fields->>'value3')::float),elapsed((fields->>'value4')::bigint) FROM s3;
                                                                                                          QUERY PLAN                                                                                                          
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: elapsed(((fields ->> 'value1'::text))::double precision), elapsed(((fields ->> 'value2'::text))::bigint), elapsed(((fields ->> 'value3'::text))::double precision), elapsed(((fields ->> 'value4'::text))::bigint)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 247:
SELECT elapsed((fields->>'value1')::float),elapsed((fields->>'value2')::bigint),elapsed((fields->>'value3')::float),elapsed((fields->>'value4')::bigint) FROM s3;
ERROR:  stub elapsed(anyelement) is called
CONTEXT:  PL/pgSQL function elapsed(anyelement) line 3 at RAISE
--Testcase 248:
EXPLAIN VERBOSE
SELECT elapsed((fields->>'value1')::float, interval '0.5s'),elapsed((fields->>'value2')::bigint, interval '0.2s'),elapsed((fields->>'value3')::float, interval '0.1s'),elapsed((fields->>'value4')::bigint, interval '2s') FROM s3;
                                                                                                                                                         QUERY PLAN                                                                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: elapsed(((fields ->> 'value1'::text))::double precision, '@ 0.5 secs'::interval), elapsed(((fields ->> 'value2'::text))::bigint, '@ 0.2 secs'::interval), elapsed(((fields ->> 'value3'::text))::double precision, '@ 0.1 secs'::interval), elapsed(((fields ->> 'value4'::text))::bigint, '@ 2 secs'::interval)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 249:
SELECT elapsed((fields->>'value1')::float, interval '0.5s'),elapsed((fields->>'value2')::bigint, interval '0.2s'),elapsed((fields->>'value3')::float, interval '0.1s'),elapsed((fields->>'value4')::bigint, interval '2s') FROM s3;
ERROR:  stub elapsed(anyelement, interval) is called
CONTEXT:  PL/pgSQL function elapsed(anyelement,interval) line 3 at RAISE
-- select elapsed(*) (stub function, explain)
--Testcase 250:
EXPLAIN VERBOSE
SELECT elapsed_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: elapsed_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select elapsed(*) (stub function, result)
--Testcase 251:
SELECT elapsed_all() from s3;
ERROR:  stub elapsed_all() is called
CONTEXT:  PL/pgSQL function elapsed_all() line 3 at RAISE
-- select elapsed(regex) (stub function, explain)
--Testcase 252:
EXPLAIN VERBOSE
SELECT elapsed('/value[1,4]/') from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: elapsed('/value[1,4]/'::text)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select elapsed(regex) (stub agg function, result)
--Testcase 253:
SELECT elapsed('/value[1,4]/') from s3;
ERROR:  stub elapsed(text) is called
CONTEXT:  PL/pgSQL function elapsed(text) line 3 at RAISE
-- select elapsed(*) (stub function and group by tag only) (explain)
--Testcase 254:
EXPLAIN VERBOSE
SELECT elapsed_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (elapsed_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT elapsed(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select elapsed(*) (stub function and group by tag only) (result)
--Testcase 255:
SELECT elapsed_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 elapsed_all                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"1000000000\",\"value2\" : \"1000000000\",\"value3\" : \"1000000000\",\"value4\" : \"1000000000\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"1000000000\",\"value2\" : \"1000000000\",\"value3\" : \"1000000000\",\"value4\" : \"1000000000\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1000000000\",\"value2\" : \"1000000000\",\"value3\" : \"1000000000\",\"value4\" : \"1000000000\" }")
(3 rows)

-- select elapsed(regex) (stub function and group by tag only) (explain)
--Testcase 256:
EXPLAIN VERBOSE
SELECT elapsed('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                        QUERY PLAN                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (elapsed('/value[1,4]/'::text)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT elapsed(/value[1,4]/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select elapsed(regex) (stub function and group by tag only) (result)
--Testcase 257:
SELECT elapsed('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                       elapsed                                        
--------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"1000000000\",\"value4\" : \"1000000000\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"1000000000\",\"value4\" : \"1000000000\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1000000000\",\"value4\" : \"1000000000\" }")
(3 rows)

-- select elapsed(*) (stub function, expose data, explain)
--Testcase 258:
EXPLAIN VERBOSE
SELECT (elapsed_all()::s3).* from s3;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((elapsed_all())::s3)."time", ((elapsed_all())::s3).tags, ((elapsed_all())::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select elapsed(*) (stub function, expose data, result)
--Testcase 259:
SELECT (elapsed_all()::s3).* from s3;
ERROR:  stub elapsed_all() is called
CONTEXT:  PL/pgSQL function elapsed_all() line 3 at RAISE
-- select elapsed(regex) (stub function, expose data, explain)
--Testcase 260:
EXPLAIN VERBOSE
SELECT (elapsed('/value[1,4]/')::s3).* from s3;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((elapsed('/value[1,4]/'::text))::s3)."time", ((elapsed('/value[1,4]/'::text))::s3).tags, ((elapsed('/value[1,4]/'::text))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select elapsed(regex) (stub agg function, expose data, result)
--Testcase 261:
SELECT (elapsed('/value[1,4]/')::s3).* from s3;
ERROR:  stub elapsed(text) is called
CONTEXT:  PL/pgSQL function elapsed(text) line 3 at RAISE
--Testcase 262:
EXPLAIN VERBOSE
SELECT moving_average((fields->>'value1')::float, 2),moving_average((fields->>'value2')::bigint, 2),moving_average((fields->>'value3')::float, 2),moving_average((fields->>'value4')::bigint, 2) FROM s3;
                                                                                                                              QUERY PLAN                                                                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: moving_average(((fields ->> 'value1'::text))::double precision, 2), moving_average(((fields ->> 'value2'::text))::bigint, 2), moving_average(((fields ->> 'value3'::text))::double precision, 2), moving_average(((fields ->> 'value4'::text))::bigint, 2)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 263:
SELECT moving_average((fields->>'value1')::float, 2),moving_average((fields->>'value2')::bigint, 2),moving_average((fields->>'value3')::float, 2),moving_average((fields->>'value4')::bigint, 2) FROM s3;
ERROR:  stub moving_average(float8, int) is called
CONTEXT:  PL/pgSQL function moving_average(double precision,integer) line 3 at RAISE
-- select moving_average(*) (stub function, explain)
--Testcase 264:
EXPLAIN VERBOSE
SELECT moving_average_all(2) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: moving_average_all(2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select moving_average(*) (stub function, result)
--Testcase 265:
SELECT moving_average_all(2) from s3;
ERROR:  stub moving_average_all(int) is called
CONTEXT:  PL/pgSQL function moving_average_all(integer) line 3 at RAISE
-- select moving_average(regex) (stub function, explain)
--Testcase 266:
EXPLAIN VERBOSE
SELECT moving_average('/value[1,4]/', 2) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: moving_average('/value[1,4]/'::text, 2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select moving_average(regex) (stub function, result)
--Testcase 267:
SELECT moving_average('/value[1,4]/', 2) from s3;
ERROR:  stub moving_average(text, int) is called
CONTEXT:  PL/pgSQL function moving_average(text,integer) line 3 at RAISE
-- select moving_average(*) (stub function and group by tag only) (explain)
--Testcase 268:
EXPLAIN VERBOSE
SELECT moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (moving_average_all(2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT moving_average(*, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select moving_average(*) (stub function and group by tag only) (result)
--Testcase 269:
SELECT moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 moving_average_all                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.15000000000000002\",\"value2\" : \"100\",\"value3\" : \"-0.15000000000000002\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.25\",\"value2\" : \"100\",\"value3\" : \"-0.25\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1.6500000000000001\",\"value2\" : \"200\",\"value3\" : \"-1.6500000000000001\",\"value4\" : \"-200\" }")
(3 rows)

-- select moving_average(regex) (stub function and group by tag only) (explain)
--Testcase 270:
EXPLAIN VERBOSE
SELECT moving_average('/value[1,4]/', 2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (moving_average('/value[1,4]/'::text, 2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT moving_average(/value[1,4]/, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select moving_average(regex) (stub function and group by tag only) (result)
--Testcase 271:
SELECT moving_average('/value[1,4]/', 2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                     moving_average                                      
-----------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.15000000000000002\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.25\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1.6500000000000001\",\"value4\" : \"-200\" }")
(3 rows)

-- select moving_average(*) (stub function, expose data, explain)
--Testcase 272:
EXPLAIN VERBOSE
SELECT (moving_average_all(2)::s3).* from s3;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((moving_average_all(2))::s3)."time", ((moving_average_all(2))::s3).tags, ((moving_average_all(2))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select moving_average(*) (stub function, expose data, result)
--Testcase 273:
SELECT (moving_average_all(2)::s3).* from s3;
ERROR:  stub moving_average_all(int) is called
CONTEXT:  PL/pgSQL function moving_average_all(integer) line 3 at RAISE
-- select moving_average(regex) (stub function, expose data, explain)
--Testcase 274:
EXPLAIN VERBOSE
SELECT (moving_average('/value[1,4]/', 2)::s3).* from s3;
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((moving_average('/value[1,4]/'::text, 2))::s3)."time", ((moving_average('/value[1,4]/'::text, 2))::s3).tags, ((moving_average('/value[1,4]/'::text, 2))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select moving_average(regex) (stub function, expose data, result)
--Testcase 275:
SELECT (moving_average('/value[1,4]/', 2)::s3).* from s3;
ERROR:  stub moving_average(text, int) is called
CONTEXT:  PL/pgSQL function moving_average(text,integer) line 3 at RAISE
--Testcase 276:
EXPLAIN VERBOSE
SELECT chande_momentum_oscillator((fields->>'value1')::float, 2),chande_momentum_oscillator((fields->>'value2')::bigint, 2),chande_momentum_oscillator((fields->>'value3')::float, 2),chande_momentum_oscillator((fields->>'value4')::bigint, 2) FROM s3;
                                                                                                                                                      QUERY PLAN                                                                                                                                                      
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: chande_momentum_oscillator(((fields ->> 'value1'::text))::double precision, 2), chande_momentum_oscillator(((fields ->> 'value2'::text))::bigint, 2), chande_momentum_oscillator(((fields ->> 'value3'::text))::double precision, 2), chande_momentum_oscillator(((fields ->> 'value4'::text))::bigint, 2)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 277:
SELECT chande_momentum_oscillator((fields->>'value1')::float, 2),chande_momentum_oscillator((fields->>'value2')::bigint, 2),chande_momentum_oscillator((fields->>'value3')::float, 2),chande_momentum_oscillator((fields->>'value4')::bigint, 2) FROM s3;
ERROR:  stub chande_momentum_oscillator(float8, int) is called
CONTEXT:  PL/pgSQL function chande_momentum_oscillator(double precision,integer) line 3 at RAISE
--Testcase 278:
EXPLAIN VERBOSE
SELECT chande_momentum_oscillator((fields->>'value1')::float, 2, 2),chande_momentum_oscillator((fields->>'value2')::bigint, 2, 2),chande_momentum_oscillator((fields->>'value3')::float, 2, 2),chande_momentum_oscillator((fields->>'value4')::bigint, 2, 2) FROM s3;
                                                                                                                                                            QUERY PLAN                                                                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: chande_momentum_oscillator(((fields ->> 'value1'::text))::double precision, 2, 2), chande_momentum_oscillator(((fields ->> 'value2'::text))::bigint, 2, 2), chande_momentum_oscillator(((fields ->> 'value3'::text))::double precision, 2, 2), chande_momentum_oscillator(((fields ->> 'value4'::text))::bigint, 2, 2)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 279:
SELECT chande_momentum_oscillator((fields->>'value1')::float, 2, 2),chande_momentum_oscillator((fields->>'value2')::bigint, 2, 2),chande_momentum_oscillator((fields->>'value3')::float, 2, 2),chande_momentum_oscillator((fields->>'value4')::bigint, 2, 2) FROM s3;
ERROR:  stub chande_momentum_oscillator(float8, int, int) is called
CONTEXT:  PL/pgSQL function chande_momentum_oscillator(double precision,integer,integer) line 3 at RAISE
-- select chande_momentum_oscillator(*) (stub function, explain)
--Testcase 280:
EXPLAIN VERBOSE
SELECT chande_momentum_oscillator_all(2) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: chande_momentum_oscillator_all(2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select chande_momentum_oscillator(*) (stub function, result)
--Testcase 281:
SELECT chande_momentum_oscillator_all(2) from s3;
ERROR:  stub chande_momentum_oscillator_all(int) is called
CONTEXT:  PL/pgSQL function chande_momentum_oscillator_all(integer) line 3 at RAISE
-- select chande_momentum_oscillator(regex) (stub function, explain)
--Testcase 282:
EXPLAIN VERBOSE
SELECT chande_momentum_oscillator('/value[1,4]/',2) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: chande_momentum_oscillator('/value[1,4]/'::text, 2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select chande_momentum_oscillator(regex) (stub agg function, result)
--Testcase 283:
SELECT chande_momentum_oscillator('/value[1,4]/',2) from s3;
ERROR:  stub chande_momentum_oscillator(text, int) is called
CONTEXT:  PL/pgSQL function chande_momentum_oscillator(text,integer) line 3 at RAISE
-- select chande_momentum_oscillator(*) (stub function and group by tag only) (explain)
--Testcase 284:
EXPLAIN VERBOSE
SELECT chande_momentum_oscillator_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (chande_momentum_oscillator_all(2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT chande_momentum_oscillator(*, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select chande_momentum_oscillator(*) (stub agg function and group by tag only) (result)
--Testcase 285:
SELECT chande_momentum_oscillator_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                        chande_momentum_oscillator_all                                         
---------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"100\",\"value2\" : \"0\",\"value3\" : \"-100\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"100\",\"value2\" : \"0\",\"value3\" : \"-100\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"100\",\"value2\" : \"0\",\"value3\" : \"-100\",\"value4\" : \"0\" }")
(3 rows)

-- select chande_momentum_oscillator(regex) (stub agg function and group by tag only) (explain)
--Testcase 286:
EXPLAIN VERBOSE
SELECT chande_momentum_oscillator('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (chande_momentum_oscillator('/value[1,4]/'::text, 2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT chande_momentum_oscillator(/value[1,4]/, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select chande_momentum_oscillator(regex) (stub function and group by tag only) (result)
--Testcase 287:
SELECT chande_momentum_oscillator('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                      chande_momentum_oscillator                      
----------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"100\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"100\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"100\",\"value4\" : \"0\" }")
(3 rows)

-- select chande_momentum_oscillator(*) (stub agg function, expose data, explain)
--Testcase 288:
EXPLAIN VERBOSE
SELECT (chande_momentum_oscillator_all(2)::s3).* from s3;
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((chande_momentum_oscillator_all(2))::s3)."time", ((chande_momentum_oscillator_all(2))::s3).tags, ((chande_momentum_oscillator_all(2))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select chande_momentum_oscillator(*) (stub function, expose data, result)
--Testcase 289:
SELECT (chande_momentum_oscillator_all(2)::s3).* from s3;
ERROR:  stub chande_momentum_oscillator_all(int) is called
CONTEXT:  PL/pgSQL function chande_momentum_oscillator_all(integer) line 3 at RAISE
-- select chande_momentum_oscillator(regex) (stub function, expose data, explain)
--Testcase 290:
EXPLAIN VERBOSE
SELECT (chande_momentum_oscillator('/value[1,4]/',2)::s3).* from s3;
                                                                                                     QUERY PLAN                                                                                                     
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((chande_momentum_oscillator('/value[1,4]/'::text, 2))::s3)."time", ((chande_momentum_oscillator('/value[1,4]/'::text, 2))::s3).tags, ((chande_momentum_oscillator('/value[1,4]/'::text, 2))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select chande_momentum_oscillator(regex) (stub function, expose data, result)
--Testcase 291:
SELECT (chande_momentum_oscillator('/value[1,4]/',2)::s3).* from s3;
ERROR:  stub chande_momentum_oscillator(text, int) is called
CONTEXT:  PL/pgSQL function chande_momentum_oscillator(text,integer) line 3 at RAISE
--Testcase 292:
EXPLAIN VERBOSE
SELECT exponential_moving_average((fields->>'value1')::float, 2),exponential_moving_average((fields->>'value2')::bigint, 2),exponential_moving_average((fields->>'value3')::float, 2),exponential_moving_average((fields->>'value4')::bigint, 2) FROM s3;
                                                                                                                                                      QUERY PLAN                                                                                                                                                      
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: exponential_moving_average(((fields ->> 'value1'::text))::double precision, 2), exponential_moving_average(((fields ->> 'value2'::text))::bigint, 2), exponential_moving_average(((fields ->> 'value3'::text))::double precision, 2), exponential_moving_average(((fields ->> 'value4'::text))::bigint, 2)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 293:
SELECT exponential_moving_average((fields->>'value1')::float, 2),exponential_moving_average((fields->>'value2')::bigint, 2),exponential_moving_average((fields->>'value3')::float, 2),exponential_moving_average((fields->>'value4')::bigint, 2) FROM s3;
ERROR:  stub exponential_moving_average(float8, int) is called
CONTEXT:  PL/pgSQL function exponential_moving_average(double precision,integer) line 3 at RAISE
--Testcase 294:
EXPLAIN VERBOSE
SELECT exponential_moving_average((fields->>'value1')::float, 2, 2),exponential_moving_average((fields->>'value2')::bigint, 2, 2),exponential_moving_average((fields->>'value3')::float, 2, 2),exponential_moving_average((fields->>'value4')::bigint, 2, 2) FROM s3;
                                                                                                                                                            QUERY PLAN                                                                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: exponential_moving_average(((fields ->> 'value1'::text))::double precision, 2, 2), exponential_moving_average(((fields ->> 'value2'::text))::bigint, 2, 2), exponential_moving_average(((fields ->> 'value3'::text))::double precision, 2, 2), exponential_moving_average(((fields ->> 'value4'::text))::bigint, 2, 2)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 295:
SELECT exponential_moving_average((fields->>'value1')::float, 2, 2),exponential_moving_average((fields->>'value2')::bigint, 2, 2),exponential_moving_average((fields->>'value3')::float, 2, 2),exponential_moving_average((fields->>'value4')::bigint, 2, 2) FROM s3;
ERROR:  stub exponential_moving_average(float8, int, int) is called
CONTEXT:  PL/pgSQL function exponential_moving_average(double precision,integer,integer) line 3 at RAISE
-- select exponential_moving_average(*) (stub function, explain)
--Testcase 296:
EXPLAIN VERBOSE
SELECT exponential_moving_average_all(2) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: exponential_moving_average_all(2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select exponential_moving_average(*) (stub function, result)
--Testcase 297:
SELECT exponential_moving_average_all(2) from s3;
ERROR:  stub exponential_moving_average_all(int) is called
CONTEXT:  PL/pgSQL function exponential_moving_average_all(integer) line 3 at RAISE
-- select exponential_moving_average(regex) (stub function, explain)
--Testcase 298:
EXPLAIN VERBOSE
SELECT exponential_moving_average('/value[1,4]/',2) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: exponential_moving_average('/value[1,4]/'::text, 2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select exponential_moving_average(regex) (stub function, result)
--Testcase 299:
SELECT exponential_moving_average('/value[1,4]/',2) from s3;
ERROR:  stub exponential_moving_average(text, int) is called
CONTEXT:  PL/pgSQL function exponential_moving_average(text,integer) line 3 at RAISE
-- select exponential_moving_average(*) (stub function and group by tag only) (explain)
--Testcase 300:
EXPLAIN VERBOSE
SELECT exponential_moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (exponential_moving_average_all(2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT exponential_moving_average(*, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select exponential_moving_average(*) (stub function and group by tag only) (result)
--Testcase 301:
SELECT exponential_moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                           exponential_moving_average_all                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.16666666666666669\",\"value2\" : \"100\",\"value3\" : \"-0.16666666666666669\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.25555555555555554\",\"value2\" : \"100\",\"value3\" : \"-0.25555555555555554\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1.8333333333333335\",\"value2\" : \"200\",\"value3\" : \"-1.8333333333333335\",\"value4\" : \"-200\" }")
(3 rows)

-- select exponential_moving_average(regex) (stub function and group by tag only) (explain)
--Testcase 302:
EXPLAIN VERBOSE
SELECT exponential_moving_average('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (exponential_moving_average('/value[1,4]/'::text, 2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT exponential_moving_average(/value[1,4]/, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select exponential_moving_average(regex) (stub function and group by tag only) (result)
--Testcase 303:
SELECT exponential_moving_average('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                               exponential_moving_average                                
-----------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.16666666666666669\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.25555555555555554\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1.8333333333333335\",\"value4\" : \"-200\" }")
(3 rows)

--Testcase 304:
EXPLAIN VERBOSE
SELECT double_exponential_moving_average((fields->>'value1')::float, 2),double_exponential_moving_average((fields->>'value2')::bigint, 2),double_exponential_moving_average((fields->>'value3')::float, 2),double_exponential_moving_average((fields->>'value4')::bigint, 2) FROM s3;
                                                                                                                                                                    QUERY PLAN                                                                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: double_exponential_moving_average(((fields ->> 'value1'::text))::double precision, 2), double_exponential_moving_average(((fields ->> 'value2'::text))::bigint, 2), double_exponential_moving_average(((fields ->> 'value3'::text))::double precision, 2), double_exponential_moving_average(((fields ->> 'value4'::text))::bigint, 2)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 305:
SELECT double_exponential_moving_average((fields->>'value1')::float, 2),double_exponential_moving_average((fields->>'value2')::bigint, 2),double_exponential_moving_average((fields->>'value3')::float, 2),double_exponential_moving_average((fields->>'value4')::bigint, 2) FROM s3;
ERROR:  stub double_exponential_moving_average(float8, int) is called
CONTEXT:  PL/pgSQL function double_exponential_moving_average(double precision,integer) line 3 at RAISE
--Testcase 306:
EXPLAIN VERBOSE
SELECT double_exponential_moving_average((fields->>'value1')::float, 2, 2),double_exponential_moving_average((fields->>'value2')::bigint, 2, 2),double_exponential_moving_average((fields->>'value3')::float, 2, 2),double_exponential_moving_average((fields->>'value4')::bigint, 2, 2) FROM s3;
                                                                                                                                                                          QUERY PLAN                                                                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: double_exponential_moving_average(((fields ->> 'value1'::text))::double precision, 2, 2), double_exponential_moving_average(((fields ->> 'value2'::text))::bigint, 2, 2), double_exponential_moving_average(((fields ->> 'value3'::text))::double precision, 2, 2), double_exponential_moving_average(((fields ->> 'value4'::text))::bigint, 2, 2)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 307:
SELECT double_exponential_moving_average((fields->>'value1')::float, 2, 2),double_exponential_moving_average((fields->>'value2')::bigint, 2, 2),double_exponential_moving_average((fields->>'value3')::float, 2, 2),double_exponential_moving_average((fields->>'value4')::bigint, 2, 2) FROM s3;
ERROR:  stub double_exponential_moving_average(float8, int, int) is called
CONTEXT:  PL/pgSQL function double_exponential_moving_average(double precision,integer,integer) line 3 at RAISE
-- select double_exponential_moving_average(*) (stub function, explain)
--Testcase 308:
EXPLAIN VERBOSE
SELECT double_exponential_moving_average_all(2) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: double_exponential_moving_average_all(2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select double_exponential_moving_average(*) (stub function, result)
--Testcase 309:
SELECT double_exponential_moving_average_all(2) from s3;
ERROR:  stub double_exponential_moving_average_all(int) is called
CONTEXT:  PL/pgSQL function double_exponential_moving_average_all(integer) line 3 at RAISE
-- select double_exponential_moving_average(regex) (stub function, explain)
--Testcase 310:
EXPLAIN VERBOSE
SELECT double_exponential_moving_average('/value[1,4]/',2) from s3;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: double_exponential_moving_average('/value[1,4]/'::text, 2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select double_exponential_moving_average(regex) (stub function, result)
--Testcase 311:
SELECT double_exponential_moving_average('/value[1,4]/',2) from s3;
ERROR:  stub double_exponential_moving_average(text, int) is called
CONTEXT:  PL/pgSQL function double_exponential_moving_average(text,integer) line 3 at RAISE
-- select double_exponential_moving_average(*) (stub function and group by tag only) (explain)
--Testcase 312:
EXPLAIN VERBOSE
SELECT double_exponential_moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                 QUERY PLAN                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (double_exponential_moving_average_all(2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT double_exponential_moving_average(*, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select double_exponential_moving_average(*) (stub function and group by tag only) (result)
--Testcase 313:
SELECT double_exponential_moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                       double_exponential_moving_average_all                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.1888888888888889\",\"value2\" : \"100\",\"value3\" : \"-0.1888888888888889\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.29259259259259257\",\"value2\" : \"100\",\"value3\" : \"-0.29259259259259257\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.077777777777778\",\"value2\" : \"200\",\"value3\" : \"-2.077777777777778\",\"value4\" : \"-200\" }")
(3 rows)

-- select double_exponential_moving_average(regex) (stub function and group by tag only) (explain)
--Testcase 314:
EXPLAIN VERBOSE
SELECT double_exponential_moving_average('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                      QUERY PLAN                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (double_exponential_moving_average('/value[1,4]/'::text, 2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT double_exponential_moving_average(/value[1,4]/, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select double_exponential_moving_average(regex) (stub function and group by tag only) (result)
--Testcase 315:
SELECT double_exponential_moving_average('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                            double_exponential_moving_average                            
-----------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.1888888888888889\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.29259259259259257\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.077777777777778\",\"value4\" : \"-200\" }")
(3 rows)

--Testcase 316:
EXPLAIN VERBOSE
SELECT kaufmans_efficiency_ratio((fields->>'value1')::float, 2),kaufmans_efficiency_ratio((fields->>'value2')::bigint, 2),kaufmans_efficiency_ratio((fields->>'value3')::float, 2),kaufmans_efficiency_ratio((fields->>'value4')::bigint, 2) FROM s3;
                                                                                                                                                    QUERY PLAN                                                                                                                                                    
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: kaufmans_efficiency_ratio(((fields ->> 'value1'::text))::double precision, 2), kaufmans_efficiency_ratio(((fields ->> 'value2'::text))::bigint, 2), kaufmans_efficiency_ratio(((fields ->> 'value3'::text))::double precision, 2), kaufmans_efficiency_ratio(((fields ->> 'value4'::text))::bigint, 2)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 317:
SELECT kaufmans_efficiency_ratio((fields->>'value1')::float, 2),kaufmans_efficiency_ratio((fields->>'value2')::bigint, 2),kaufmans_efficiency_ratio((fields->>'value3')::float, 2),kaufmans_efficiency_ratio((fields->>'value4')::bigint, 2) FROM s3;
ERROR:  stub kaufmans_efficiency_ratio(float8, int) is called
CONTEXT:  PL/pgSQL function kaufmans_efficiency_ratio(double precision,integer) line 3 at RAISE
--Testcase 318:
EXPLAIN VERBOSE
SELECT kaufmans_efficiency_ratio((fields->>'value1')::float, 2, 2),kaufmans_efficiency_ratio((fields->>'value2')::bigint, 2, 2),kaufmans_efficiency_ratio((fields->>'value3')::float, 2, 2),kaufmans_efficiency_ratio((fields->>'value4')::bigint, 2, 2) FROM s3;
                                                                                                                                                          QUERY PLAN                                                                                                                                                          
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: kaufmans_efficiency_ratio(((fields ->> 'value1'::text))::double precision, 2, 2), kaufmans_efficiency_ratio(((fields ->> 'value2'::text))::bigint, 2, 2), kaufmans_efficiency_ratio(((fields ->> 'value3'::text))::double precision, 2, 2), kaufmans_efficiency_ratio(((fields ->> 'value4'::text))::bigint, 2, 2)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 319:
SELECT kaufmans_efficiency_ratio((fields->>'value1')::float, 2, 2),kaufmans_efficiency_ratio((fields->>'value2')::bigint, 2, 2),kaufmans_efficiency_ratio((fields->>'value3')::float, 2, 2),kaufmans_efficiency_ratio((fields->>'value4')::bigint, 2, 2) FROM s3;
ERROR:  stub kaufmans_efficiency_ratio(float8, int, int) is called
CONTEXT:  PL/pgSQL function kaufmans_efficiency_ratio(double precision,integer,integer) line 3 at RAISE
-- select kaufmans_efficiency_ratio(*) (stub function, explain)
--Testcase 320:
EXPLAIN VERBOSE
SELECT kaufmans_efficiency_ratio_all(2) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: kaufmans_efficiency_ratio_all(2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select kaufmans_efficiency_ratio(*) (stub function, result)
--Testcase 321:
SELECT kaufmans_efficiency_ratio_all(2) from s3;
ERROR:  stub kaufmans_efficiency_ratio_all(int) is called
CONTEXT:  PL/pgSQL function kaufmans_efficiency_ratio_all(integer) line 3 at RAISE
-- select kaufmans_efficiency_ratio(regex) (stub function, explain)
--Testcase 322:
EXPLAIN VERBOSE
SELECT kaufmans_efficiency_ratio('/value[1,4]/',2) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select kaufmans_efficiency_ratio(regex) (stub function, result)
--Testcase 323:
SELECT kaufmans_efficiency_ratio('/value[1,4]/',2) from s3;
ERROR:  stub kaufmans_efficiency_ratio(text, int) is called
CONTEXT:  PL/pgSQL function kaufmans_efficiency_ratio(text,integer) line 3 at RAISE
-- select kaufmans_efficiency_ratio(*) (stub function and group by tag only) (explain)
--Testcase 324:
EXPLAIN VERBOSE
SELECT kaufmans_efficiency_ratio_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (kaufmans_efficiency_ratio_all(2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT kaufmans_efficiency_ratio(*, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select kaufmans_efficiency_ratio(*) (stub function and group by tag only) (result)
--Testcase 325:
SELECT kaufmans_efficiency_ratio_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                      kaufmans_efficiency_ratio_all                                       
----------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"1\",\"value2\" : \"0\",\"value3\" : \"1\",\"value4\" : \"0\" }")
(1 row)

-- select kaufmans_efficiency_ratio(regex) (stub function and group by tag only) (explain)
--Testcase 326:
EXPLAIN VERBOSE
SELECT kaufmans_efficiency_ratio('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT kaufmans_efficiency_ratio(/value[1,4]/, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select kaufmans_efficiency_ratio(regex) (stub function and group by tag only) (result)
--Testcase 327:
SELECT kaufmans_efficiency_ratio('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                     kaufmans_efficiency_ratio                      
--------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"1\",\"value4\" : \"0\" }")
(1 row)

-- select kaufmans_efficiency_ratio(*) (stub function, expose data, explain)
--Testcase 328:
EXPLAIN VERBOSE
SELECT (kaufmans_efficiency_ratio_all(2)::s3).* from s3;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((kaufmans_efficiency_ratio_all(2))::s3)."time", ((kaufmans_efficiency_ratio_all(2))::s3).tags, ((kaufmans_efficiency_ratio_all(2))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select kaufmans_efficiency_ratio(*) (stub function, expose data, result)
--Testcase 329:
SELECT (kaufmans_efficiency_ratio_all(2)::s3).* from s3;
ERROR:  stub kaufmans_efficiency_ratio_all(int) is called
CONTEXT:  PL/pgSQL function kaufmans_efficiency_ratio_all(integer) line 3 at RAISE
-- select kaufmans_efficiency_ratio(regex) (stub function, expose data, explain)
--Testcase 330:
EXPLAIN VERBOSE
SELECT (kaufmans_efficiency_ratio('/value[1,4]/',2)::s3).* from s3;
                                                                                                   QUERY PLAN                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2))::s3)."time", ((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2))::s3).tags, ((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select kaufmans_efficiency_ratio(regex) (stub function, expose data, result)
--Testcase 331:
SELECT (kaufmans_efficiency_ratio('/value[1,4]/',2)::s3).* from s3;
ERROR:  stub kaufmans_efficiency_ratio(text, int) is called
CONTEXT:  PL/pgSQL function kaufmans_efficiency_ratio(text,integer) line 3 at RAISE
--Testcase 332:
EXPLAIN VERBOSE
SELECT kaufmans_adaptive_moving_average((fields->>'value1')::float, 2),kaufmans_adaptive_moving_average((fields->>'value2')::bigint, 2),kaufmans_adaptive_moving_average((fields->>'value3')::float, 2),kaufmans_adaptive_moving_average((fields->>'value4')::bigint, 2) FROM s3;
                                                                                                                                                                  QUERY PLAN                                                                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: kaufmans_adaptive_moving_average(((fields ->> 'value1'::text))::double precision, 2), kaufmans_adaptive_moving_average(((fields ->> 'value2'::text))::bigint, 2), kaufmans_adaptive_moving_average(((fields ->> 'value3'::text))::double precision, 2), kaufmans_adaptive_moving_average(((fields ->> 'value4'::text))::bigint, 2)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 333:
SELECT kaufmans_adaptive_moving_average((fields->>'value1')::float, 2),kaufmans_adaptive_moving_average((fields->>'value2')::bigint, 2),kaufmans_adaptive_moving_average((fields->>'value3')::float, 2),kaufmans_adaptive_moving_average((fields->>'value4')::bigint, 2) FROM s3;
ERROR:  stub kaufmans_adaptive_moving_average(float8, int) is called
CONTEXT:  PL/pgSQL function kaufmans_adaptive_moving_average(double precision,integer) line 3 at RAISE
--Testcase 334:
EXPLAIN VERBOSE
SELECT kaufmans_adaptive_moving_average((fields->>'value1')::float, 2, 2),kaufmans_adaptive_moving_average((fields->>'value2')::bigint, 2, 2),kaufmans_adaptive_moving_average((fields->>'value3')::float, 2, 2),kaufmans_adaptive_moving_average((fields->>'value4')::bigint, 2, 2) FROM s3;
                                                                                                                                                                        QUERY PLAN                                                                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: kaufmans_adaptive_moving_average(((fields ->> 'value1'::text))::double precision, 2, 2), kaufmans_adaptive_moving_average(((fields ->> 'value2'::text))::bigint, 2, 2), kaufmans_adaptive_moving_average(((fields ->> 'value3'::text))::double precision, 2, 2), kaufmans_adaptive_moving_average(((fields ->> 'value4'::text))::bigint, 2, 2)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 335:
SELECT kaufmans_adaptive_moving_average((fields->>'value1')::float, 2, 2),kaufmans_adaptive_moving_average((fields->>'value2')::bigint, 2, 2),kaufmans_adaptive_moving_average((fields->>'value3')::float, 2, 2),kaufmans_adaptive_moving_average((fields->>'value4')::bigint, 2, 2) FROM s3;
ERROR:  stub kaufmans_adaptive_moving_average(float8, int, int) is called
CONTEXT:  PL/pgSQL function kaufmans_adaptive_moving_average(double precision,integer,integer) line 3 at RAISE
-- select kaufmans_adaptive_moving_average(*) (stub function, explain)
--Testcase 336:
EXPLAIN VERBOSE
SELECT kaufmans_adaptive_moving_average_all(2) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: kaufmans_adaptive_moving_average_all(2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select kaufmans_adaptive_moving_average(*) (stub function, result)
--Testcase 337:
SELECT kaufmans_adaptive_moving_average_all(2) from s3;
ERROR:  stub kaufmans_adaptive_moving_average_all(int) is called
CONTEXT:  PL/pgSQL function kaufmans_adaptive_moving_average_all(integer) line 3 at RAISE
-- select kaufmans_adaptive_moving_average(regex) (stub function, explain)
--Testcase 338:
EXPLAIN VERBOSE
SELECT kaufmans_adaptive_moving_average('/value[1,4]/',2) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: kaufmans_adaptive_moving_average('/value[1,4]/'::text, 2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select kaufmans_adaptive_moving_average(regex) (stub agg function, result)
--Testcase 339:
SELECT kaufmans_adaptive_moving_average('/value[1,4]/',2) from s3;
ERROR:  stub kaufmans_adaptive_moving_average(text, int) is called
CONTEXT:  PL/pgSQL function kaufmans_adaptive_moving_average(text,integer) line 3 at RAISE
-- select kaufmans_adaptive_moving_average(*) (stub function and group by tag only) (explain)
--Testcase 340:
EXPLAIN VERBOSE
SELECT kaufmans_adaptive_moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (kaufmans_adaptive_moving_average_all(2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT kaufmans_adaptive_moving_average(*, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select kaufmans_adaptive_moving_average(*) (stub function and group by tag only) (result)
--Testcase 341:
SELECT kaufmans_adaptive_moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                        kaufmans_adaptive_moving_average_all                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.24444444444444446\",\"value2\" : \"100\",\"value3\" : \"-0.24444444444444446\",\"value4\" : \"-100\" }")
(1 row)

-- select kaufmans_adaptive_moving_average(regex) (stub function and group by tag only) (explain)
--Testcase 342:
EXPLAIN VERBOSE
SELECT kaufmans_adaptive_moving_average('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                      QUERY PLAN                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (kaufmans_adaptive_moving_average('/value[1,4]/'::text, 2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT kaufmans_adaptive_moving_average(/value[1,4]/, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select kaufmans_adaptive_moving_average(regex) (stub function and group by tag only) (result)
--Testcase 343:
SELECT kaufmans_adaptive_moving_average('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                            kaufmans_adaptive_moving_average                             
-----------------------------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.24444444444444446\",\"value4\" : \"-100\" }")
(1 row)

--Testcase 344:
EXPLAIN VERBOSE
SELECT triple_exponential_moving_average((fields->>'value1')::float, 2),triple_exponential_moving_average((fields->>'value2')::bigint, 2),triple_exponential_moving_average((fields->>'value3')::float, 2),triple_exponential_moving_average((fields->>'value4')::bigint, 2) FROM s3;
                                                                                                                                                                    QUERY PLAN                                                                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: triple_exponential_moving_average(((fields ->> 'value1'::text))::double precision, 2), triple_exponential_moving_average(((fields ->> 'value2'::text))::bigint, 2), triple_exponential_moving_average(((fields ->> 'value3'::text))::double precision, 2), triple_exponential_moving_average(((fields ->> 'value4'::text))::bigint, 2)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 345:
SELECT triple_exponential_moving_average((fields->>'value1')::float, 2),triple_exponential_moving_average((fields->>'value2')::bigint, 2),triple_exponential_moving_average((fields->>'value3')::float, 2),triple_exponential_moving_average((fields->>'value4')::bigint, 2) FROM s3;
ERROR:  stub triple_exponential_moving_average(float8, int) is called
CONTEXT:  PL/pgSQL function triple_exponential_moving_average(double precision,integer) line 3 at RAISE
--Testcase 346:
EXPLAIN VERBOSE
SELECT triple_exponential_moving_average((fields->>'value1')::float, 2, 2),triple_exponential_moving_average((fields->>'value2')::bigint, 2, 2),triple_exponential_moving_average((fields->>'value3')::float, 2, 2),triple_exponential_moving_average((fields->>'value4')::bigint, 2, 2) FROM s3;
                                                                                                                                                                          QUERY PLAN                                                                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: triple_exponential_moving_average(((fields ->> 'value1'::text))::double precision, 2, 2), triple_exponential_moving_average(((fields ->> 'value2'::text))::bigint, 2, 2), triple_exponential_moving_average(((fields ->> 'value3'::text))::double precision, 2, 2), triple_exponential_moving_average(((fields ->> 'value4'::text))::bigint, 2, 2)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 347:
SELECT triple_exponential_moving_average((fields->>'value1')::float, 2, 2),triple_exponential_moving_average((fields->>'value2')::bigint, 2, 2),triple_exponential_moving_average((fields->>'value3')::float, 2, 2),triple_exponential_moving_average((fields->>'value4')::bigint, 2, 2) FROM s3;
ERROR:  stub triple_exponential_moving_average(float8, int, int) is called
CONTEXT:  PL/pgSQL function triple_exponential_moving_average(double precision,integer,integer) line 3 at RAISE
-- select triple_exponential_moving_average(*) (stub function, explain)
--Testcase 348:
EXPLAIN VERBOSE
SELECT triple_exponential_moving_average_all(2) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: triple_exponential_moving_average_all(2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select triple_exponential_moving_average(*) (stub function, result)
--Testcase 349:
SELECT triple_exponential_moving_average_all(2) from s3;
ERROR:  stub triple_exponential_moving_average_all(int) is called
CONTEXT:  PL/pgSQL function triple_exponential_moving_average_all(integer) line 3 at RAISE
-- select triple_exponential_moving_average(regex) (stub function, explain)
--Testcase 350:
EXPLAIN VERBOSE
SELECT triple_exponential_moving_average('/value[1,4]/',2) from s3;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: triple_exponential_moving_average('/value[1,4]/'::text, 2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select triple_exponential_moving_average(regex) (stub function, result)
--Testcase 351:
SELECT triple_exponential_moving_average('/value[1,4]/',2) from s3;
ERROR:  stub triple_exponential_moving_average(text, int) is called
CONTEXT:  PL/pgSQL function triple_exponential_moving_average(text,integer) line 3 at RAISE
-- select triple_exponential_moving_average(*) (stub function and group by tag only) (explain)
--Testcase 352:
EXPLAIN VERBOSE
SELECT triple_exponential_moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                 QUERY PLAN                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (triple_exponential_moving_average_all(2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT triple_exponential_moving_average(*, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select triple_exponential_moving_average(*) (stub function and group by tag only) (result)
--Testcase 353:
SELECT triple_exponential_moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                       triple_exponential_moving_average_all                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.1962962962962963\",\"value2\" : \"100\",\"value3\" : \"-0.1962962962962963\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.30000000000000004\",\"value2\" : \"100\",\"value3\" : \"-0.30000000000000004\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.1592592592592585\",\"value2\" : \"200\",\"value3\" : \"-2.1592592592592585\",\"value4\" : \"-200\" }")
(3 rows)

-- select triple_exponential_moving_average(regex) (stub agg function and group by tag only) (explain)
--Testcase 354:
EXPLAIN VERBOSE
SELECT triple_exponential_moving_average('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                      QUERY PLAN                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (triple_exponential_moving_average('/value[1,4]/'::text, 2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT triple_exponential_moving_average(/value[1,4]/, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select triple_exponential_moving_average(regex) (stub agg function and group by tag only) (result)
--Testcase 355:
SELECT triple_exponential_moving_average('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                            triple_exponential_moving_average                            
-----------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.1962962962962963\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.30000000000000004\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.1592592592592585\",\"value4\" : \"-200\" }")
(3 rows)

--Testcase 356:
EXPLAIN VERBOSE
SELECT triple_exponential_derivative((fields->>'value1')::float, 2),triple_exponential_derivative((fields->>'value2')::bigint, 2),triple_exponential_derivative((fields->>'value3')::float, 2),triple_exponential_derivative((fields->>'value4')::bigint, 2) FROM s3;
                                                                                                                                                            QUERY PLAN                                                                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: triple_exponential_derivative(((fields ->> 'value1'::text))::double precision, 2), triple_exponential_derivative(((fields ->> 'value2'::text))::bigint, 2), triple_exponential_derivative(((fields ->> 'value3'::text))::double precision, 2), triple_exponential_derivative(((fields ->> 'value4'::text))::bigint, 2)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 357:
SELECT triple_exponential_derivative((fields->>'value1')::float, 2),triple_exponential_derivative((fields->>'value2')::bigint, 2),triple_exponential_derivative((fields->>'value3')::float, 2),triple_exponential_derivative((fields->>'value4')::bigint, 2) FROM s3;
ERROR:  stub triple_exponential_derivative(float8, int) is called
CONTEXT:  PL/pgSQL function triple_exponential_derivative(double precision,integer) line 3 at RAISE
--Testcase 358:
EXPLAIN VERBOSE
SELECT triple_exponential_derivative((fields->>'value1')::float, 2, 2),triple_exponential_derivative((fields->>'value2')::bigint, 2, 2),triple_exponential_derivative((fields->>'value3')::float, 2, 2),triple_exponential_derivative((fields->>'value4')::bigint, 2, 2) FROM s3;
                                                                                                                                                                  QUERY PLAN                                                                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: triple_exponential_derivative(((fields ->> 'value1'::text))::double precision, 2, 2), triple_exponential_derivative(((fields ->> 'value2'::text))::bigint, 2, 2), triple_exponential_derivative(((fields ->> 'value3'::text))::double precision, 2, 2), triple_exponential_derivative(((fields ->> 'value4'::text))::bigint, 2, 2)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 359:
SELECT triple_exponential_derivative((fields->>'value1')::float, 2, 2),triple_exponential_derivative((fields->>'value2')::bigint, 2, 2),triple_exponential_derivative((fields->>'value3')::float, 2, 2),triple_exponential_derivative((fields->>'value4')::bigint, 2, 2) FROM s3;
ERROR:  stub triple_exponential_derivative(float8, int, int) is called
CONTEXT:  PL/pgSQL function triple_exponential_derivative(double precision,integer,integer) line 3 at RAISE
-- select triple_exponential_derivative(*) (stub function, explain)
--Testcase 360:
EXPLAIN VERBOSE
SELECT triple_exponential_derivative_all(2) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: triple_exponential_derivative_all(2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select triple_exponential_derivative(*) (stub function, result)
--Testcase 361:
SELECT triple_exponential_derivative_all(2) from s3;
ERROR:  stub triple_exponential_derivative_all(int) is called
CONTEXT:  PL/pgSQL function triple_exponential_derivative_all(integer) line 3 at RAISE
-- select triple_exponential_derivative(regex) (stub function, explain)
--Testcase 362:
EXPLAIN VERBOSE
SELECT triple_exponential_derivative('/value[1,4]/',2) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: triple_exponential_derivative('/value[1,4]/'::text, 2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select triple_exponential_derivative(regex) (stub function, result)
--Testcase 363:
SELECT triple_exponential_derivative('/value[1,4]/',2) from s3;
ERROR:  stub triple_exponential_derivative(text, int) is called
CONTEXT:  PL/pgSQL function triple_exponential_derivative(text,integer) line 3 at RAISE
-- select triple_exponential_derivative(*) (stub function and group by tag only) (explain)
--Testcase 364:
EXPLAIN VERBOSE
SELECT triple_exponential_derivative_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                               QUERY PLAN                                                                               
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (triple_exponential_derivative_all(2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT triple_exponential_derivative(*, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select triple_exponential_derivative(*) (stub function and group by tag only) (result)
--Testcase 365:
SELECT triple_exponential_derivative_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                    triple_exponential_derivative_all                                                     
------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"45.71428571428569\",\"value2\" : \"0\",\"value3\" : \"45.71428571428569\",\"value4\" : \"0\" }")
(1 row)

-- select triple_exponential_derivative(regex) (stub function and group by tag only) (explain)
--Testcase 366:
EXPLAIN VERBOSE
SELECT triple_exponential_derivative('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (triple_exponential_derivative('/value[1,4]/'::text, 2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT triple_exponential_derivative(/value[1,4]/, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select triple_exponential_derivative(regex) (stub function and group by tag only) (result)
--Testcase 367:
SELECT triple_exponential_derivative('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                           triple_exponential_derivative                            
------------------------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"45.71428571428569\",\"value4\" : \"0\" }")
(1 row)

--Testcase 368:
EXPLAIN VERBOSE
SELECT relative_strength_index((fields->>'value1')::float, 2),relative_strength_index((fields->>'value2')::bigint, 2),relative_strength_index((fields->>'value3')::float, 2),relative_strength_index((fields->>'value4')::bigint, 2) FROM s3;
                                                                                                                                                QUERY PLAN                                                                                                                                                
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: relative_strength_index(((fields ->> 'value1'::text))::double precision, 2), relative_strength_index(((fields ->> 'value2'::text))::bigint, 2), relative_strength_index(((fields ->> 'value3'::text))::double precision, 2), relative_strength_index(((fields ->> 'value4'::text))::bigint, 2)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 369:
SELECT relative_strength_index((fields->>'value1')::float, 2),relative_strength_index((fields->>'value2')::bigint, 2),relative_strength_index((fields->>'value3')::float, 2),relative_strength_index((fields->>'value4')::bigint, 2) FROM s3;
ERROR:  stub relative_strength_index(float8, int) is called
CONTEXT:  PL/pgSQL function relative_strength_index(double precision,integer) line 3 at RAISE
--Testcase 370:
EXPLAIN VERBOSE
SELECT relative_strength_index((fields->>'value1')::float, 2, 2),relative_strength_index((fields->>'value2')::bigint, 2, 2),relative_strength_index((fields->>'value3')::float, 2, 2),relative_strength_index((fields->>'value4')::bigint, 2, 2) FROM s3;
                                                                                                                                                      QUERY PLAN                                                                                                                                                      
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: relative_strength_index(((fields ->> 'value1'::text))::double precision, 2, 2), relative_strength_index(((fields ->> 'value2'::text))::bigint, 2, 2), relative_strength_index(((fields ->> 'value3'::text))::double precision, 2, 2), relative_strength_index(((fields ->> 'value4'::text))::bigint, 2, 2)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

--Testcase 371:
SELECT relative_strength_index((fields->>'value1')::float, 2, 2),relative_strength_index((fields->>'value2')::bigint, 2, 2),relative_strength_index((fields->>'value3')::float, 2, 2),relative_strength_index((fields->>'value4')::bigint, 2, 2) FROM s3;
ERROR:  stub relative_strength_index(float8, int, int) is called
CONTEXT:  PL/pgSQL function relative_strength_index(double precision,integer,integer) line 3 at RAISE
-- select relative_strength_index(*) (stub function, explain)
--Testcase 372:
EXPLAIN VERBOSE
SELECT relative_strength_index_all(2) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: relative_strength_index_all(2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select relative_strength_index(*) (stub function, result)
--Testcase 373:
SELECT relative_strength_index_all(2) from s3;
ERROR:  stub relative_strength_index_all(int) is called
CONTEXT:  PL/pgSQL function relative_strength_index_all(integer) line 3 at RAISE
-- select relative_strength_index(regex) (stub agg function, explain)
--Testcase 374:
EXPLAIN VERBOSE
SELECT relative_strength_index('/value[1,4]/',2) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: relative_strength_index('/value[1,4]/'::text, 2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select relative_strength_index(regex) (stub agg function, result)
--Testcase 375:
SELECT relative_strength_index('/value[1,4]/',2) from s3;
ERROR:  stub relative_strength_index(text, int) is called
CONTEXT:  PL/pgSQL function relative_strength_index(text,integer) line 3 at RAISE
-- select relative_strength_index(*) (stub function and group by tag only) (explain)
--Testcase 376:
EXPLAIN VERBOSE
SELECT relative_strength_index_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (relative_strength_index_all(2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT relative_strength_index(*, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select relative_strength_index(*) (stub function and group by tag only) (result)
--Testcase 377:
SELECT relative_strength_index_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                         relative_strength_index_all                                          
--------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"100\",\"value2\" : \"100\",\"value3\" : \"0\",\"value4\" : \"0\" }")
(1 row)

-- select relative_strength_index(regex) (stub function and group by tag only) (explain)
--Testcase 378:
EXPLAIN VERBOSE
SELECT relative_strength_index('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (relative_strength_index('/value[1,4]/'::text, 2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT relative_strength_index(/value[1,4]/, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select relative_strength_index(regex) (stub function and group by tag only) (result)
--Testcase 379:
SELECT relative_strength_index('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                       relative_strength_index                        
----------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"100\",\"value4\" : \"0\" }")
(1 row)

-- select relative_strength_index(*) (stub function, expose data, explain)
--Testcase 380:
EXPLAIN VERBOSE
SELECT (relative_strength_index_all(2)::s3).* from s3;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((relative_strength_index_all(2))::s3)."time", ((relative_strength_index_all(2))::s3).tags, ((relative_strength_index_all(2))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select relative_strength_index(*) (stub function, expose data, result)
--Testcase 381:
SELECT (relative_strength_index_all(2)::s3).* from s3;
ERROR:  stub relative_strength_index_all(int) is called
CONTEXT:  PL/pgSQL function relative_strength_index_all(integer) line 3 at RAISE
-- select relative_strength_index(regex) (stub function, expose data, explain)
--Testcase 382:
EXPLAIN VERBOSE
SELECT (relative_strength_index('/value[1,4]/',2)::s3).* from s3;
                                                                                                QUERY PLAN                                                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((relative_strength_index('/value[1,4]/'::text, 2))::s3)."time", ((relative_strength_index('/value[1,4]/'::text, 2))::s3).tags, ((relative_strength_index('/value[1,4]/'::text, 2))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select relative_strength_index(regex) (stub function, expose data, result)
--Testcase 383:
SELECT (relative_strength_index('/value[1,4]/',2)::s3).* from s3;
ERROR:  stub relative_strength_index(text, int) is called
CONTEXT:  PL/pgSQL function relative_strength_index(text,integer) line 3 at RAISE
-- select integral (stub agg function, explain)
--Testcase 384:
EXPLAIN VERBOSE
SELECT integral((fields->>'value1')::float),integral((fields->>'value2')::bigint),integral((fields->>'value3')::float),integral((fields->>'value4')::bigint) FROM s3;
                                                                                                                QUERY PLAN                                                                                                                
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (integral(((fields ->> 'value1'::text))::double precision)), (integral(((fields ->> 'value2'::text))::bigint)), (integral(((fields ->> 'value3'::text))::double precision)), (integral(((fields ->> 'value4'::text))::bigint))
   InfluxDB query: SELECT integral("value1"), integral("value2"), integral("value3"), integral("value4") FROM "s3"
(3 rows)

-- select integral (stub agg function, result)
--Testcase 385:
SELECT integral((fields->>'value1')::float),integral((fields->>'value2')::bigint),integral((fields->>'value3')::float),integral((fields->>'value4')::bigint) FROM s3;
 integral | integral | integral | integral 
----------+----------+----------+----------
      5.5 |      750 |     -5.5 |     -750
(1 row)

--Testcase 386:
EXPLAIN VERBOSE
SELECT integral((fields->>'value1')::float, interval '1s'),integral((fields->>'value2')::bigint, interval '1s'),integral((fields->>'value3')::float, interval '1s'),integral((fields->>'value4')::bigint, interval '1s') FROM s3;
                                                                                                                                                          QUERY PLAN                                                                                                                                                          
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (integral(((fields ->> 'value1'::text))::double precision, '@ 1 sec'::interval)), (integral(((fields ->> 'value2'::text))::bigint, '@ 1 sec'::interval)), (integral(((fields ->> 'value3'::text))::double precision, '@ 1 sec'::interval)), (integral(((fields ->> 'value4'::text))::bigint, '@ 1 sec'::interval))
   InfluxDB query: SELECT integral("value1", 0d0h0m1s0u), integral("value2", 0d0h0m1s0u), integral("value3", 0d0h0m1s0u), integral("value4", 0d0h0m1s0u) FROM "s3"
(3 rows)

-- select integral (stub agg function, result)
--Testcase 387:
SELECT integral((fields->>'value1')::float, interval '1s'),integral((fields->>'value2')::bigint, interval '1s'),integral((fields->>'value3')::float, interval '1s'),integral((fields->>'value4')::bigint, interval '1s') FROM s3;
 integral | integral | integral | integral 
----------+----------+----------+----------
      5.5 |      750 |     -5.5 |     -750
(1 row)

-- select integral (stub agg function, raise exception if not expected type)
--Testcase 388:
SELECT integral((fields->>'value1')::numeric),integral((fields->>'value2')::numeric),integral((fields->>'value3')::numeric),integral((fields->>'value4')::numeric) FROM s3;
ERROR:  stub integral_sfunc(double precision, float8) is called
CONTEXT:  PL/pgSQL function integral_sfunc(double precision,double precision) line 3 at RAISE
-- select integral (stub agg function and group by influx_time() and tag) (explain)
--Testcase 389:
EXPLAIN VERBOSE
SELECT integral((fields->>'value1')::float),influx_time(time, interval '1s'),tags->>'tag1' tag1 FROM s3 GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=48)
   Output: (integral(((fields ->> 'value1'::text))::double precision)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT integral("value1") FROM "s3" GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select integral (stub agg function and group by influx_time() and tag) (result)
--Testcase 390:
SELECT integral((fields->>'value1')::float),influx_time(time, interval '1s'),tags->>'tag1' tag1 FROM s3 GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
      integral       |      influx_time       | tag1 
---------------------+------------------------+------
 0.15000000000000002 | 1970-01-01 09:00:00+09 | a
                0.25 | 1970-01-01 09:00:01+09 | a
  1.6500000000000001 | 1970-01-01 09:00:03+09 | b
                2.75 | 1970-01-01 09:00:04+09 | b
(4 rows)

-- select integral (stub agg function and group by influx_time() and tag) (explain)
--Testcase 391:
EXPLAIN VERBOSE
SELECT integral((fields->>'value1')::float, interval '1s'),influx_time(time, interval '1s'),tags->>'tag1' tag1 FROM s3 GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=48)
   Output: (integral(((fields ->> 'value1'::text))::double precision, '@ 1 sec'::interval)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT integral("value1", 0d0h0m1s0u) FROM "s3" GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select integral (stub agg function and group by influx_time() and tag) (result)
--Testcase 392:
SELECT integral((fields->>'value1')::float, interval '1s'),influx_time(time, interval '1s'),tags->>'tag1' tag1 FROM s3 GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
      integral       |      influx_time       | tag1 
---------------------+------------------------+------
 0.15000000000000002 | 1970-01-01 09:00:00+09 | a
                0.25 | 1970-01-01 09:00:01+09 | a
  1.6500000000000001 | 1970-01-01 09:00:03+09 | b
                2.75 | 1970-01-01 09:00:04+09 | b
(4 rows)

-- select integral (stub agg function and group by tag only) (result)
--Testcase 393:
SELECT tags->>'tag1' tag1,integral((fields->>'value1')::float) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1' ORDER BY 1;
 tag1 |      integral      
------+--------------------
 a    |                0.4
 b    | 1.6500000000000001
(2 rows)

-- select integral (stub agg function and other aggs) (result)
--Testcase 394:
SELECT sum((fields->>'value1')::float),integral((fields->>'value1')::float),count((fields->>'value1')::float) FROM s3;
        sum        | integral | count 
-------------------+----------+-------
 7.199999999999999 |      5.5 |     6
(1 row)

-- select integral (stub agg function and group by tag only) (result)
--Testcase 395:
SELECT tags->>'tag1' tag1,integral((fields->>'value1')::float, interval '1s') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1' ORDER BY 1;
 tag1 |      integral      
------+--------------------
 a    |                0.4
 b    | 1.6500000000000001
(2 rows)

-- select integral (stub agg function and other aggs) (result)
--Testcase 396:
SELECT sum((fields->>'value1')::float),integral((fields->>'value1')::float, interval '1s'),count((fields->>'value1')::float) FROM s3;
        sum        | integral | count 
-------------------+----------+-------
 7.199999999999999 |      5.5 |     6
(1 row)

-- select integral over join query (explain)
--Testcase 397:
EXPLAIN VERBOSE
SELECT integral((t1.fields->>'value1')::float), integral((t2.fields->>'value1')::float) FROM s3 t1 INNER JOIN s3 t2 ON ((t1.fields->>'value1')::float = (t2.fields->>'value1')::float) where (t1.fields->>'value1')::float = 0.1;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=39.87..39.88 rows=1 width=16)
   Output: integral(((t1.fields ->> 'value1'::text))::double precision), integral(((t2.fields ->> 'value1'::text))::double precision)
   ->  Nested Loop  (cost=20.00..14.63 rows=49 width=64)
         Output: t1.fields, t2.fields
         ->  Foreign Scan on public.s3 t1  (cost=10.00..7.00 rows=7 width=32)
               Output: t1."time", t1.tags, t1.fields
               InfluxDB query: SELECT * FROM "s3" WHERE (("value1" = 0.1))
         ->  Materialize  (cost=10.00..7.04 rows=7 width=32)
               Output: t2.fields
               ->  Foreign Scan on public.s3 t2  (cost=10.00..7.00 rows=7 width=32)
                     Output: t2.fields
                     InfluxDB query: SELECT * FROM "s3" WHERE (("value1" = 0.1))
(12 rows)

-- select integral over join query (result, stub call error)
--Testcase 398:
SELECT integral((t1.fields->>'value1')::float), integral((t2.fields->>'value1')::float) FROM s3 t1 INNER JOIN s3 t2 ON ((t1.fields->>'value1')::float = (t2.fields->>'value1')::float) where (t1.fields->>'value1')::float = 0.1;
ERROR:  stub integral_sfunc(double precision, float8) is called
CONTEXT:  PL/pgSQL function integral_sfunc(double precision,double precision) line 3 at RAISE
-- select integral over join query (explain)
--Testcase 399:
EXPLAIN VERBOSE
SELECT integral((t1.fields->>'value1')::float, interval '1s'), integral((t2.fields->>'value1')::float, interval '1s') FROM s3 t1 INNER JOIN s3 t2 ON ((t1.fields->>'value1')::float = (t2.fields->>'value1')::float) where (t1.fields->>'value1')::float = 0.1;
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=39.87..39.88 rows=1 width=16)
   Output: integral(((t1.fields ->> 'value1'::text))::double precision, '@ 1 sec'::interval), integral(((t2.fields ->> 'value1'::text))::double precision, '@ 1 sec'::interval)
   ->  Nested Loop  (cost=20.00..14.63 rows=49 width=64)
         Output: t1.fields, t2.fields
         ->  Foreign Scan on public.s3 t1  (cost=10.00..7.00 rows=7 width=32)
               Output: t1."time", t1.tags, t1.fields
               InfluxDB query: SELECT * FROM "s3" WHERE (("value1" = 0.1))
         ->  Materialize  (cost=10.00..7.04 rows=7 width=32)
               Output: t2.fields
               ->  Foreign Scan on public.s3 t2  (cost=10.00..7.00 rows=7 width=32)
                     Output: t2.fields
                     InfluxDB query: SELECT * FROM "s3" WHERE (("value1" = 0.1))
(12 rows)

-- select integral over join query (result, stub call error)
--Testcase 400:
SELECT integral((t1.fields->>'value1')::float, interval '1s'), integral((t2.fields->>'value1')::float, interval '1s') FROM s3 t1 INNER JOIN s3 t2 ON ((t1.fields->>'value1')::float = (t2.fields->>'value1')::float) where (t1.fields->>'value1')::float = 0.1;
ERROR:  stub integral_sfunc(double precision, float8, interval) is called
CONTEXT:  PL/pgSQL function integral_sfunc(double precision,double precision,interval) line 3 at RAISE
-- select integral with having (explain)
--Testcase 401:
EXPLAIN VERBOSE
SELECT integral((fields->>'value1')::float) FROM s3 HAVING integral((fields->>'value1')::float) > 100;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Aggregate  (cost=2214.93..2214.94 rows=1 width=8)
   Output: integral(((fields ->> 'value1'::text))::double precision)
   Filter: (integral(((s3.fields ->> 'value1'::text))::double precision) > '100'::double precision)
   ->  Foreign Scan on public.s3  (cost=10.00..1462.00 rows=1462 width=32)
         Output: "time", tags, fields
         InfluxDB query: SELECT * FROM "s3"
(6 rows)

-- select integral with having (explain, not pushdown, stub call error)
--Testcase 402:
SELECT integral((fields->>'value1')::float) FROM s3 HAVING integral((fields->>'value1')::float) > 100;
ERROR:  stub integral_sfunc(double precision, float8) is called
CONTEXT:  PL/pgSQL function integral_sfunc(double precision,double precision) line 3 at RAISE
-- select integral with having (explain)
--Testcase 403:
EXPLAIN VERBOSE
SELECT integral((fields->>'value1')::float, interval '1s') FROM s3 HAVING integral((fields->>'value1')::float, interval '1s') > 100;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=2214.93..2214.94 rows=1 width=8)
   Output: integral(((fields ->> 'value1'::text))::double precision, '@ 1 sec'::interval)
   Filter: (integral(((s3.fields ->> 'value1'::text))::double precision, '@ 1 sec'::interval) > '100'::double precision)
   ->  Foreign Scan on public.s3  (cost=10.00..1462.00 rows=1462 width=32)
         Output: "time", tags, fields
         InfluxDB query: SELECT * FROM "s3"
(6 rows)

-- select integral with having (explain, not pushdown, stub call error)
--Testcase 404:
SELECT integral((fields->>'value1')::float, interval '1s') FROM s3 HAVING integral((fields->>'value1')::float, interval '1s') > 100;
ERROR:  stub integral_sfunc(double precision, float8, interval) is called
CONTEXT:  PL/pgSQL function integral_sfunc(double precision,double precision,interval) line 3 at RAISE
-- select integral(*) (stub agg function, explain)
--Testcase 405:
EXPLAIN VERBOSE
SELECT integral_all(*) from s3;
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (integral_all(*))
   InfluxDB query: SELECT integral(*) FROM "s3"
(3 rows)

-- select integral(*) (stub agg function, result)
--Testcase 406:
SELECT integral_all(*) from s3;
                                                    integral_all                                                    
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"5.5\",\"value2\" : \"750\",\"value3\" : \"-5.5\",\"value4\" : \"-750\" }")
(1 row)

-- select integral(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 407:
EXPLAIN VERBOSE
SELECT integral_all(*) FROM s3 GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (integral_all(*)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT integral(*) FROM "s3" GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select integral(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 408:
SELECT integral_all(*) FROM s3 GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                    integral_all                                                                    
----------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.15000000000000002\",\"value2\" : \"100\",\"value3\" : \"-0.15000000000000002\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.25\",\"value2\" : \"100\",\"value3\" : \"-0.25\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.6500000000000001\",\"value2\" : \"200\",\"value3\" : \"-1.6500000000000001\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.75\",\"value2\" : \"200\",\"value3\" : \"-2.75\",\"value4\" : \"-200\" }")
(4 rows)

-- select integral(*) (stub agg function and group by tag only) (explain)
--Testcase 409:
EXPLAIN VERBOSE
SELECT integral_all(*) FROM s3 WHERE (fields->>'value1')::float > 0.3 GROUP BY tags->>'tag1';
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (integral_all(*)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT integral(*) FROM "s3" WHERE (("value1" > 0.3)) GROUP BY ("tag1")
(3 rows)

-- select integral(*) (stub agg function and group by tag only) (result)
--Testcase 410:
SELECT integral_all(*) FROM s3 WHERE (fields->>'value1')::float > 0.3 GROUP BY tags->>'tag1';
                                                    integral_all                                                    
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"4.4\",\"value2\" : \"400\",\"value3\" : \"-4.4\",\"value4\" : \"-400\" }")
(1 row)

-- select integral(*) (stub agg function, expose data, explain)
--Testcase 411:
EXPLAIN VERBOSE
SELECT (integral_all(*)::s3).* from s3;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((integral_all(*)))::s3)."time", (((integral_all(*)))::s3).tags, (((integral_all(*)))::s3).fields
   InfluxDB query: SELECT integral(*) FROM "s3"
(3 rows)

-- select integral(*) (stub agg function, expose data, result)
--Testcase 412:
SELECT (integral_all(*)::s3).* from s3;
          time          | tags |                                 fields                                 
------------------------+------+------------------------------------------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "5.5", "value2": "750", "value3": "-5.5", "value4": "-750"}
(1 row)

-- select integral(regex) (stub agg function, explain)
--Testcase 413:
EXPLAIN VERBOSE
SELECT integral('/value[1,4]/') from s3;
                        QUERY PLAN                         
-----------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (integral('/value[1,4]/'::text))
   InfluxDB query: SELECT integral(/value[1,4]/) FROM "s3"
(3 rows)

-- select integral(regex) (stub agg function, result)
--Testcase 414:
SELECT integral('/value[1,4]/') from s3;
                                integral                                 
-------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"5.5\",\"value4\" : \"-750\" }")
(1 row)

-- select integral(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 415:
EXPLAIN VERBOSE
SELECT integral('/^v.*/') FROM s3 GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (integral('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT integral(/^v.*/) FROM "s3" GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select integral(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 416:
SELECT integral('/^v.*/') FROM s3 GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                      integral                                                                      
----------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.15000000000000002\",\"value2\" : \"100\",\"value3\" : \"-0.15000000000000002\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.25\",\"value2\" : \"100\",\"value3\" : \"-0.25\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.6500000000000001\",\"value2\" : \"200\",\"value3\" : \"-1.6500000000000001\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.75\",\"value2\" : \"200\",\"value3\" : \"-2.75\",\"value4\" : \"-200\" }")
(4 rows)

-- select integral(regex) (stub agg function and group by tag only) (explain)
--Testcase 417:
EXPLAIN VERBOSE
SELECT integral('/value[1,4]/') FROM s3 WHERE (fields->>'value1')::float > 0.3 GROUP BY tags->>'tag1';
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (integral('/value[1,4]/'::text)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT integral(/value[1,4]/) FROM "s3" WHERE (("value1" > 0.3)) GROUP BY ("tag1")
(3 rows)

-- select integral(regex) (stub agg function and group by tag only) (result)
--Testcase 418:
SELECT integral('/value[1,4]/') FROM s3 WHERE (fields->>'value1')::float > 0.3 GROUP BY tags->>'tag1';
                                integral                                 
-------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"4.4\",\"value4\" : \"-400\" }")
(1 row)

-- select integral(regex) (stub agg function, expose data, explain)
--Testcase 419:
EXPLAIN VERBOSE
SELECT (integral('/value[1,4]/')::s3).* from s3;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((integral('/value[1,4]/'::text)))::s3)."time", (((integral('/value[1,4]/'::text)))::s3).tags, (((integral('/value[1,4]/'::text)))::s3).fields
   InfluxDB query: SELECT integral(/value[1,4]/) FROM "s3"
(3 rows)

-- select integral(regex) (stub agg function, expose data, result)
--Testcase 420:
SELECT (integral('/value[1,4]/')::s3).* from s3;
          time          | tags |               fields                
------------------------+------+-------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "5.5", "value4": "-750"}
(1 row)

-- select mean (stub agg function, explain)
--Testcase 421:
EXPLAIN VERBOSE
SELECT mean((fields->>'value1')::float),mean((fields->>'value2')::bigint),mean((fields->>'value3')::float),mean((fields->>'value4')::bigint) FROM s3;
                                                                                                        QUERY PLAN                                                                                                        
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (mean(((fields ->> 'value1'::text))::double precision)), (mean(((fields ->> 'value2'::text))::bigint)), (mean(((fields ->> 'value3'::text))::double precision)), (mean(((fields ->> 'value4'::text))::bigint))
   InfluxDB query: SELECT mean("value1"), mean("value2"), mean("value3"), mean("value4") FROM "s3"
(3 rows)

-- select mean (stub agg function, result)
--Testcase 422:
SELECT mean((fields->>'value1')::float),mean((fields->>'value2')::bigint),mean((fields->>'value3')::float),mean((fields->>'value4')::bigint) FROM s3;
 mean | mean | mean | mean 
------+------+------+------
  1.2 |  150 | -1.2 | -150
(1 row)

-- select mean (stub agg function, raise exception if not expected type)
--Testcase 423:
SELECT mean((fields->>'value1')::numeric),mean((fields->>'value2')::numeric),mean((fields->>'value3')::numeric),mean((fields->>'value4')::numeric) FROM s3;
ERROR:  stub mean_sfunc(double precision, float8) is called
CONTEXT:  PL/pgSQL function mean_sfunc(double precision,double precision) line 3 at RAISE
-- select mean (stub agg function and group by influx_time() and tag) (explain)
--Testcase 424:
EXPLAIN VERBOSE
SELECT mean((fields->>'value1')::float),influx_time(time, interval '1s'),tags->>'tag1' tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=48)
   Output: (mean(((fields ->> 'value1'::text))::double precision)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT mean("value1") FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select mean (stub agg function and group by influx_time() and tag) (result)
--Testcase 425:
SELECT mean((fields->>'value1')::float),influx_time(time, interval '1s'),tags->>'tag1' tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
 mean |      influx_time       | tag1 
------+------------------------+------
  0.1 | 1970-01-01 09:00:00+09 | a
  0.2 | 1970-01-01 09:00:01+09 | a
  0.3 | 1970-01-01 09:00:02+09 | a
      | 1970-01-01 09:00:03+09 | a
      | 1970-01-01 09:00:04+09 | a
      | 1970-01-01 09:00:00+09 | b
      | 1970-01-01 09:00:01+09 | b
      | 1970-01-01 09:00:02+09 | b
  1.1 | 1970-01-01 09:00:03+09 | b
  2.2 | 1970-01-01 09:00:04+09 | b
(10 rows)

-- select mean (stub agg function and group by tag only) (result)
--Testcase 426:
SELECT tags->>'tag1' tag1,mean((fields->>'value1')::float) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
 tag1 |        mean         
------+---------------------
 a    | 0.20000000000000004
 b    |  1.6500000000000001
(2 rows)

-- select mean (stub agg function and other aggs) (result)
--Testcase 427:
SELECT sum((fields->>'value1')::float),mean((fields->>'value1')::float),count((fields->>'value1')::float) FROM s3;
        sum        | mean | count 
-------------------+------+-------
 7.199999999999999 |  1.2 |     6
(1 row)

-- select mean over join query (explain)
--Testcase 428:
EXPLAIN VERBOSE
SELECT mean((t1.fields->>'value1')::float), mean((t2.fields->>'value1')::float) FROM s3 t1 INNER JOIN s3 t2 ON ((t1.fields->>'value1')::float = (t2.fields->>'value1')::float) where (t1.fields->>'value1')::float = 0.1;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=39.87..39.88 rows=1 width=16)
   Output: mean(((t1.fields ->> 'value1'::text))::double precision), mean(((t2.fields ->> 'value1'::text))::double precision)
   ->  Nested Loop  (cost=20.00..14.63 rows=49 width=64)
         Output: t1.fields, t2.fields
         ->  Foreign Scan on public.s3 t1  (cost=10.00..7.00 rows=7 width=32)
               Output: t1."time", t1.tags, t1.fields
               InfluxDB query: SELECT * FROM "s3" WHERE (("value1" = 0.1))
         ->  Materialize  (cost=10.00..7.04 rows=7 width=32)
               Output: t2.fields
               ->  Foreign Scan on public.s3 t2  (cost=10.00..7.00 rows=7 width=32)
                     Output: t2.fields
                     InfluxDB query: SELECT * FROM "s3" WHERE (("value1" = 0.1))
(12 rows)

-- select mean over join query (result, stub call error)
--Testcase 429:
SELECT mean((t1.fields->>'value1')::float), mean((t2.fields->>'value1')::float) FROM s3 t1 INNER JOIN s3 t2 ON ((t1.fields->>'value1')::float = (t2.fields->>'value1')::float) where (t1.fields->>'value1')::float = 0.1;
ERROR:  stub mean_sfunc(double precision, float8) is called
CONTEXT:  PL/pgSQL function mean_sfunc(double precision,double precision) line 3 at RAISE
-- select mean with having (explain)
--Testcase 430:
EXPLAIN VERBOSE
SELECT mean((fields->>'value1')::float) FROM s3 HAVING mean((fields->>'value1')::float) > 100;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Aggregate  (cost=2214.93..2214.94 rows=1 width=8)
   Output: mean(((fields ->> 'value1'::text))::double precision)
   Filter: (mean(((s3.fields ->> 'value1'::text))::double precision) > '100'::double precision)
   ->  Foreign Scan on public.s3  (cost=10.00..1462.00 rows=1462 width=32)
         Output: "time", tags, fields
         InfluxDB query: SELECT * FROM "s3"
(6 rows)

-- select mean with having (explain, not pushdown, stub call error)
--Testcase 431:
SELECT mean((fields->>'value1')::float) FROM s3 HAVING mean((fields->>'value1')::float) > 100;
ERROR:  stub mean_sfunc(double precision, float8) is called
CONTEXT:  PL/pgSQL function mean_sfunc(double precision,double precision) line 3 at RAISE
-- select mean(*) (stub agg function, explain)
--Testcase 432:
EXPLAIN VERBOSE
SELECT mean_all(*) from s3;
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (mean_all(*))
   InfluxDB query: SELECT mean(*) FROM "s3"
(3 rows)

-- select mean(*) (stub agg function, result)
--Testcase 433:
SELECT mean_all(*) from s3;
                                                      mean_all                                                      
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.2\",\"value2\" : \"150\",\"value3\" : \"-1.2\",\"value4\" : \"-150\" }")
(1 row)

-- select mean(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 434:
EXPLAIN VERBOSE
SELECT mean_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (mean_all(*)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT mean(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select mean(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 435:
SELECT mean_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                      mean_all                                                      
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select mean(*) (stub agg function and group by tag only) (explain)
--Testcase 436:
EXPLAIN VERBOSE
SELECT mean_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (mean_all(*)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT mean(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select mean(*) (stub agg function and group by tag only) (result)
--Testcase 437:
SELECT mean_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                      mean_all                                                                      
----------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.20000000000000004\",\"value2\" : \"100\",\"value3\" : \"-0.20000000000000004\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.6500000000000001\",\"value2\" : \"200\",\"value3\" : \"-1.6500000000000001\",\"value4\" : \"-200\" }")
(2 rows)

-- select mean(*) (stub agg function, expose data, explain)
--Testcase 438:
EXPLAIN VERBOSE
SELECT (mean_all(*)::s3).* from s3;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((mean_all(*)))::s3)."time", (((mean_all(*)))::s3).tags, (((mean_all(*)))::s3).fields
   InfluxDB query: SELECT mean(*) FROM "s3"
(3 rows)

-- select mean(*) (stub agg function, expose data, result)
--Testcase 439:
SELECT (mean_all(*)::s3).* from s3;
          time          | tags |                                 fields                                 
------------------------+------+------------------------------------------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "1.2", "value2": "150", "value3": "-1.2", "value4": "-150"}
(1 row)

-- select mean(regex) (stub agg function, explain)
--Testcase 440:
EXPLAIN VERBOSE
SELECT mean('/value[1,4]/') from s3;
                      QUERY PLAN                       
-------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (mean('/value[1,4]/'::text))
   InfluxDB query: SELECT mean(/value[1,4]/) FROM "s3"
(3 rows)

-- select mean(regex) (stub agg function, result)
--Testcase 441:
SELECT mean('/value[1,4]/') from s3;
                                  mean                                   
-------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.2\",\"value4\" : \"-150\" }")
(1 row)

-- select mean(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 442:
EXPLAIN VERBOSE
SELECT mean('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (mean('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT mean(/^v.*/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select mean(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 443:
SELECT mean('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                        mean                                                        
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select mean(regex) (stub agg function and group by tag only) (explain)
--Testcase 444:
EXPLAIN VERBOSE
SELECT mean('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (mean('/value[1,4]/'::text)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT mean(/value[1,4]/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select mean(regex) (stub agg function and group by tag only) (result)
--Testcase 445:
SELECT mean('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                          mean                                           
-----------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.20000000000000004\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.6500000000000001\",\"value4\" : \"-200\" }")
(2 rows)

-- select mean(regex) (stub agg function, expose data, explain)
--Testcase 446:
EXPLAIN VERBOSE
SELECT (mean('/value[1,4]/')::s3).* from s3;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((mean('/value[1,4]/'::text)))::s3)."time", (((mean('/value[1,4]/'::text)))::s3).tags, (((mean('/value[1,4]/'::text)))::s3).fields
   InfluxDB query: SELECT mean(/value[1,4]/) FROM "s3"
(3 rows)

-- select mean(regex) (stub agg function, expose data, result)
--Testcase 447:
SELECT (mean('/value[1,4]/')::s3).* from s3;
          time          | tags |               fields                
------------------------+------+-------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "1.2", "value4": "-150"}
(1 row)

-- select median (stub agg function, explain)
--Testcase 448:
EXPLAIN VERBOSE
SELECT median((fields->>'value1')::float),median((fields->>'value2')::bigint),median((fields->>'value3')::float),median((fields->>'value4')::bigint) FROM s3;
                                                                                                            QUERY PLAN                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (median(((fields ->> 'value1'::text))::double precision)), (median(((fields ->> 'value2'::text))::bigint)), (median(((fields ->> 'value3'::text))::double precision)), (median(((fields ->> 'value4'::text))::bigint))
   InfluxDB query: SELECT median("value1"), median("value2"), median("value3"), median("value4") FROM "s3"
(3 rows)

-- select median (stub agg function, result)
--Testcase 449:
SELECT median((fields->>'value1')::float),median((fields->>'value2')::bigint),median((fields->>'value3')::float),median((fields->>'value4')::bigint) FROM s3;
 median | median |       median        | median 
--------+--------+---------------------+--------
    0.7 |    150 | -0.7000000000000001 |   -150
(1 row)

-- select median (stub agg function, raise exception if not expected type)
--Testcase 450:
SELECT median((fields->>'value1')::numeric),median((fields->>'value2')::numeric),median((fields->>'value3')::numeric),median((fields->>'value4')::numeric) FROM s3;
ERROR:  stub median_sfunc(double precision, float8) is called
CONTEXT:  PL/pgSQL function median_sfunc(double precision,double precision) line 3 at RAISE
-- select median (stub agg function and group by influx_time() and tag) (explain)
--Testcase 451:
EXPLAIN VERBOSE
SELECT median((fields->>'value1')::float),influx_time(time, interval '1s'),tags->>'tag1' tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=48)
   Output: (median(((fields ->> 'value1'::text))::double precision)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT median("value1") FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select median (stub agg function and group by influx_time() and tag) (result)
--Testcase 452:
SELECT median((fields->>'value1')::float),influx_time(time, interval '1s'),tags->>'tag1' tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
 median |      influx_time       | tag1 
--------+------------------------+------
    0.1 | 1970-01-01 09:00:00+09 | a
    0.2 | 1970-01-01 09:00:01+09 | a
    0.3 | 1970-01-01 09:00:02+09 | a
        | 1970-01-01 09:00:03+09 | a
        | 1970-01-01 09:00:04+09 | a
        | 1970-01-01 09:00:00+09 | b
        | 1970-01-01 09:00:01+09 | b
        | 1970-01-01 09:00:02+09 | b
    1.1 | 1970-01-01 09:00:03+09 | b
    2.2 | 1970-01-01 09:00:04+09 | b
(10 rows)

-- select median (stub agg function and group by tag only) (result)
--Testcase 453:
SELECT tags->>'tag1' tag1,median((fields->>'value1')::float) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
 tag1 |       median       
------+--------------------
 a    |                0.2
 b    | 1.6500000000000001
(2 rows)

-- select median (stub agg function and other aggs) (result)
--Testcase 454:
SELECT sum((fields->>'value1')::float),median((fields->>'value1')::float),count((fields->>'value1')::float) FROM s3;
        sum        | median | count 
-------------------+--------+-------
 7.199999999999999 |    0.7 |     6
(1 row)

-- select median over join query (explain)
--Testcase 455:
EXPLAIN VERBOSE
SELECT median((t1.fields->>'value1')::float), median((t2.fields->>'value1')::float) FROM s3 t1 INNER JOIN s3 t2 ON ((t1.fields->>'value1')::float = (t2.fields->>'value1')::float) where (t1.fields->>'value1')::float = 0.1;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=39.87..39.88 rows=1 width=16)
   Output: median(((t1.fields ->> 'value1'::text))::double precision), median(((t2.fields ->> 'value1'::text))::double precision)
   ->  Nested Loop  (cost=20.00..14.63 rows=49 width=64)
         Output: t1.fields, t2.fields
         ->  Foreign Scan on public.s3 t1  (cost=10.00..7.00 rows=7 width=32)
               Output: t1."time", t1.tags, t1.fields
               InfluxDB query: SELECT * FROM "s3" WHERE (("value1" = 0.1))
         ->  Materialize  (cost=10.00..7.04 rows=7 width=32)
               Output: t2.fields
               ->  Foreign Scan on public.s3 t2  (cost=10.00..7.00 rows=7 width=32)
                     Output: t2.fields
                     InfluxDB query: SELECT * FROM "s3" WHERE (("value1" = 0.1))
(12 rows)

-- select median over join query (result, stub call error)
--Testcase 456:
SELECT median((t1.fields->>'value1')::float), median((t2.fields->>'value1')::float) FROM s3 t1 INNER JOIN s3 t2 ON ((t1.fields->>'value1')::float = (t2.fields->>'value1')::float) where (t1.fields->>'value1')::float = 0.1;
ERROR:  stub median_sfunc(double precision, float8) is called
CONTEXT:  PL/pgSQL function median_sfunc(double precision,double precision) line 3 at RAISE
-- select median with having (explain)
--Testcase 457:
EXPLAIN VERBOSE
SELECT median((fields->>'value1')::float) FROM s3 HAVING median((fields->>'value1')::float) > 100;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Aggregate  (cost=2214.93..2214.94 rows=1 width=8)
   Output: median(((fields ->> 'value1'::text))::double precision)
   Filter: (median(((s3.fields ->> 'value1'::text))::double precision) > '100'::double precision)
   ->  Foreign Scan on public.s3  (cost=10.00..1462.00 rows=1462 width=32)
         Output: "time", tags, fields
         InfluxDB query: SELECT * FROM "s3"
(6 rows)

-- select median with having (explain, not pushdown, stub call error)
--Testcase 458:
SELECT median((fields->>'value1')::float) FROM s3 HAVING median((fields->>'value1')::float) > 100;
ERROR:  stub median_sfunc(double precision, float8) is called
CONTEXT:  PL/pgSQL function median_sfunc(double precision,double precision) line 3 at RAISE
-- select median(*) (stub agg function, explain)
--Testcase 459:
EXPLAIN VERBOSE
SELECT median_all(*) from s3;
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (median_all(*))
   InfluxDB query: SELECT median(*) FROM "s3"
(3 rows)

-- select median(*) (stub agg function, result)
--Testcase 460:
SELECT median_all(*) from s3;
                                                            median_all                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.7\",\"value2\" : \"150\",\"value3\" : \"-0.7000000000000001\",\"value4\" : \"-150\" }")
(1 row)

-- select median(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 461:
EXPLAIN VERBOSE
SELECT median_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (median_all(*)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT median(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select median(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 462:
SELECT median_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                     median_all                                                     
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select median(*) (stub agg function and group by tag only) (explain)
--Testcase 463:
EXPLAIN VERBOSE
SELECT median_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (median_all(*)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT median(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select median(*) (stub agg function and group by tag only) (result)
--Testcase 464:
SELECT median_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                    median_all                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.6500000000000001\",\"value2\" : \"200\",\"value3\" : \"-1.6500000000000001\",\"value4\" : \"-200\" }")
(2 rows)

-- select median(*) (stub agg function, expose data, explain)
--Testcase 465:
EXPLAIN VERBOSE
SELECT (median_all(*)::s3).* from s3;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((median_all(*)))::s3)."time", (((median_all(*)))::s3).tags, (((median_all(*)))::s3).fields
   InfluxDB query: SELECT median(*) FROM "s3"
(3 rows)

-- select median(*) (stub agg function, expose data, result)
--Testcase 466:
SELECT (median_all(*)::s3).* from s3;
          time          | tags |                                        fields                                         
------------------------+------+---------------------------------------------------------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "0.7", "value2": "150", "value3": "-0.7000000000000001", "value4": "-150"}
(1 row)

-- select median(regex) (stub agg function, explain)
--Testcase 467:
EXPLAIN VERBOSE
SELECT median('/^v.*/') from s3;
                    QUERY PLAN                     
---------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (median('/^v.*/'::text))
   InfluxDB query: SELECT median(/^v.*/) FROM "s3"
(3 rows)

-- select median(regex) (stub agg function, result)
--Testcase 468:
SELECT  median('/^v.*/') from s3;
                                                              median                                                               
-----------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.7\",\"value2\" : \"150\",\"value3\" : \"-0.7000000000000001\",\"value4\" : \"-150\" }")
(1 row)

-- select median(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 469:
EXPLAIN VERBOSE
SELECT median('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (median('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT median(/^v.*/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select median(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 470:
SELECT median('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                       median                                                       
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select median(regex) (stub agg function and group by tag only) (explain)
--Testcase 471:
EXPLAIN VERBOSE
SELECT median('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (median('/value[1,4]/'::text)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT median(/value[1,4]/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select median(regex) (stub agg function and group by tag only) (result)
--Testcase 472:
SELECT median('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                         median                                         
----------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.6500000000000001\",\"value4\" : \"-200\" }")
(2 rows)

-- select median(regex) (stub agg function, expose data, explain)
--Testcase 473:
EXPLAIN VERBOSE
SELECT (median('/value[1,4]/')::s3).* from s3;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((median('/value[1,4]/'::text)))::s3)."time", (((median('/value[1,4]/'::text)))::s3).tags, (((median('/value[1,4]/'::text)))::s3).fields
   InfluxDB query: SELECT median(/value[1,4]/) FROM "s3"
(3 rows)

-- select median(regex) (stub agg function, expose data, result)
--Testcase 474:
SELECT (median('/value[1,4]/')::s3).* from s3;
          time          | tags |               fields                
------------------------+------+-------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "0.7", "value4": "-150"}
(1 row)

-- select influx_mode (stub agg function, explain)
--Testcase 475:
EXPLAIN VERBOSE
SELECT influx_mode((fields->>'value1')::float),influx_mode((fields->>'value2')::bigint),influx_mode((fields->>'value3')::float),influx_mode((fields->>'value4')::bigint) FROM s3;
                                                                                                                      QUERY PLAN                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (influx_mode(((fields ->> 'value1'::text))::double precision)), (influx_mode(((fields ->> 'value2'::text))::bigint)), (influx_mode(((fields ->> 'value3'::text))::double precision)), (influx_mode(((fields ->> 'value4'::text))::bigint))
   InfluxDB query: SELECT mode("value1"), mode("value2"), mode("value3"), mode("value4") FROM "s3"
(3 rows)

-- select influx_mode (stub agg function, result)
--Testcase 476:
SELECT influx_mode((fields->>'value1')::float),influx_mode((fields->>'value2')::bigint),influx_mode((fields->>'value3')::float),influx_mode((fields->>'value4')::bigint) FROM s3;
 influx_mode | influx_mode | influx_mode | influx_mode 
-------------+-------------+-------------+-------------
         0.1 |         100 |        -3.3 |        -100
(1 row)

-- select influx_mode (stub agg function, raise exception if not expected type)
--Testcase 477:
SELECT influx_mode((fields->>'value1')::numeric),influx_mode((fields->>'value2')::numeric),influx_mode((fields->>'value3')::numeric),influx_mode((fields->>'value4')::numeric) FROM s3;
 influx_mode | influx_mode | influx_mode | influx_mode 
-------------+-------------+-------------+-------------
         0.1 |         100 |        -3.3 |        -100
(1 row)

-- select influx_mode (stub agg function and group by influx_time() and tag) (explain)
--Testcase 478:
EXPLAIN VERBOSE
SELECT influx_mode((fields->>'value1')::numeric),influx_time(time, interval '1s'),tags->>'tag1' tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (influx_mode(((fields ->> 'value1'::text))::numeric)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT mode("value1") FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select influx_mode (stub agg function and group by influx_time() and tag) (result)
--Testcase 479:
SELECT influx_mode((fields->>'value1')::numeric),influx_time(time, interval '1s'),tags->>'tag1' tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
 influx_mode |      influx_time       | tag1 
-------------+------------------------+------
         0.1 | 1970-01-01 09:00:00+09 | a
         0.2 | 1970-01-01 09:00:01+09 | a
         0.3 | 1970-01-01 09:00:02+09 | a
             | 1970-01-01 09:00:03+09 | a
             | 1970-01-01 09:00:04+09 | a
             | 1970-01-01 09:00:00+09 | b
             | 1970-01-01 09:00:01+09 | b
             | 1970-01-01 09:00:02+09 | b
         1.1 | 1970-01-01 09:00:03+09 | b
         2.2 | 1970-01-01 09:00:04+09 | b
(10 rows)

-- select influx_mode (stub agg function and group by tag only) (result)
--Testcase 480:
SELECT tags->>'tag1' tag1,influx_mode((fields->>'value1')::numeric) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
 tag1 | influx_mode 
------+-------------
 a    |         0.1
 b    |         1.1
(2 rows)

-- select influx_mode (stub agg function and other aggs) (result)
--Testcase 481:
SELECT sum((fields->>'value1')::float),influx_mode((fields->>'value1')::numeric),count((fields->>'value1')::float) FROM s3;
        sum        | influx_mode | count 
-------------------+-------------+-------
 7.199999999999999 |         0.1 |     6
(1 row)

-- select influx_mode over join query (explain)
--Testcase 482:
EXPLAIN VERBOSE
SELECT influx_mode((t1.fields->>'value1')::float), influx_mode((t2.fields->>'value1')::float) FROM s3 t1 INNER JOIN s3 t2 ON ((t1.fields->>'value1')::float = (t2.fields->>'value1')::float) where (t1.fields->>'value1')::float = 0.1;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=39.87..39.88 rows=1 width=16)
   Output: influx_mode(((t1.fields ->> 'value1'::text))::double precision), influx_mode(((t2.fields ->> 'value1'::text))::double precision)
   ->  Nested Loop  (cost=20.00..14.63 rows=49 width=64)
         Output: t1.fields, t2.fields
         ->  Foreign Scan on public.s3 t1  (cost=10.00..7.00 rows=7 width=32)
               Output: t1."time", t1.tags, t1.fields
               InfluxDB query: SELECT * FROM "s3" WHERE (("value1" = 0.1))
         ->  Materialize  (cost=10.00..7.04 rows=7 width=32)
               Output: t2.fields
               ->  Foreign Scan on public.s3 t2  (cost=10.00..7.00 rows=7 width=32)
                     Output: t2.fields
                     InfluxDB query: SELECT * FROM "s3" WHERE (("value1" = 0.1))
(12 rows)

-- select influx_mode over join query (result, stub call error)
--Testcase 483:
SELECT influx_mode((t1.fields->>'value1')::float), influx_mode((t2.fields->>'value1')::float) FROM s3 t1 INNER JOIN s3 t2 ON ((t1.fields->>'value1')::float = (t2.fields->>'value1')::float) where (t1.fields->>'value1')::float = 0.1;
ERROR:  stub influx_mode_sfunc(anyelement, anyelement) is called
CONTEXT:  PL/pgSQL function influx_mode_sfunc(anyelement,anyelement) line 3 at RAISE
-- select influx_mode with having (explain)
--Testcase 484:
EXPLAIN VERBOSE
SELECT influx_mode((fields->>'value1')::float) FROM s3 HAVING influx_mode((fields->>'value1')::float) > 100;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Aggregate  (cost=2214.93..2214.94 rows=1 width=8)
   Output: influx_mode(((fields ->> 'value1'::text))::double precision)
   Filter: (influx_mode(((s3.fields ->> 'value1'::text))::double precision) > '100'::double precision)
   ->  Foreign Scan on public.s3  (cost=10.00..1462.00 rows=1462 width=32)
         Output: "time", tags, fields
         InfluxDB query: SELECT * FROM "s3"
(6 rows)

-- select influx_mode with having (explain, not pushdown, stub call error)
--Testcase 485:
SELECT influx_mode((fields->>'value1')::float) FROM s3 HAVING influx_mode((fields->>'value1')::float) > 100;
ERROR:  stub influx_mode_sfunc(anyelement, anyelement) is called
CONTEXT:  PL/pgSQL function influx_mode_sfunc(anyelement,anyelement) line 3 at RAISE
-- select influx_mode(*) (stub agg function, explain)
--Testcase 486:
EXPLAIN VERBOSE
SELECT influx_mode_all(*) from s3;
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (influx_mode_all(*))
   InfluxDB query: SELECT mode(*) FROM "s3"
(3 rows)

-- select influx_mode(*) (stub agg function, result)
--Testcase 487:
SELECT influx_mode_all(*) from s3;
                                                  influx_mode_all                                                   
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-3.3\",\"value4\" : \"-100\" }")
(1 row)

-- select influx_mode(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 488:
EXPLAIN VERBOSE
SELECT influx_mode_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (influx_mode_all(*)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT mode(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select influx_mode(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 489:
SELECT influx_mode_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                  influx_mode_all                                                   
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select influx_mode(*) (stub agg function and group by tag only) (explain)
--Testcase 490:
EXPLAIN VERBOSE
SELECT influx_mode_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (influx_mode_all(*)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT mode(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select influx_mode(*) (stub agg function and group by tag only) (result)
--Testcase 491:
SELECT influx_mode_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                  influx_mode_all                                                   
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(2 rows)

-- select influx_mode(*) (stub agg function, expose data, explain)
--Testcase 492:
EXPLAIN VERBOSE
SELECT (influx_mode_all(*)::s3).* from s3;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((influx_mode_all(*)))::s3)."time", (((influx_mode_all(*)))::s3).tags, (((influx_mode_all(*)))::s3).fields
   InfluxDB query: SELECT mode(*) FROM "s3"
(3 rows)

-- select influx_mode(*) (stub agg function, expose data, result)
--Testcase 493:
SELECT (influx_mode_all(*)::s3).* from s3;
          time          | tags |                                 fields                                 
------------------------+------+------------------------------------------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "0.1", "value2": "100", "value3": "-3.3", "value4": "-100"}
(1 row)

-- select influx_mode(regex) (stub function, explain)
--Testcase 494:
EXPLAIN VERBOSE
SELECT influx_mode('/value[1,4]/') from s3;
                      QUERY PLAN                       
-------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (influx_mode('/value[1,4]/'::text))
   InfluxDB query: SELECT mode(/value[1,4]/) FROM "s3"
(3 rows)

-- select influx_mode(regex) (stub function, result)
--Testcase 495:
SELECT influx_mode('/value[1,4]/') from s3;
                               influx_mode                               
-------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value4\" : \"-100\" }")
(1 row)

-- select influx_mode(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 496:
EXPLAIN VERBOSE
SELECT influx_mode('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (influx_mode('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT mode(/^v.*/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select influx_mode(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 497:
SELECT influx_mode('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                    influx_mode                                                     
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select influx_mode(regex) (stub agg function and group by tag only) (explain)
--Testcase 498:
EXPLAIN VERBOSE
SELECT influx_mode('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (influx_mode('/value[1,4]/'::text)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT mode(/value[1,4]/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select influx_mode(regex) (stub agg function and group by tag only) (result)
--Testcase 499:
SELECT influx_mode('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                               influx_mode                               
-------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.1\",\"value4\" : \"-200\" }")
(2 rows)

-- select influx_mode(regex) (stub agg function, expose data, explain)
--Testcase 500:
EXPLAIN VERBOSE
SELECT (influx_mode('/value[1,4]/')::s3).* from s3;
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((influx_mode('/value[1,4]/'::text)))::s3)."time", (((influx_mode('/value[1,4]/'::text)))::s3).tags, (((influx_mode('/value[1,4]/'::text)))::s3).fields
   InfluxDB query: SELECT mode(/value[1,4]/) FROM "s3"
(3 rows)

-- select influx_mode(regex) (stub agg function, expose data, result)
--Testcase 501:
SELECT (influx_mode('/value[1,4]/')::s3).* from s3;
          time          | tags |               fields                
------------------------+------+-------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "0.1", "value4": "-100"}
(1 row)

-- select stddev (agg function, explain)
--Testcase 502:
EXPLAIN VERBOSE
SELECT stddev((fields->>'value1')::float),stddev((fields->>'value2')::bigint),stddev((fields->>'value3')::float),stddev((fields->>'value4')::bigint) FROM s3;
                                                                                                            QUERY PLAN                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=80)
   Output: (stddev(((fields ->> 'value1'::text))::double precision)), (stddev(((fields ->> 'value2'::text))::bigint)), (stddev(((fields ->> 'value3'::text))::double precision)), (stddev(((fields ->> 'value4'::text))::bigint))
   InfluxDB query: SELECT stddev("value1"), stddev("value2"), stddev("value3"), stddev("value4") FROM "s3"
(3 rows)

-- select stddev (agg function, result)
--Testcase 503:
SELECT stddev((fields->>'value1')::float),stddev((fields->>'value2')::bigint),stddev((fields->>'value3')::float),stddev((fields->>'value4')::bigint) FROM s3;
      stddev       |       stddev       |      stddev       |       stddev       
-------------------+--------------------+-------------------+--------------------
 1.299230541512937 | 54.772255750516614 | 1.299230541512937 | 54.772255750516614
(1 row)

-- select stddev (agg function and group by influx_time() and tag) (explain)
--Testcase 504:
EXPLAIN VERBOSE
SELECT stddev((fields->>'value1')::float),influx_time(time, interval '1s'),tags->>'tag1' tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=48)
   Output: (stddev(((fields ->> 'value1'::text))::double precision)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT stddev("value1") FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select stddev (agg function and group by influx_time() and tag) (result)
--Testcase 505:
SELECT stddev((fields->>'value1')::float),influx_time(time, interval '1s'),tags->>'tag1' tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
 stddev |      influx_time       | tag1 
--------+------------------------+------
        | 1970-01-01 09:00:00+09 | a
        | 1970-01-01 09:00:01+09 | a
        | 1970-01-01 09:00:02+09 | a
        | 1970-01-01 09:00:03+09 | a
        | 1970-01-01 09:00:04+09 | a
        | 1970-01-01 09:00:00+09 | b
        | 1970-01-01 09:00:01+09 | b
        | 1970-01-01 09:00:02+09 | b
        | 1970-01-01 09:00:03+09 | b
        | 1970-01-01 09:00:04+09 | b
(10 rows)

-- select stddev (agg function and group by tag only) (result)
--Testcase 506:
SELECT tags->>'tag1' tag1,stddev((fields->>'value1')::float) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
 tag1 |       stddev        
------+---------------------
 a    | 0.09999999999999999
 b    |  0.7778174593052023
(2 rows)

-- select stddev (agg function and other aggs) (result)
--Testcase 507:
SELECT sum((fields->>'value1')::float),stddev((fields->>'value1')::float),count(fields->>'value1') FROM s3;
        sum        |      stddev       | count 
-------------------+-------------------+-------
 7.199999999999999 | 1.299230541512937 |     6
(1 row)

-- select stddev(*) (stub agg function, explain)
--Testcase 508:
EXPLAIN VERBOSE
SELECT stddev_all(*) from s3;
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (stddev_all(*))
   InfluxDB query: SELECT stddev(*) FROM "s3"
(3 rows)

-- select stddev(*) (stub agg function, result)
--Testcase 509:
SELECT stddev_all(*) from s3;
                                                                                 stddev_all                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.299230541512937\",\"value2\" : \"54.772255750516614\",\"value3\" : \"1.299230541512937\",\"value4\" : \"54.772255750516614\" }")
(1 row)

-- select stddev(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 510:
EXPLAIN VERBOSE
SELECT stddev_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (stddev_all(*)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT stddev(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select stddev(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 511:
SELECT stddev_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                              stddev_all                                              
------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
(10 rows)

-- select stddev(*) (stub agg function and group by tag only) (explain)
--Testcase 512:
EXPLAIN VERBOSE
SELECT stddev_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (stddev_all(*)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT stddev(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select stddev(*) (stub agg function and group by tag only) (result)
--Testcase 513:
SELECT stddev_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                  stddev_all                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.09999999999999999\",\"value2\" : \"0\",\"value3\" : \"0.09999999999999999\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.7778174593052023\",\"value2\" : \"0\",\"value3\" : \"0.7778174593052023\",\"value4\" : \"0\" }")
(2 rows)

-- select stddev(regex) (stub function, explain)
--Testcase 514:
EXPLAIN VERBOSE
SELECT stddev('/value[1,4]/') from s3;
                       QUERY PLAN                        
---------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (stddev('/value[1,4]/'::text))
   InfluxDB query: SELECT stddev(/value[1,4]/) FROM "s3"
(3 rows)

-- select stddev(regex) (stub function, result)
--Testcase 515:
SELECT stddev('/value[1,4]/') from s3;
                                               stddev                                                
-----------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.299230541512937\",\"value4\" : \"54.772255750516614\" }")
(1 row)

-- select stddev(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 516:
EXPLAIN VERBOSE
SELECT stddev('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (stddev('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT stddev(/^v.*/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select stddev(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 517:
SELECT stddev('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                stddev                                                
------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
(10 rows)

-- select stddev(regex) (stub agg function and group by tag only) (explain)
--Testcase 518:
EXPLAIN VERBOSE
SELECT stddev('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (stddev('/value[1,4]/'::text)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT stddev(/value[1,4]/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select stddev(regex) (stub agg function and group by tag only) (result)
--Testcase 519:
SELECT stddev('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                        stddev                                        
--------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.09999999999999999\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.7778174593052023\",\"value4\" : \"0\" }")
(2 rows)

-- select influx_sum(*) (stub agg function, explain)
--Testcase 520:
EXPLAIN VERBOSE
SELECT influx_sum_all(*) from s3;
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (influx_sum_all(*))
   InfluxDB query: SELECT sum(*) FROM "s3"
(3 rows)

-- select influx_sum(*) (stub agg function, result)
--Testcase 521:
SELECT influx_sum_all(*) from s3;
                                                                 influx_sum_all                                                                 
------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"7.199999999999999\",\"value2\" : \"900\",\"value3\" : \"-7.199999999999999\",\"value4\" : \"-900\" }")
(1 row)

-- select influx_sum(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 522:
EXPLAIN VERBOSE
SELECT influx_sum_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (influx_sum_all(*)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT sum(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select influx_sum(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 523:
SELECT influx_sum_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                   influx_sum_all                                                   
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select influx_sum(*) (stub agg function and group by tag only) (explain)
--Testcase 524:
EXPLAIN VERBOSE
SELECT influx_sum_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (influx_sum_all(*)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT sum(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select influx_sum(*) (stub agg function and group by tag only) (result)
--Testcase 525:
SELECT influx_sum_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                  influx_sum_all                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.6000000000000001\",\"value2\" : \"300\",\"value3\" : \"-0.6000000000000001\",\"value4\" : \"-300\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"3.3000000000000003\",\"value2\" : \"400\",\"value3\" : \"-3.3000000000000003\",\"value4\" : \"-400\" }")
(2 rows)

-- select influx_sum(*) (stub agg function, expose data, explain)
--Testcase 526:
EXPLAIN VERBOSE
SELECT (influx_sum_all(*)::s3).* from s3;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((influx_sum_all(*)))::s3)."time", (((influx_sum_all(*)))::s3).tags, (((influx_sum_all(*)))::s3).fields
   InfluxDB query: SELECT sum(*) FROM "s3"
(3 rows)

-- select influx_sum(*) (stub agg function, expose data, result)
--Testcase 527:
SELECT (influx_sum_all(*)::s3).* from s3;
          time          | tags |                                               fields                                               
------------------------+------+----------------------------------------------------------------------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "7.199999999999999", "value2": "900", "value3": "-7.199999999999999", "value4": "-900"}
(1 row)

-- select influx_sum(regex) (stub function, explain)
--Testcase 528:
EXPLAIN VERBOSE
SELECT influx_sum('/value[1,4]/') from s3;
                      QUERY PLAN                      
------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (influx_sum('/value[1,4]/'::text))
   InfluxDB query: SELECT sum(/value[1,4]/) FROM "s3"
(3 rows)

-- select influx_sum(regex) (stub function, result)
--Testcase 529:
SELECT influx_sum('/value[1,4]/') from s3;
                                      influx_sum                                       
---------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"7.199999999999999\",\"value4\" : \"-900\" }")
(1 row)

-- select influx_sum(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 530:
EXPLAIN VERBOSE
SELECT influx_sum('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (influx_sum('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT sum(/^v.*/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select influx_sum(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 531:
SELECT influx_sum('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                     influx_sum                                                     
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select influx_sum(regex) (stub agg function and group by tag only) (explain)
--Testcase 532:
EXPLAIN VERBOSE
SELECT influx_sum('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (influx_sum('/value[1,4]/'::text)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT sum(/value[1,4]/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select influx_sum(regex) (stub agg function and group by tag only) (result)
--Testcase 533:
SELECT influx_sum('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                       influx_sum                                       
----------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.6000000000000001\",\"value4\" : \"-300\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"3.3000000000000003\",\"value4\" : \"-400\" }")
(2 rows)

-- select influx_sum(regex) (stub agg function, expose data, explain)
--Testcase 534:
EXPLAIN VERBOSE
SELECT (influx_sum('/value[1,4]/')::s3).* from s3;
                                                                           QUERY PLAN                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((influx_sum('/value[1,4]/'::text)))::s3)."time", (((influx_sum('/value[1,4]/'::text)))::s3).tags, (((influx_sum('/value[1,4]/'::text)))::s3).fields
   InfluxDB query: SELECT sum(/value[1,4]/) FROM "s3"
(3 rows)

-- select influx_sum(regex) (stub agg function, expose data, result)
--Testcase 535:
SELECT (influx_sum('/value[1,4]/')::s3).* from s3;
          time          | tags |                      fields                       
------------------------+------+---------------------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "7.199999999999999", "value4": "-900"}
(1 row)

-- selector function bottom() (explain)
--Testcase 536:
EXPLAIN VERBOSE
SELECT bottom((fields->>'value1')::float, 1) FROM s3;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1838.47 rows=1462 width=8)
   Output: bottom(((fields ->> 'value1'::text))::double precision, 1)
   InfluxDB query: SELECT "value1" FROM "s3"
(3 rows)

-- selector function bottom() (result)
--Testcase 537:
SELECT bottom((fields->>'value1')::float, 1) FROM s3;
ERROR:  stub bottom(float8, int) is called
CONTEXT:  PL/pgSQL function bottom(double precision,integer) line 3 at RAISE
-- selector function bottom() cannot be combined with other functions(explain)
--Testcase 538:
EXPLAIN VERBOSE
SELECT bottom((fields->>'value1')::float, 1), bottom((fields->>'value2')::bigint, 1), bottom((fields->>'value3')::float, 1), bottom((fields->>'value4')::bigint, 1) FROM s3;
                                                                                                              QUERY PLAN                                                                                                              
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: bottom(((fields ->> 'value1'::text))::double precision, 1), bottom(((fields ->> 'value2'::text))::bigint, 1), bottom(((fields ->> 'value3'::text))::double precision, 1), bottom(((fields ->> 'value4'::text))::bigint, 1)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

-- selector function bottom() cannot be combined with other functions(result)
--Testcase 539:
SELECT bottom((fields->>'value1')::float, 1), bottom((fields->>'value2')::bigint, 1), bottom((fields->>'value3')::float, 1), bottom((fields->>'value4')::bigint, 1) FROM s3;
ERROR:  stub bottom(float8, int) is called
CONTEXT:  PL/pgSQL function bottom(double precision,integer) line 3 at RAISE
-- select influx_max(*) (stub agg function, explain)
--Testcase 540:
EXPLAIN VERBOSE
SELECT influx_max_all(*) from s3;
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (influx_max_all(*))
   InfluxDB query: SELECT max(*) FROM "s3"
(3 rows)

-- select influx_max(*) (stub agg function, result)
--Testcase 541:
SELECT influx_max_all(*) from s3;
                                                   influx_max_all                                                   
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"3.3\",\"value2\" : \"200\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
(1 row)

-- select influx_max(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 542:
EXPLAIN VERBOSE
SELECT influx_max_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (influx_max_all(*)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT max(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select influx_max(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 543:
SELECT influx_max_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                   influx_max_all                                                   
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select influx_max(*) (stub agg function and group by tag only) (explain)
--Testcase 544:
EXPLAIN VERBOSE
SELECT influx_max_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (influx_max_all(*)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT max(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select influx_max(*) (stub agg function and group by tag only) (result)
--Testcase 545:
SELECT influx_max_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                   influx_max_all                                                   
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
(2 rows)

-- select influx_max(*) (stub agg function, expose data, explain)
--Testcase 546:
EXPLAIN VERBOSE
SELECT (influx_max_all(*)::s3).* from s3;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((influx_max_all(*)))::s3)."time", (((influx_max_all(*)))::s3).tags, (((influx_max_all(*)))::s3).fields
   InfluxDB query: SELECT max(*) FROM "s3"
(3 rows)

-- select influx_max(*) (stub agg function, expose data, result)
--Testcase 547:
SELECT (influx_max_all(*)::s3).* from s3;
          time          | tags |                                 fields                                 
------------------------+------+------------------------------------------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "3.3", "value2": "200", "value3": "-0.1", "value4": "-100"}
(1 row)

-- select influx_max(regex) (stub function, explain)
--Testcase 548:
EXPLAIN VERBOSE
SELECT influx_max('/value[1,4]/') from s3;
                      QUERY PLAN                      
------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (influx_max('/value[1,4]/'::text))
   InfluxDB query: SELECT max(/value[1,4]/) FROM "s3"
(3 rows)

-- select influx_max(regex) (stub function, result)
--Testcase 549:
SELECT influx_max('/value[1,4]/') from s3;
                               influx_max                                
-------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"3.3\",\"value4\" : \"-100\" }")
(1 row)

-- select influx_max(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 550:
EXPLAIN VERBOSE
SELECT influx_max('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (influx_max('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT max(/^v.*/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select influx_max(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 551:
SELECT influx_max('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                     influx_max                                                     
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select influx_max(regex) (stub agg function and group by tag only) (explain)
--Testcase 552:
EXPLAIN VERBOSE
SELECT influx_max('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (influx_max('/value[1,4]/'::text)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT max(/value[1,4]/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select influx_max(regex) (stub agg function and group by tag only) (result)
--Testcase 553:
SELECT influx_max('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                               influx_max                                
-------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"2.2\",\"value4\" : \"-200\" }")
(2 rows)

-- select influx_max(regex) (stub agg function, expose data, explain)
--Testcase 554:
EXPLAIN VERBOSE
SELECT (influx_max('/value[1,4]/')::s3).* from s3;
                                                                           QUERY PLAN                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((influx_max('/value[1,4]/'::text)))::s3)."time", (((influx_max('/value[1,4]/'::text)))::s3).tags, (((influx_max('/value[1,4]/'::text)))::s3).fields
   InfluxDB query: SELECT max(/value[1,4]/) FROM "s3"
(3 rows)

-- select influx_max(regex) (stub agg function, expose data, result)
--Testcase 555:
SELECT (influx_max('/value[1,4]/')::s3).* from s3;
          time          | tags |               fields                
------------------------+------+-------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "3.3", "value4": "-100"}
(1 row)

-- select influx_min(*) (stub agg function, explain)
--Testcase 556:
EXPLAIN VERBOSE
SELECT influx_min_all(*) from s3;
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (influx_min_all(*))
   InfluxDB query: SELECT min(*) FROM "s3"
(3 rows)

-- select influx_min(*) (stub agg function, result)
--Testcase 557:
SELECT influx_min_all(*) from s3;
                                                   influx_min_all                                                   
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-3.3\",\"value4\" : \"-200\" }")
(1 row)

-- select influx_min(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 558:
EXPLAIN VERBOSE
SELECT influx_min_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (influx_min_all(*)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT min(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select influx_min(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 559:
SELECT influx_min_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                   influx_min_all                                                   
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select influx_min(*) (stub agg function and group by tag only) (explain)
--Testcase 560:
EXPLAIN VERBOSE
SELECT influx_min_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (influx_min_all(*)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT min(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select influx_min(*) (stub agg function and group by tag only) (result)
--Testcase 561:
SELECT influx_min_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                   influx_min_all                                                   
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(2 rows)

-- select influx_min(*) (stub agg function, expose data, explain)
--Testcase 562:
EXPLAIN VERBOSE
SELECT (influx_min_all(*)::s3).* from s3;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((influx_min_all(*)))::s3)."time", (((influx_min_all(*)))::s3).tags, (((influx_min_all(*)))::s3).fields
   InfluxDB query: SELECT min(*) FROM "s3"
(3 rows)

-- select influx_min(*) (stub agg function, expose data, result)
--Testcase 563:
SELECT (influx_min_all(*)::s3).* from s3;
          time          | tags |                                 fields                                 
------------------------+------+------------------------------------------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "0.1", "value2": "100", "value3": "-3.3", "value4": "-200"}
(1 row)

-- select influx_min(regex) (stub function, explain)
--Testcase 564:
EXPLAIN VERBOSE
SELECT influx_min('/value[1,4]/') from s3;
                      QUERY PLAN                      
------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (influx_min('/value[1,4]/'::text))
   InfluxDB query: SELECT min(/value[1,4]/) FROM "s3"
(3 rows)

-- select influx_min(regex) (stub function, result)
--Testcase 565:
SELECT influx_min('/value[1,4]/') from s3;
                               influx_min                                
-------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value4\" : \"-200\" }")
(1 row)

-- select influx_min(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 566:
EXPLAIN VERBOSE
SELECT influx_min('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (influx_min('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT min(/^v.*/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select influx_min(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 567:
SELECT influx_min('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                     influx_min                                                     
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select influx_min(regex) (stub agg function and group by tag only) (explain)
--Testcase 568:
EXPLAIN VERBOSE
SELECT influx_min('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (influx_min('/value[1,4]/'::text)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT min(/value[1,4]/) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select influx_min(regex) (stub agg function and group by tag only) (result)
--Testcase 569:
SELECT influx_min('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                               influx_min                                
-------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.1\",\"value4\" : \"-200\" }")
(2 rows)

-- select influx_min(regex) (stub agg function, expose data, explain)
--Testcase 570:
EXPLAIN VERBOSE
SELECT (influx_min('/value[1,4]/')::s3).* from s3;
                                                                           QUERY PLAN                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (((influx_min('/value[1,4]/'::text)))::s3)."time", (((influx_min('/value[1,4]/'::text)))::s3).tags, (((influx_min('/value[1,4]/'::text)))::s3).fields
   InfluxDB query: SELECT min(/value[1,4]/) FROM "s3"
(3 rows)

-- select influx_min(regex) (stub agg function, expose data, result)
--Testcase 571:
SELECT (influx_min('/value[1,4]/')::s3).* from s3;
          time          | tags |               fields                
------------------------+------+-------------------------------------
 1970-01-01 09:00:00+09 |      | {"value1": "0.1", "value4": "-200"}
(1 row)

-- selector function percentile() (explain)
--Testcase 572:
EXPLAIN VERBOSE
SELECT percentile((fields->>'value1')::float, 50), percentile((fields->>'value2')::bigint, 60), percentile((fields->>'value3')::float, 25), percentile((fields->>'value4')::bigint, 33) FROM s3;
                                                                                                                        QUERY PLAN                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: percentile(((fields ->> 'value1'::text))::double precision, 50), percentile(((fields ->> 'value2'::text))::bigint, 60), percentile(((fields ->> 'value3'::text))::double precision, 25), percentile(((fields ->> 'value4'::text))::bigint, 33)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

-- selector function percentile() (result)
--Testcase 573:
SELECT percentile((fields->>'value1')::float, 50), percentile((fields->>'value2')::bigint, 60), percentile((fields->>'value3')::float, 25), percentile((fields->>'value4')::bigint, 33) FROM s3;
ERROR:  stub percentile(float8, int) is called
CONTEXT:  PL/pgSQL function percentile(double precision,integer) line 3 at RAISE
-- selector function percentile() (explain)
--Testcase 574:
EXPLAIN VERBOSE
SELECT percentile((fields->>'value1')::float, 1.5), percentile((fields->>'value2')::bigint, 6.7), percentile((fields->>'value3')::float, 20.5), percentile((fields->>'value4')::bigint, 75.2) FROM s3;
                                                                                                                                                                   QUERY PLAN                                                                                                                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: percentile(((fields ->> 'value1'::text))::double precision, '1.5'::double precision), percentile(((fields ->> 'value2'::text))::bigint, '6.7'::double precision), percentile(((fields ->> 'value3'::text))::double precision, '20.5'::double precision), percentile(((fields ->> 'value4'::text))::bigint, '75.2'::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

-- selector function percentile() (result)
--Testcase 575:
SELECT percentile((fields->>'value1')::float, 1.5), percentile((fields->>'value2')::bigint, 6.7), percentile((fields->>'value3')::float, 20.5), percentile((fields->>'value4')::bigint, 75.2) FROM s3;
ERROR:  stub percentile(float8, float8) is called
CONTEXT:  PL/pgSQL function percentile(double precision,double precision) line 3 at RAISE
-- select percentile(*, int) (stub agg function, explain)
--Testcase 576:
EXPLAIN VERBOSE
SELECT percentile_all(50) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: percentile_all(50)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select percentile(*, int) (stub agg function, result)
--Testcase 577:
SELECT percentile_all(50) from s3;
ERROR:  stub percentile_all(int) is called
CONTEXT:  PL/pgSQL function percentile_all(integer) line 3 at RAISE
-- select percentile(*, float8) (stub agg function, explain)
--Testcase 578:
EXPLAIN VERBOSE
SELECT percentile_all(70.5) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: percentile_all('70.5'::double precision)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select percentile(*, float8) (stub agg function, result)
--Testcase 579:
SELECT percentile_all(70.5) from s3;
ERROR:  stub percentile_all(float8) is called
CONTEXT:  PL/pgSQL function percentile_all(double precision) line 3 at RAISE
-- select percentile(*, int) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 580:
EXPLAIN VERBOSE
SELECT percentile_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (percentile_all(50)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT percentile(*, 50) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select percentile(*, int) (stub agg function and group by influx_time() and tag) (result)
--Testcase 581:
SELECT percentile_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                   percentile_all                                                   
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select percentile(*, float8) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 582:
EXPLAIN VERBOSE
SELECT percentile_all(70.5) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                                 QUERY PLAN                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (percentile_all('70.5'::double precision)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT percentile(*, 70.5) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select percentile(*, float8) (stub agg function and group by influx_time() and tag) (result)
--Testcase 583:
SELECT percentile_all(70.5) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                   percentile_all                                                   
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select percentile(*, int) (stub agg function and group by tag only) (explain)
--Testcase 584:
EXPLAIN VERBOSE
SELECT percentile_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (percentile_all(50)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT percentile(*, 50) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select percentile(*, int) (stub agg function and group by tag only) (result)
--Testcase 585:
SELECT percentile_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                   percentile_all                                                   
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(2 rows)

-- select percentile(*, float8) (stub agg function and group by tag only) (explain)
--Testcase 586:
EXPLAIN VERBOSE
SELECT percentile_all(70.5) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (percentile_all('70.5'::double precision)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT percentile(*, 70.5) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select percentile(*, float8) (stub agg function and group by tag only) (result)
--Testcase 587:
SELECT percentile_all(70.5) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                   percentile_all                                                   
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(2 rows)

-- select percentile(*, int) (stub agg function, expose data, explain)
--Testcase 588:
EXPLAIN VERBOSE
SELECT (percentile_all(50)::s3).* from s3;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((percentile_all(50))::s3)."time", ((percentile_all(50))::s3).tags, ((percentile_all(50))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select percentile(*, int) (stub agg function, expose data, result)
--Testcase 589:
SELECT (percentile_all(50)::s3).* from s3;
ERROR:  stub percentile_all(int) is called
CONTEXT:  PL/pgSQL function percentile_all(integer) line 3 at RAISE
-- select percentile(*, int) (stub agg function, expose data, explain)
--Testcase 590:
EXPLAIN VERBOSE
SELECT (percentile_all(70.5)::s3).* from s3;
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((percentile_all('70.5'::double precision))::s3)."time", ((percentile_all('70.5'::double precision))::s3).tags, ((percentile_all('70.5'::double precision))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select percentile(*, int) (stub agg function, expose data, result)
--Testcase 591:
SELECT (percentile_all(70.5)::s3).* from s3;
ERROR:  stub percentile_all(float8) is called
CONTEXT:  PL/pgSQL function percentile_all(double precision) line 3 at RAISE
-- select percentile(regex) (stub function, explain)
--Testcase 592:
EXPLAIN VERBOSE
SELECT percentile('/value[1,4]/', 50) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: percentile('/value[1,4]/'::text, 50)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select percentile(regex) (stub function, result)
--Testcase 593:
SELECT percentile('/value[1,4]/', 50) from s3;
ERROR:  stub percentile(text, int) is called
CONTEXT:  PL/pgSQL function percentile(text,integer) line 3 at RAISE
-- select percentile(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 594:
EXPLAIN VERBOSE
SELECT percentile('/^v.*/', 50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (percentile('/^v.*/'::text, 50)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT percentile(/^v.*/, 50) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select percentile(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 595:
SELECT percentile('/^v.*/', 50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                     percentile                                                     
--------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1\",\"value2\" : \"100\",\"value3\" : \"-0.1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2\",\"value2\" : \"100\",\"value3\" : \"-0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3\",\"value2\" : \"100\",\"value3\" : \"-0.3\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.1\",\"value2\" : \"200\",\"value3\" : \"-1.1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2.2\",\"value2\" : \"200\",\"value3\" : \"-2.2\",\"value4\" : \"-200\" }")
(10 rows)

-- select percentile(regex) (stub agg function and group by tag only) (explain)
--Testcase 596:
EXPLAIN VERBOSE
SELECT percentile('/value[1,4]/', 70.5) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (percentile('/value[1,4]/'::text, '70.5'::double precision)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT percentile(/value[1,4]/, 70.5) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select percentile(regex) (stub agg function and group by tag only) (result)
--Testcase 597:
SELECT percentile('/value[1,4]/', 70.5) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                               percentile                                
-------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.2\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.1\",\"value4\" : \"-200\" }")
(2 rows)

-- select percentile(regex) (stub agg function, expose data, explain)
--Testcase 598:
EXPLAIN VERBOSE
SELECT (percentile('/value[1,4]/', 50)::s3).* from s3;
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((percentile('/value[1,4]/'::text, 50))::s3)."time", ((percentile('/value[1,4]/'::text, 50))::s3).tags, ((percentile('/value[1,4]/'::text, 50))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select percentile(regex) (stub agg function, expose data, result)
--Testcase 599:
SELECT (percentile('/value[1,4]/', 50)::s3).* from s3;
ERROR:  stub percentile(text, int) is called
CONTEXT:  PL/pgSQL function percentile(text,integer) line 3 at RAISE
-- select percentile(regex) (stub agg function, expose data, explain)
--Testcase 600:
EXPLAIN VERBOSE
SELECT (percentile('/value[1,4]/', 70.5)::s3).* from s3;
                                                                                                               QUERY PLAN                                                                                                                
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((percentile('/value[1,4]/'::text, '70.5'::double precision))::s3)."time", ((percentile('/value[1,4]/'::text, '70.5'::double precision))::s3).tags, ((percentile('/value[1,4]/'::text, '70.5'::double precision))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select percentile(regex) (stub agg function, expose data, result)
--Testcase 601:
SELECT (percentile('/value[1,4]/', 70.5)::s3).* from s3;
ERROR:  stub percentile(text, float8) is called
CONTEXT:  PL/pgSQL function percentile(text,double precision) line 3 at RAISE
-- selector function top(field_key,N) (explain)
--Testcase 602:
EXPLAIN VERBOSE
SELECT top((fields->>'value1')::float, 1) FROM s3;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1838.47 rows=1462 width=8)
   Output: top(((fields ->> 'value1'::text))::double precision, 1)
   InfluxDB query: SELECT "value1" FROM "s3"
(3 rows)

-- selector function top(field_key,N) (result)
--Testcase 603:
SELECT top((fields->>'value1')::float, 1) FROM s3;
ERROR:  stub top(float8, int) is called
CONTEXT:  PL/pgSQL function top(double precision,integer) line 3 at RAISE
-- selector function top(field_key,tag_key(s),N) (explain)
--Testcase 604:
EXPLAIN VERBOSE
SELECT top((fields->>'value1')::float, tags->>'tag1', 1) FROM s3;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1171.80 rows=930 width=8)
   Output: top(((fields ->> 'value1'::text))::double precision, (tags ->> 'tag1'::text), 1)
   InfluxDB query: SELECT "value1", "tag1" FROM "s3"
(3 rows)

-- selector function top(field_key,tag_key(s),N) (result)
--Testcase 605:
SELECT top((fields->>'value1')::float, tags->>'tag1', 1) FROM s3;
ERROR:  stub top(float8, text, int) is called
CONTEXT:  PL/pgSQL function top(double precision,text,integer) line 3 at RAISE
-- selector function top() cannot be combined with other functions(explain)
--Testcase 606:
EXPLAIN VERBOSE
SELECT top((fields->>'value1')::float, 1), top((fields->>'value2')::bigint, 1), top((fields->>'value3')::float, 1), top((fields->>'value4')::bigint, 1) FROM s3;
                                                                                                        QUERY PLAN                                                                                                        
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2967.86 rows=1462 width=32)
   Output: top(((fields ->> 'value1'::text))::double precision, 1), top(((fields ->> 'value2'::text))::bigint, 1), top(((fields ->> 'value3'::text))::double precision, 1), top(((fields ->> 'value4'::text))::bigint, 1)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

-- selector function top() cannot be combined with other functions(result)
--Testcase 607:
SELECT top((fields->>'value1')::float, 1), top((fields->>'value2')::bigint, 1), top((fields->>'value3')::float, 1), top((fields->>'value4')::bigint, 1) FROM s3;
ERROR:  stub top(float8, int) is called
CONTEXT:  PL/pgSQL function top(double precision,integer) line 3 at RAISE
-- select acos (builtin function, explain)
--Testcase 608:
EXPLAIN VERBOSE
SELECT acos((fields->>'value1')::float), acos((fields->>'value3')::float) FROM s3;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1491.24 rows=1462 width=16)
   Output: acos(((fields ->> 'value1'::text))::double precision), acos(((fields ->> 'value3'::text))::double precision)
   InfluxDB query: SELECT "value1", "value3" FROM "s3"
(3 rows)

-- select acos (builtin function, result)
--Testcase 609:
SELECT acos((fields->>'value1')::float), acos((fields->>'value3')::float) FROM s3;
ERROR:  input is out of range
-- select acos (builtin function, not pushdown constraints, explain)
--Testcase 610:
EXPLAIN VERBOSE
SELECT acos((fields->>'value1')::float), acos((fields->>'value3')::float) FROM s3 WHERE to_hex((fields->>'value2')::bigint) = '64';
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..7.14 rows=7 width=16)
   Output: acos(((fields ->> 'value1'::text))::double precision), acos(((fields ->> 'value3'::text))::double precision)
   Filter: (to_hex(((s3.fields ->> 'value2'::text))::bigint) = '64'::text)
   InfluxDB query: SELECT "value1", "value3", "value2" FROM "s3"
(4 rows)

-- select acos (builtin function, not pushdown constraints, result)
--Testcase 611:
SELECT acos((fields->>'value1')::float), acos((fields->>'value3')::float) FROM s3 WHERE to_hex((fields->>'value2')::bigint) = '64';
        acos        |        acos        
--------------------+--------------------
 1.4706289056333368 | 1.6709637479564565
  1.369438406004566 | 1.7721542475852274
 1.2661036727794992 | 1.8754889808102941
(3 rows)

-- select acos (builtin function, pushdown constraints, explain)
--Testcase 612:
EXPLAIN VERBOSE
SELECT acos((fields->>'value1')::float), acos((fields->>'value3')::float) FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1484.10 rows=1455 width=16)
   Output: acos(((fields ->> 'value1'::text))::double precision), acos(((fields ->> 'value3'::text))::double precision)
   InfluxDB query: SELECT "value1", "value3" FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select acos (builtin function, pushdown constraints, result)
--Testcase 613:
SELECT acos((fields->>'value1')::float), acos((fields->>'value3')::float) FROM s3 WHERE (fields->>'value2')::bigint != 200;
        acos        |        acos        
--------------------+--------------------
 1.4706289056333368 | 1.6709637479564565
  1.369438406004566 | 1.7721542475852274
 1.2661036727794992 | 1.8754889808102941
(3 rows)

-- select acos as nest function with agg (pushdown, explain)
--Testcase 614:
EXPLAIN VERBOSE
SELECT sum((fields->>'value3')::float), acos(sum((fields->>'value3')::float)) FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=16)
   Output: (sum(((fields ->> 'value3'::text))::double precision)), (acos(sum(((fields ->> 'value3'::text))::double precision)))
   InfluxDB query: SELECT sum("value3"), acos(sum("value3")) FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select acos as nest function with agg (pushdown, result)
--Testcase 615:
SELECT sum((fields->>'value3')::float), acos(sum((fields->>'value3')::float)) FROM s3 WHERE (fields->>'value2')::bigint != 200;
         sum         |       acos        
---------------------+-------------------
 -0.6000000000000001 | 2.214297435588181
(1 row)

-- select acos as nest with log2 (pushdown, explain)
--Testcase 616:
EXPLAIN VERBOSE
SELECT acos(log2((fields->>'value1')::float)),acos(log2(1/(fields->>'value1')::float)) FROM s3;
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2225.89 rows=1462 width=16)
   Output: acos(log2(((fields ->> 'value1'::text))::double precision)), acos(log2(('1'::double precision / ((fields ->> 'value1'::text))::double precision)))
   InfluxDB query: SELECT "value1" FROM "s3"
(3 rows)

-- select acos as nest with log2 (pushdown, result)
--Testcase 617:
SELECT acos(log2((fields->>'value1')::float)),acos(log2(1/(fields->>'value1')::float)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select acos with non pushdown func and explicit constant (explain)
--Testcase 618:
EXPLAIN VERBOSE
SELECT acos((fields->>'value3')::float), pi(), 4.1 FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1469.55 rows=1455 width=48)
   Output: acos(((fields ->> 'value3'::text))::double precision), '3.141592653589793'::double precision, 4.1
   InfluxDB query: SELECT "value3" FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select acos with non pushdown func and explicit constant (result)
--Testcase 619:
SELECT acos((fields->>'value3')::float), pi(), 4.1 FROM s3 WHERE (fields->>'value2')::bigint != 200;
        acos        |        pi         | ?column? 
--------------------+-------------------+----------
 1.6709637479564565 | 3.141592653589793 |      4.1
 1.7721542475852274 | 3.141592653589793 |      4.1
 1.8754889808102941 | 3.141592653589793 |      4.1
(3 rows)

-- select acos with order by (explain)
--Testcase 620:
EXPLAIN VERBOSE
SELECT (fields->>'value1')::float value1, acos(1-(fields->>'value1')::float) FROM s3 WHERE (fields->>'value2')::bigint != 200 ORDER BY acos(1-(fields->>'value1')::float);
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1560.54..1564.17 rows=1455 width=16)
   Output: (((fields ->> 'value1'::text))::double precision), (acos(('1'::double precision - ((fields ->> 'value1'::text))::double precision)))
   Sort Key: (acos(('1'::double precision - ((s3.fields ->> 'value1'::text))::double precision)))
   ->  Foreign Scan on public.s3  (cost=10.00..1484.10 rows=1455 width=16)
         Output: ((fields ->> 'value1'::text))::double precision, acos(('1'::double precision - ((fields ->> 'value1'::text))::double precision))
         InfluxDB query: SELECT "value1" FROM "s3" WHERE (("value2" <> 200))
(6 rows)

-- select acos with order by (result)
--Testcase 621:
SELECT (fields->>'value1')::float value1, acos(1-(fields->>'value1')::float) FROM s3 WHERE (fields->>'value2')::bigint != 200 ORDER BY acos(1-(fields->>'value1')::float);
 value1 |        acos         
--------+---------------------
    0.1 | 0.45102681179626236
    0.2 |  0.6435011087932843
    0.3 |  0.7953988301841436
(3 rows)

-- select acos with order by index (result)
--Testcase 622:
SELECT (fields->>'value1')::float value1, acos(1-(fields->>'value1')::float) FROM s3 WHERE (fields->>'value2')::bigint != 200 ORDER BY 2,1;
 value1 |        acos         
--------+---------------------
    0.1 | 0.45102681179626236
    0.2 |  0.6435011087932843
    0.3 |  0.7953988301841436
(3 rows)

-- select acos with order by index (result)
--Testcase 623:
SELECT (fields->>'value1')::float value1, acos(1-(fields->>'value1')::float) FROM s3 WHERE (fields->>'value2')::bigint != 200 ORDER BY 1,2;
 value1 |        acos         
--------+---------------------
    0.1 | 0.45102681179626236
    0.2 |  0.6435011087932843
    0.3 |  0.7953988301841436
(3 rows)

-- select acos and as
--Testcase 624:
SELECT acos((fields->>'value3')::float) as acos1 FROM s3 WHERE (fields->>'value2')::bigint != 200;
       acos1        
--------------------
 1.6709637479564565
 1.7721542475852274
 1.8754889808102941
(3 rows)

-- select acos(*) (stub agg function, explain)
--Testcase 625:
EXPLAIN VERBOSE
SELECT acos_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: acos_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select acos(*) (stub agg function, result)
--Testcase 626:
SELECT acos_all() from s3;
ERROR:  stub acos_all() is called
CONTEXT:  PL/pgSQL function acos_all() line 3 at RAISE
-- select acos(*) (stub agg function and group by tag only) (explain)
--Testcase 627:
EXPLAIN VERBOSE
SELECT acos_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (acos_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT acos(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select acos(*) (stub agg function and group by tag only) (result)
--Testcase 628:
SELECT acos_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 acos_all                                                                 
------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.4706289056333368\",\"value2\" : null,\"value3\" : \"1.6709637479564563\",\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"1.3694384060045657\",\"value2\" : null,\"value3\" : \"1.7721542475852274\",\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"1.266103672779499\",\"value2\" : null,\"value3\" : \"1.8754889808102941\",\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
(5 rows)

-- select acos(*) (stub agg function, expose data, explain)
--Testcase 629:
EXPLAIN VERBOSE
SELECT (acos_all()::s3).* from s3;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((acos_all())::s3)."time", ((acos_all())::s3).tags, ((acos_all())::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select acos(*) (stub agg function, expose data, result)
--Testcase 630:
SELECT (acos_all()::s3).* from s3;
ERROR:  stub acos_all() is called
CONTEXT:  PL/pgSQL function acos_all() line 3 at RAISE
-- select asin (builtin function, explain)
--Testcase 631:
EXPLAIN VERBOSE
SELECT asin((fields->>'value1')::float), asin((fields->>'value3')::float) FROM s3;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1491.24 rows=1462 width=16)
   Output: asin(((fields ->> 'value1'::text))::double precision), asin(((fields ->> 'value3'::text))::double precision)
   InfluxDB query: SELECT "value1", "value3" FROM "s3"
(3 rows)

-- select asin (builtin function, result)
--Testcase 632:
SELECT asin((fields->>'value1')::float), asin((fields->>'value3')::float) FROM s3;
ERROR:  input is out of range
-- select asin (builtin function, not pushdown constraints, explain)
--Testcase 633:
EXPLAIN VERBOSE
SELECT asin((fields->>'value1')::float), asin((fields->>'value3')::float) FROM s3 WHERE to_hex((fields->>'value2')::bigint) = '64';
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..7.14 rows=7 width=16)
   Output: asin(((fields ->> 'value1'::text))::double precision), asin(((fields ->> 'value3'::text))::double precision)
   Filter: (to_hex(((s3.fields ->> 'value2'::text))::bigint) = '64'::text)
   InfluxDB query: SELECT "value1", "value3", "value2" FROM "s3"
(4 rows)

-- select asin (builtin function, not pushdown constraints, result)
--Testcase 634:
SELECT asin((fields->>'value1')::float), asin((fields->>'value3')::float) FROM s3 WHERE to_hex((fields->>'value2')::bigint) = '64';
        asin        |        asin         
--------------------+---------------------
 0.1001674211615598 | -0.1001674211615598
 0.2013579207903308 | -0.2013579207903308
 0.3046926540153975 | -0.3046926540153975
(3 rows)

-- select asin (builtin function, pushdown constraints, explain)
--Testcase 635:
EXPLAIN VERBOSE
SELECT asin((fields->>'value1')::float), asin((fields->>'value3')::float) FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1484.10 rows=1455 width=16)
   Output: asin(((fields ->> 'value1'::text))::double precision), asin(((fields ->> 'value3'::text))::double precision)
   InfluxDB query: SELECT "value1", "value3" FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select asin (builtin function, pushdown constraints, result)
--Testcase 636:
SELECT asin((fields->>'value1')::float), asin((fields->>'value3')::float) FROM s3 WHERE (fields->>'value2')::bigint != 200;
        asin        |        asin         
--------------------+---------------------
 0.1001674211615598 | -0.1001674211615598
 0.2013579207903308 | -0.2013579207903308
 0.3046926540153975 | -0.3046926540153975
(3 rows)

-- select asin as nest function with agg (pushdown, explain)
--Testcase 637:
EXPLAIN VERBOSE
SELECT sum((fields->>'value3')::float), asin(sum((fields->>'value3')::float)) FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=16)
   Output: (sum(((fields ->> 'value3'::text))::double precision)), (asin(sum(((fields ->> 'value3'::text))::double precision)))
   InfluxDB query: SELECT sum("value3"), asin(sum("value3")) FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select asin as nest function with agg (pushdown, result)
--Testcase 638:
SELECT sum((fields->>'value3')::float), asin(sum((fields->>'value3')::float)) FROM s3 WHERE (fields->>'value2')::bigint != 200;
         sum         |        asin         
---------------------+---------------------
 -0.6000000000000001 | -0.6435011087932845
(1 row)

-- select asin as nest with log2 (pushdown, explain)
--Testcase 639:
EXPLAIN VERBOSE
SELECT asin(log2((fields->>'value1')::float)),asin(log2(1/(fields->>'value1')::float)) FROM s3;
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2225.89 rows=1462 width=16)
   Output: asin(log2(((fields ->> 'value1'::text))::double precision)), asin(log2(('1'::double precision / ((fields ->> 'value1'::text))::double precision)))
   InfluxDB query: SELECT "value1" FROM "s3"
(3 rows)

-- select asin as nest with log2 (pushdown, result)
--Testcase 640:
SELECT asin(log2((fields->>'value1')::float)),asin(log2(1/(fields->>'value1')::float)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select asin with non pushdown func and explicit constant (explain)
--Testcase 641:
EXPLAIN VERBOSE
SELECT asin((fields->>'value3')::float), pi(), 4.1 FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1469.55 rows=1455 width=48)
   Output: asin(((fields ->> 'value3'::text))::double precision), '3.141592653589793'::double precision, 4.1
   InfluxDB query: SELECT "value3" FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select asin with non pushdown func and explicit constant (result)
--Testcase 642:
SELECT asin((fields->>'value3')::float), pi(), 4.1 FROM s3 WHERE (fields->>'value2')::bigint != 200;
        asin         |        pi         | ?column? 
---------------------+-------------------+----------
 -0.1001674211615598 | 3.141592653589793 |      4.1
 -0.2013579207903308 | 3.141592653589793 |      4.1
 -0.3046926540153975 | 3.141592653589793 |      4.1
(3 rows)

-- select asin with order by (explain)
--Testcase 643:
EXPLAIN VERBOSE
SELECT (fields->>'value1')::float value1, asin(1-(fields->>'value1')::float) FROM s3 WHERE (fields->>'value2')::bigint != 200 ORDER BY asin(1-(fields->>'value1')::float);
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1560.54..1564.17 rows=1455 width=16)
   Output: (((fields ->> 'value1'::text))::double precision), (asin(('1'::double precision - ((fields ->> 'value1'::text))::double precision)))
   Sort Key: (asin(('1'::double precision - ((s3.fields ->> 'value1'::text))::double precision)))
   ->  Foreign Scan on public.s3  (cost=10.00..1484.10 rows=1455 width=16)
         Output: ((fields ->> 'value1'::text))::double precision, asin(('1'::double precision - ((fields ->> 'value1'::text))::double precision))
         InfluxDB query: SELECT "value1" FROM "s3" WHERE (("value2" <> 200))
(6 rows)

-- select asin with order by (result)
--Testcase 644:
SELECT (fields->>'value1')::float value1, asin(1-(fields->>'value1')::float) FROM s3 WHERE (fields->>'value2')::bigint != 200 ORDER BY asin(1-(fields->>'value1')::float);
 value1 |        asin        
--------+--------------------
    0.3 |  0.775397496610753
    0.2 | 0.9272952180016123
    0.1 | 1.1197695149986342
(3 rows)

-- select asin with order by index (result)
--Testcase 645:
SELECT (fields->>'value1')::float value1, asin(1-(fields->>'value1')::float) FROM s3 WHERE (fields->>'value2')::bigint != 200 ORDER BY 2,1;
 value1 |        asin        
--------+--------------------
    0.3 |  0.775397496610753
    0.2 | 0.9272952180016123
    0.1 | 1.1197695149986342
(3 rows)

-- select asin with order by index (result)
--Testcase 646:
SELECT (fields->>'value1')::float value1, asin(1-(fields->>'value1')::float) FROM s3 WHERE (fields->>'value2')::bigint != 200 ORDER BY 1,2;
 value1 |        asin        
--------+--------------------
    0.1 | 1.1197695149986342
    0.2 | 0.9272952180016123
    0.3 |  0.775397496610753
(3 rows)

-- select asin and as
--Testcase 647:
SELECT asin((fields->>'value3')::float) as asin1 FROM s3 WHERE (fields->>'value2')::bigint != 200;
        asin1        
---------------------
 -0.1001674211615598
 -0.2013579207903308
 -0.3046926540153975
(3 rows)

-- select asin(*) (stub agg function, explain)
--Testcase 648:
EXPLAIN VERBOSE
SELECT asin_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: asin_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select asin(*) (stub agg function, result)
--Testcase 649:
SELECT asin_all() from s3;
ERROR:  stub asin_all() is called
CONTEXT:  PL/pgSQL function asin_all() line 3 at RAISE
-- select asin(*) (stub agg function and group by tag only) (explain)
--Testcase 650:
EXPLAIN VERBOSE
SELECT asin_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (asin_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT asin(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select asin(*) (stub agg function and group by tag only) (result)
--Testcase 651:
SELECT asin_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                  asin_all                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.1001674211615598\",\"value2\" : null,\"value3\" : \"-0.1001674211615598\",\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.20135792079033082\",\"value2\" : null,\"value3\" : \"-0.20135792079033082\",\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.3046926540153975\",\"value2\" : null,\"value3\" : \"-0.3046926540153975\",\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : null,\"value2\" : null,\"value3\" : null,\"value4\" : null }")
(5 rows)

-- select asin(*) (stub agg function, expose data, explain)
--Testcase 652:
EXPLAIN VERBOSE
SELECT (asin_all()::s3).* from s3;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((asin_all())::s3)."time", ((asin_all())::s3).tags, ((asin_all())::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select asin(*) (stub agg function, expose data, result)
--Testcase 653:
SELECT (asin_all()::s3).* from s3;
ERROR:  stub asin_all() is called
CONTEXT:  PL/pgSQL function asin_all() line 3 at RAISE
-- select atan (builtin function, explain)
--Testcase 654:
EXPLAIN VERBOSE
SELECT atan((fields->>'value1')::float), atan((fields->>'value2')::bigint), atan((fields->>'value3')::float), atan((fields->>'value4')::bigint) FROM s3;
                                                                                                                        QUERY PLAN                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1527.79 rows=1462 width=32)
   Output: atan(((fields ->> 'value1'::text))::double precision), atan((((fields ->> 'value2'::text))::bigint)::double precision), atan(((fields ->> 'value3'::text))::double precision), atan((((fields ->> 'value4'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

-- select atan (builtin function, result)
--Testcase 655:
SELECT atan((fields->>'value1')::float), atan((fields->>'value2')::bigint), atan((fields->>'value3')::float), atan((fields->>'value4')::bigint) FROM s3;
        atan         |        atan        |         atan         |        atan         
---------------------+--------------------+----------------------+---------------------
 0.09966865249116204 | 1.5607966601082315 | -0.09966865249116204 | -1.5607966601082315
 0.19739555984988078 | 1.5607966601082315 | -0.19739555984988078 | -1.5607966601082315
  0.2914567944778671 | 1.5607966601082315 |  -0.2914567944778671 | -1.5607966601082315
  0.8329812666744317 | 1.5657963684609384 |  -0.8329812666744317 | -1.5657963684609384
  1.1441688336680205 | 1.5657963684609384 |  -1.1441688336680205 | -1.5657963684609384
  1.2765617616837088 | 1.5657963684609384 |  -1.2765617616837088 | -1.5657963684609384
(6 rows)

-- select atan (builtin function, not pushdown constraints, explain)
--Testcase 656:
EXPLAIN VERBOSE
SELECT atan((fields->>'value1')::float), atan((fields->>'value2')::bigint), atan((fields->>'value3')::float), atan((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
                                                                                                                        QUERY PLAN                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: atan(((fields ->> 'value1'::text))::double precision), atan((((fields ->> 'value2'::text))::bigint)::double precision), atan(((fields ->> 'value3'::text))::double precision), atan((((fields ->> 'value4'::text))::bigint)::double precision)
   Filter: (to_hex(((s3.fields ->> 'value2'::text))::bigint) <> '64'::text)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(4 rows)

-- select atan (builtin function, not pushdown constraints, result)
--Testcase 657:
SELECT atan((fields->>'value1')::float), atan((fields->>'value2')::bigint), atan((fields->>'value3')::float), atan((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
        atan        |        atan        |        atan         |        atan         
--------------------+--------------------+---------------------+---------------------
 0.8329812666744317 | 1.5657963684609384 | -0.8329812666744317 | -1.5657963684609384
 1.1441688336680205 | 1.5657963684609384 | -1.1441688336680205 | -1.5657963684609384
 1.2765617616837088 | 1.5657963684609384 | -1.2765617616837088 | -1.5657963684609384
(3 rows)

-- select atan (builtin function, pushdown constraints, explain)
--Testcase 658:
EXPLAIN VERBOSE
SELECT atan((fields->>'value1')::float), atan((fields->>'value2')::bigint), atan((fields->>'value3')::float), atan((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                                                                                        QUERY PLAN                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: atan(((fields ->> 'value1'::text))::double precision), atan((((fields ->> 'value2'::text))::bigint)::double precision), atan(((fields ->> 'value3'::text))::double precision), atan((((fields ->> 'value4'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select atan (builtin function, pushdown constraints, result)
--Testcase 659:
SELECT atan((fields->>'value1')::float), atan((fields->>'value2')::bigint), atan((fields->>'value3')::float), atan((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
        atan         |        atan        |         atan         |        atan         
---------------------+--------------------+----------------------+---------------------
 0.09966865249116204 | 1.5607966601082315 | -0.09966865249116204 | -1.5607966601082315
 0.19739555984988078 | 1.5607966601082315 | -0.19739555984988078 | -1.5607966601082315
  0.2914567944778671 | 1.5607966601082315 |  -0.2914567944778671 | -1.5607966601082315
(3 rows)

-- select atan as nest function with agg (pushdown, explain)
--Testcase 660:
EXPLAIN VERBOSE
SELECT sum((fields->>'value3')::float),atan(sum((fields->>'value3')::float)) FROM s3;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=16)
   Output: (sum(((fields ->> 'value3'::text))::double precision)), (atan(sum(((fields ->> 'value3'::text))::double precision)))
   InfluxDB query: SELECT sum("value3"), atan(sum("value3")) FROM "s3"
(3 rows)

-- select atan as nest function with agg (pushdown, result)
--Testcase 661:
SELECT sum((fields->>'value3')::float),atan(sum((fields->>'value3')::float)) FROM s3;
        sum         |        atan         
--------------------+---------------------
 -7.199999999999999 | -1.4327903031373772
(1 row)

-- select atan as nest with log2 (pushdown, explain)
--Testcase 662:
EXPLAIN VERBOSE
SELECT atan(log2((fields->>'value1')::float)),atan(log2(1/(fields->>'value1')::float)) FROM s3;
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2225.89 rows=1462 width=16)
   Output: atan(log2(((fields ->> 'value1'::text))::double precision)), atan(log2(('1'::double precision / ((fields ->> 'value1'::text))::double precision)))
   InfluxDB query: SELECT "value1" FROM "s3"
(3 rows)

-- select atan as nest with log2 (pushdown, result)
--Testcase 663:
SELECT atan(log2((fields->>'value1')::float)),atan(log2(1/(fields->>'value1')::float)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select atan with non pushdown func and explicit constant (explain)
--Testcase 664:
EXPLAIN VERBOSE
SELECT atan((fields->>'value3')::float), pi(), 4.1 FROM s3;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1476.62 rows=1462 width=48)
   Output: atan(((fields ->> 'value3'::text))::double precision), '3.141592653589793'::double precision, 4.1
   InfluxDB query: SELECT "value3" FROM "s3"
(3 rows)

-- select atan with non pushdown func and explicit constant (result)
--Testcase 665:
SELECT atan((fields->>'value3')::float), pi(), 4.1 FROM s3;
         atan         |        pi         | ?column? 
----------------------+-------------------+----------
 -0.09966865249116204 | 3.141592653589793 |      4.1
 -0.19739555984988078 | 3.141592653589793 |      4.1
  -0.2914567944778671 | 3.141592653589793 |      4.1
  -0.8329812666744317 | 3.141592653589793 |      4.1
  -1.1441688336680205 | 3.141592653589793 |      4.1
  -1.2765617616837088 | 3.141592653589793 |      4.1
(6 rows)

-- select atan with order by (explain)
--Testcase 666:
EXPLAIN VERBOSE
SELECT (fields->>'value1')::float value1, atan(1-(fields->>'value1')::float) FROM s3 order by atan(1-(fields->>'value1')::float);
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1568.10..1571.75 rows=1462 width=16)
   Output: (((fields ->> 'value1'::text))::double precision), (atan(('1'::double precision - ((fields ->> 'value1'::text))::double precision)))
   Sort Key: (atan(('1'::double precision - ((s3.fields ->> 'value1'::text))::double precision)))
   ->  Foreign Scan on public.s3  (cost=10.00..1491.24 rows=1462 width=16)
         Output: ((fields ->> 'value1'::text))::double precision, atan(('1'::double precision - ((fields ->> 'value1'::text))::double precision))
         InfluxDB query: SELECT "value1" FROM "s3"
(6 rows)

-- select atan with order by (result)
--Testcase 667:
SELECT (fields->>'value1')::float value1, atan(1-(fields->>'value1')::float) FROM s3 order by atan(1-(fields->>'value1')::float);
 value1 |         atan         
--------+----------------------
    3.3 |  -1.1606689862534056
    2.2 |  -0.8760580505981935
    1.1 | -0.09966865249116212
    0.3 |   0.6107259643892086
    0.2 |   0.6747409422235527
    0.1 |   0.7328151017865066
(6 rows)

-- select atan with order by index (result)
--Testcase 668:
SELECT (fields->>'value1')::float value1, atan(1-(fields->>'value1')::float) FROM s3 order by 2,1;
 value1 |         atan         
--------+----------------------
    3.3 |  -1.1606689862534056
    2.2 |  -0.8760580505981935
    1.1 | -0.09966865249116212
    0.3 |   0.6107259643892086
    0.2 |   0.6747409422235527
    0.1 |   0.7328151017865066
(6 rows)

-- select atan with order by index (result)
--Testcase 669:
SELECT (fields->>'value1')::float value1, atan(1-(fields->>'value1')::float) FROM s3 order by 1,2;
 value1 |         atan         
--------+----------------------
    0.1 |   0.7328151017865066
    0.2 |   0.6747409422235527
    0.3 |   0.6107259643892086
    1.1 | -0.09966865249116212
    2.2 |  -0.8760580505981935
    3.3 |  -1.1606689862534056
(6 rows)

-- select atan and as
--Testcase 670:
SELECT atan((fields->>'value3')::float) as atan1 FROM s3;
        atan1         
----------------------
 -0.09966865249116204
 -0.19739555984988078
  -0.2914567944778671
  -0.8329812666744317
  -1.1441688336680205
  -1.2765617616837088
(6 rows)

-- select atan(*) (stub agg function, explain)
--Testcase 671:
EXPLAIN VERBOSE
SELECT atan_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: atan_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select atan(*) (stub agg function, result)
--Testcase 672:
SELECT atan_all() from s3;
ERROR:  stub atan_all() is called
CONTEXT:  PL/pgSQL function atan_all() line 3 at RAISE
-- select atan(*) (stub agg function and group by tag only) (explain)
--Testcase 673:
EXPLAIN VERBOSE
SELECT atan_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (atan_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT atan(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select atan(*) (stub agg function and group by tag only) (result)
--Testcase 674:
SELECT atan_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                     atan_all                                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.09966865249116204\",\"value2\" : \"1.5607966601082313\",\"value3\" : \"-0.09966865249116204\",\"value4\" : \"-1.5607966601082313\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.19739555984988078\",\"value2\" : \"1.5607966601082313\",\"value3\" : \"-0.19739555984988078\",\"value4\" : \"-1.5607966601082313\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.2914567944778671\",\"value2\" : \"1.5607966601082313\",\"value3\" : \"-0.2914567944778671\",\"value4\" : \"-1.5607966601082313\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"0.8329812666744317\",\"value2\" : \"1.5657963684609382\",\"value3\" : \"-0.8329812666744317\",\"value4\" : \"-1.5657963684609382\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1.1441688336680205\",\"value2\" : \"1.5657963684609382\",\"value3\" : \"-1.1441688336680205\",\"value4\" : \"-1.5657963684609382\" }")
(5 rows)

-- select atan(*) (stub agg function, expose data, explain)
--Testcase 675:
EXPLAIN VERBOSE
SELECT (atan_all()::s3).* from s3;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((atan_all())::s3)."time", ((atan_all())::s3).tags, ((atan_all())::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select multiple star functions (do not push down, raise warning and stub error) (result)
--Testcase 676:
SELECT asin_all(), acos_all(), atan_all() FROM s3;
ERROR:  stub asin_all() is called
CONTEXT:  PL/pgSQL function asin_all() line 3 at RAISE
-- select atan2 (builtin function, explain)
--Testcase 677:
EXPLAIN VERBOSE
SELECT atan2((fields->>'value1')::float, (fields->>'value2')::bigint), atan2((fields->>'value2')::bigint, (fields->>'value3')::float), atan2((fields->>'value3')::float, (fields->>'value4')::bigint), atan2((fields->>'value4')::bigint, (fields->>'value1')::float) FROM s3;
                                                                                                                                                                                                                                      QUERY PLAN                                                                                                                                                                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1578.96 rows=1462 width=32)
   Output: atan2(((fields ->> 'value1'::text))::double precision, (((fields ->> 'value2'::text))::bigint)::double precision), atan2((((fields ->> 'value2'::text))::bigint)::double precision, ((fields ->> 'value3'::text))::double precision), atan2(((fields ->> 'value3'::text))::double precision, (((fields ->> 'value4'::text))::bigint)::double precision), atan2((((fields ->> 'value4'::text))::bigint)::double precision, ((fields ->> 'value1'::text))::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

-- select atan2 (builtin function, result)
--Testcase 678:
SELECT atan2((fields->>'value1')::float, (fields->>'value2')::bigint), atan2((fields->>'value2')::bigint, (fields->>'value3')::float), atan2((fields->>'value3')::float, (fields->>'value4')::bigint), atan2((fields->>'value4')::bigint, (fields->>'value1')::float) FROM s3;
         atan2         |       atan2        |        atan2        |        atan2        
-----------------------+--------------------+---------------------+---------------------
 0.0009999996666668668 | 1.5717963264615635 | -3.1405926539231266 | -1.5697963271282298
 0.0019999973333397333 | 1.5727963241282363 | -3.1395926562564536 | -1.5687963294615568
 0.0029999910000485996 | 1.5737963177949452 | -3.1385926625897445 | -1.5677963357948481
  0.005499944542673214 | 1.5762962713375699 | -3.1360927090471202 | -1.5652963822522235
  0.010999556365540751 | 1.5817958831604373 | -3.1305930972242524 | -1.5597967704293558
   0.01649850286954865 | 1.5872948296644454 | -3.1250941507202445 |  -1.554297823925348
(6 rows)

-- select atan2 (builtin function, not pushdown constraints, explain)
--Testcase 679:
EXPLAIN VERBOSE
SELECT atan2((fields->>'value1')::float, (fields->>'value2')::bigint), atan2((fields->>'value2')::bigint, (fields->>'value3')::float), atan2((fields->>'value3')::float, (fields->>'value4')::bigint), atan2((fields->>'value4')::bigint, (fields->>'value1')::float) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
                                                                                                                                                                                                                                      QUERY PLAN                                                                                                                                                                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1571.40 rows=1455 width=32)
   Output: atan2(((fields ->> 'value1'::text))::double precision, (((fields ->> 'value2'::text))::bigint)::double precision), atan2((((fields ->> 'value2'::text))::bigint)::double precision, ((fields ->> 'value3'::text))::double precision), atan2(((fields ->> 'value3'::text))::double precision, (((fields ->> 'value4'::text))::bigint)::double precision), atan2((((fields ->> 'value4'::text))::bigint)::double precision, ((fields ->> 'value1'::text))::double precision)
   Filter: (to_hex(((s3.fields ->> 'value2'::text))::bigint) <> '64'::text)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(4 rows)

-- select atan2 (builtin function, not pushdown constraints, result)
--Testcase 680:
SELECT atan2((fields->>'value1')::float, (fields->>'value2')::bigint), atan2((fields->>'value2')::bigint, (fields->>'value3')::float), atan2((fields->>'value3')::float, (fields->>'value4')::bigint), atan2((fields->>'value4')::bigint, (fields->>'value1')::float) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
        atan2         |       atan2        |        atan2        |        atan2        
----------------------+--------------------+---------------------+---------------------
 0.005499944542673214 | 1.5762962713375699 | -3.1360927090471202 | -1.5652963822522235
 0.010999556365540751 | 1.5817958831604373 | -3.1305930972242524 | -1.5597967704293558
  0.01649850286954865 | 1.5872948296644454 | -3.1250941507202445 |  -1.554297823925348
(3 rows)

-- select atan2 (builtin function, pushdown constraints, explain)
--Testcase 681:
EXPLAIN VERBOSE
SELECT atan2((fields->>'value1')::float, (fields->>'value2')::bigint), atan2((fields->>'value2')::bigint, (fields->>'value3')::float), atan2((fields->>'value3')::float, (fields->>'value4')::bigint), atan2((fields->>'value4')::bigint, (fields->>'value1')::float) FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                                                                                                                                                                                                      QUERY PLAN                                                                                                                                                                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1571.40 rows=1455 width=32)
   Output: atan2(((fields ->> 'value1'::text))::double precision, (((fields ->> 'value2'::text))::bigint)::double precision), atan2((((fields ->> 'value2'::text))::bigint)::double precision, ((fields ->> 'value3'::text))::double precision), atan2(((fields ->> 'value3'::text))::double precision, (((fields ->> 'value4'::text))::bigint)::double precision), atan2((((fields ->> 'value4'::text))::bigint)::double precision, ((fields ->> 'value1'::text))::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select atan2 (builtin function, pushdown constraints, result)
--Testcase 682:
SELECT atan2((fields->>'value1')::float, (fields->>'value2')::bigint), atan2((fields->>'value2')::bigint, (fields->>'value3')::float), atan2((fields->>'value3')::float, (fields->>'value4')::bigint), atan2((fields->>'value4')::bigint, (fields->>'value1')::float) FROM s3 WHERE (fields->>'value2')::bigint != 200;
         atan2         |       atan2        |        atan2        |        atan2        
-----------------------+--------------------+---------------------+---------------------
 0.0009999996666668668 | 1.5717963264615635 | -3.1405926539231266 | -1.5697963271282298
 0.0019999973333397333 | 1.5727963241282363 | -3.1395926562564536 | -1.5687963294615568
 0.0029999910000485996 | 1.5737963177949452 | -3.1385926625897445 | -1.5677963357948481
(3 rows)

-- select atan2 as nest function with agg (pushdown, explain)
--Testcase 683:
EXPLAIN VERBOSE
SELECT sum((fields->>'value3')::float), sum((fields->>'value4')::bigint),atan2(sum((fields->>'value3')::float), sum((fields->>'value3')::float)) FROM s3;
                                                                                                             QUERY PLAN                                                                                                              
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=48)
   Output: (sum(((fields ->> 'value3'::text))::double precision)), (sum(((fields ->> 'value4'::text))::bigint)), (atan2(sum(((fields ->> 'value3'::text))::double precision), sum(((fields ->> 'value3'::text))::double precision)))
   InfluxDB query: SELECT sum("value3"), sum("value4"), atan2(sum("value3"), sum("value3")) FROM "s3"
(3 rows)

-- select atan2 as nest function with agg (pushdown, result)
--Testcase 684:
SELECT sum((fields->>'value3')::float), sum((fields->>'value4')::bigint),atan2(sum((fields->>'value3')::float), sum((fields->>'value3')::float)) FROM s3;
        sum         | sum  |       atan2        
--------------------+------+--------------------
 -7.199999999999999 | -900 | -2.356194490192345
(1 row)

-- select atan2 as nest with log2 (pushdown, explain)
--Testcase 685:
EXPLAIN VERBOSE
SELECT atan2(log2((fields->>'value1')::float), log2((fields->>'value1')::float)),atan2(log2(1/(fields->>'value1')::float), log2(1/(fields->>'value1')::float)) FROM s3;
                                                                                                                                               QUERY PLAN                                                                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2982.48 rows=1462 width=16)
   Output: atan2(log2(((fields ->> 'value1'::text))::double precision), log2(((fields ->> 'value1'::text))::double precision)), atan2(log2(('1'::double precision / ((fields ->> 'value1'::text))::double precision)), log2(('1'::double precision / ((fields ->> 'value1'::text))::double precision)))
   InfluxDB query: SELECT "value1" FROM "s3"
(3 rows)

-- select atan2 as nest with log2 (pushdown, result)
--Testcase 686:
SELECT atan2(log2((fields->>'value1')::float), log2((fields->>'value1')::float)),atan2(log2(1/(fields->>'value1')::float), log2(1/(fields->>'value1')::float)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select atan2 with non pushdown func and explicit constant (explain)
--Testcase 687:
EXPLAIN VERBOSE
SELECT atan2((fields->>'value3')::float, (fields->>'value4')::bigint), pi(), 4.1 FROM s3;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1491.24 rows=1462 width=48)
   Output: atan2(((fields ->> 'value3'::text))::double precision, (((fields ->> 'value4'::text))::bigint)::double precision), '3.141592653589793'::double precision, 4.1
   InfluxDB query: SELECT "value3", "value4" FROM "s3"
(3 rows)

-- select atan2 with non pushdown func and explicit constant (result)
--Testcase 688:
SELECT atan2((fields->>'value3')::float, (fields->>'value4')::bigint), pi(), 4.1 FROM s3;
        atan2        |        pi         | ?column? 
---------------------+-------------------+----------
 -3.1405926539231266 | 3.141592653589793 |      4.1
 -3.1395926562564536 | 3.141592653589793 |      4.1
 -3.1385926625897445 | 3.141592653589793 |      4.1
 -3.1360927090471202 | 3.141592653589793 |      4.1
 -3.1305930972242524 | 3.141592653589793 |      4.1
 -3.1250941507202445 | 3.141592653589793 |      4.1
(6 rows)

-- select atan2 with order by (explain)
--Testcase 689:
EXPLAIN VERBOSE
SELECT (fields->>'value1')::float value1, atan2(1-(fields->>'value1')::float, 1-(fields->>'value2')::bigint) FROM s3 order by atan2(1-(fields->>'value1')::float, 1-(fields->>'value2')::bigint);
                                                                                                     QUERY PLAN                                                                                                     
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1586.37..1590.03 rows=1462 width=16)
   Output: (((fields ->> 'value1'::text))::double precision), (atan2(('1'::double precision - ((fields ->> 'value1'::text))::double precision), ((1 - ((fields ->> 'value2'::text))::bigint))::double precision))
   Sort Key: (atan2(('1'::double precision - ((s3.fields ->> 'value1'::text))::double precision), ((1 - ((s3.fields ->> 'value2'::text))::bigint))::double precision))
   ->  Foreign Scan on public.s3  (cost=10.00..1509.52 rows=1462 width=16)
         Output: ((fields ->> 'value1'::text))::double precision, atan2(('1'::double precision - ((fields ->> 'value1'::text))::double precision), ((1 - ((fields ->> 'value2'::text))::bigint))::double precision)
         InfluxDB query: SELECT "value1", "value2" FROM "s3"
(6 rows)

-- select atan2 with order by (result)
--Testcase 690:
SELECT (fields->>'value1')::float value1, atan2(1-(fields->>'value1')::float, 1-(fields->>'value2')::bigint) FROM s3 order by atan2(1-(fields->>'value1')::float, 1-(fields->>'value2')::bigint);
 value1 |        atan2        
--------+---------------------
    1.1 | -3.1410901410692773
    2.2 | -3.1355625759253205
    3.3 |  -3.130035379243216
    0.1 |  3.1325019949247332
    0.2 |  3.1335120213928933
    0.3 |  3.1345220643486456
(6 rows)

-- select atan2 with order by index (result)
--Testcase 691:
SELECT (fields->>'value1')::float value1, atan2(1-(fields->>'value1')::float, 1-(fields->>'value2')::bigint) FROM s3 order by 2,1;
 value1 |        atan2        
--------+---------------------
    1.1 | -3.1410901410692773
    2.2 | -3.1355625759253205
    3.3 |  -3.130035379243216
    0.1 |  3.1325019949247332
    0.2 |  3.1335120213928933
    0.3 |  3.1345220643486456
(6 rows)

-- select atan2 with order by index (result)
--Testcase 692:
SELECT (fields->>'value1')::float value1, atan2(1-(fields->>'value1')::float, 1-(fields->>'value2')::bigint) FROM s3 order by 1,2;
 value1 |        atan2        
--------+---------------------
    0.1 |  3.1325019949247332
    0.2 |  3.1335120213928933
    0.3 |  3.1345220643486456
    1.1 | -3.1410901410692773
    2.2 | -3.1355625759253205
    3.3 |  -3.130035379243216
(6 rows)

-- select atan2 and as
--Testcase 693:
SELECT atan2((fields->>'value3')::float, (fields->>'value4')::bigint) as atan21 FROM s3;
       atan21        
---------------------
 -3.1405926539231266
 -3.1395926562564536
 -3.1385926625897445
 -3.1360927090471202
 -3.1305930972242524
 -3.1250941507202445
(6 rows)

-- select atan2(*) (stub function, explain)
--Testcase 694:
EXPLAIN VERBOSE
SELECT atan2_all((fields->>'value1')::float) from s3;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1838.47 rows=1462 width=32)
   Output: atan2_all(((fields ->> 'value1'::text))::double precision)
   InfluxDB query: SELECT "value1" FROM "s3"
(3 rows)

-- select atan2(*) (stub function, result)
--Testcase 695:
SELECT atan2_all((fields->>'value1')::float) from s3;
ERROR:  stub atan2_all(float8) is called
CONTEXT:  PL/pgSQL function atan2_all(double precision) line 3 at RAISE
-- select ceil (builtin function, explain)
--Testcase 696:
EXPLAIN VERBOSE
SELECT ceil((fields->>'value1')::float), ceil((fields->>'value2')::bigint), ceil((fields->>'value3')::float), ceil((fields->>'value4')::bigint) FROM s3;
                                                                                                                        QUERY PLAN                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1527.79 rows=1462 width=32)
   Output: ceil(((fields ->> 'value1'::text))::double precision), ceil((((fields ->> 'value2'::text))::bigint)::double precision), ceil(((fields ->> 'value3'::text))::double precision), ceil((((fields ->> 'value4'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

-- select ceil (builtin function, result)
--Testcase 697:
SELECT ceil((fields->>'value1')::float), ceil((fields->>'value2')::bigint), ceil((fields->>'value3')::float), ceil((fields->>'value4')::bigint) FROM s3;
 ceil | ceil | ceil | ceil 
------+------+------+------
    1 |  100 |   -0 | -100
    1 |  100 |   -0 | -100
    1 |  100 |   -0 | -100
    2 |  200 |   -1 | -200
    3 |  200 |   -2 | -200
    4 |  200 |   -3 | -200
(6 rows)

-- select ceil (builtin function, not pushdown constraints, explain)
--Testcase 698:
EXPLAIN VERBOSE
SELECT ceil((fields->>'value1')::float), ceil((fields->>'value2')::bigint), ceil((fields->>'value3')::float), ceil((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
                                                                                                                        QUERY PLAN                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: ceil(((fields ->> 'value1'::text))::double precision), ceil((((fields ->> 'value2'::text))::bigint)::double precision), ceil(((fields ->> 'value3'::text))::double precision), ceil((((fields ->> 'value4'::text))::bigint)::double precision)
   Filter: (to_hex(((s3.fields ->> 'value2'::text))::bigint) <> '64'::text)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(4 rows)

-- select ceil (builtin function, not pushdown constraints, result)
--Testcase 699:
SELECT ceil((fields->>'value1')::float), ceil((fields->>'value2')::bigint), ceil((fields->>'value3')::float), ceil((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
 ceil | ceil | ceil | ceil 
------+------+------+------
    2 |  200 |   -1 | -200
    3 |  200 |   -2 | -200
    4 |  200 |   -3 | -200
(3 rows)

-- select ceil (builtin function, pushdown constraints, explain)
--Testcase 700:
EXPLAIN VERBOSE
SELECT ceil((fields->>'value1')::float), ceil((fields->>'value2')::bigint), ceil((fields->>'value3')::float), ceil((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                                                                                        QUERY PLAN                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: ceil(((fields ->> 'value1'::text))::double precision), ceil((((fields ->> 'value2'::text))::bigint)::double precision), ceil(((fields ->> 'value3'::text))::double precision), ceil((((fields ->> 'value4'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select ceil (builtin function, pushdown constraints, result)
--Testcase 701:
SELECT ceil((fields->>'value1')::float), ceil((fields->>'value2')::bigint), ceil((fields->>'value3')::float), ceil((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
 ceil | ceil | ceil | ceil 
------+------+------+------
    1 |  100 |   -0 | -100
    1 |  100 |   -0 | -100
    1 |  100 |   -0 | -100
(3 rows)

-- select ceil as nest function with agg (pushdown, explain)
--Testcase 702:
EXPLAIN VERBOSE
SELECT sum((fields->>'value3')::float),ceil(sum((fields->>'value3')::float)) FROM s3;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=16)
   Output: (sum(((fields ->> 'value3'::text))::double precision)), (ceil(sum(((fields ->> 'value3'::text))::double precision)))
   InfluxDB query: SELECT sum("value3"), ceil(sum("value3")) FROM "s3"
(3 rows)

-- select ceil as nest function with agg (pushdown, result)
--Testcase 703:
SELECT sum((fields->>'value3')::float),ceil(sum((fields->>'value3')::float)) FROM s3;
        sum         | ceil 
--------------------+------
 -7.199999999999999 |   -7
(1 row)

-- select ceil as nest with log2 (pushdown, explain)
--Testcase 704:
EXPLAIN VERBOSE
SELECT ceil(log2((fields->>'value1')::float)),ceil(log2(1/(fields->>'value1')::float)) FROM s3;
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2225.89 rows=1462 width=16)
   Output: ceil(log2(((fields ->> 'value1'::text))::double precision)), ceil(log2(('1'::double precision / ((fields ->> 'value1'::text))::double precision)))
   InfluxDB query: SELECT "value1" FROM "s3"
(3 rows)

-- select ceil as nest with log2 (pushdown, result)
--Testcase 705:
SELECT ceil(log2((fields->>'value1')::float)),ceil(log2(1/(fields->>'value1')::float)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select ceil with non pushdown func and explicit constant (explain)
--Testcase 706:
EXPLAIN VERBOSE
SELECT ceil((fields->>'value3')::float), pi(), 4.1 FROM s3;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1476.62 rows=1462 width=48)
   Output: ceil(((fields ->> 'value3'::text))::double precision), '3.141592653589793'::double precision, 4.1
   InfluxDB query: SELECT "value3" FROM "s3"
(3 rows)

-- select ceil with non pushdown func and explicit constant (result)
--Testcase 707:
SELECT ceil((fields->>'value3')::float), pi(), 4.1 FROM s3;
 ceil |        pi         | ?column? 
------+-------------------+----------
   -0 | 3.141592653589793 |      4.1
   -0 | 3.141592653589793 |      4.1
   -0 | 3.141592653589793 |      4.1
   -1 | 3.141592653589793 |      4.1
   -2 | 3.141592653589793 |      4.1
   -3 | 3.141592653589793 |      4.1
(6 rows)

-- select ceil with order by (explain)
--Testcase 708:
EXPLAIN VERBOSE
SELECT (fields->>'value1')::float value1, ceil(1-(fields->>'value1')::float) FROM s3 order by ceil(1-(fields->>'value1')::float);
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1568.10..1571.75 rows=1462 width=16)
   Output: (((fields ->> 'value1'::text))::double precision), (ceil(('1'::double precision - ((fields ->> 'value1'::text))::double precision)))
   Sort Key: (ceil(('1'::double precision - ((s3.fields ->> 'value1'::text))::double precision)))
   ->  Foreign Scan on public.s3  (cost=10.00..1491.24 rows=1462 width=16)
         Output: ((fields ->> 'value1'::text))::double precision, ceil(('1'::double precision - ((fields ->> 'value1'::text))::double precision))
         InfluxDB query: SELECT "value1" FROM "s3"
(6 rows)

-- select ceil with order by (result)
--Testcase 709:
SELECT (fields->>'value1')::float value1, ceil(1-(fields->>'value1')::float) FROM s3 order by ceil(1-(fields->>'value1')::float);
 value1 | ceil 
--------+------
    3.3 |   -2
    2.2 |   -1
    1.1 |   -0
    0.1 |    1
    0.2 |    1
    0.3 |    1
(6 rows)

-- select ceil with order by index (result)
--Testcase 710:
SELECT (fields->>'value1')::float value1, ceil(1-(fields->>'value1')::float) FROM s3 order by 2,1;
 value1 | ceil 
--------+------
    3.3 |   -2
    2.2 |   -1
    1.1 |   -0
    0.1 |    1
    0.2 |    1
    0.3 |    1
(6 rows)

-- select ceil with order by index (result)
--Testcase 711:
SELECT (fields->>'value1')::float value1, ceil(1-(fields->>'value1')::float) FROM s3 order by 1,2;
 value1 | ceil 
--------+------
    0.1 |    1
    0.2 |    1
    0.3 |    1
    1.1 |   -0
    2.2 |   -1
    3.3 |   -2
(6 rows)

-- select ceil and as
--Testcase 712:
SELECT ceil((fields->>'value3')::float) as ceil1 FROM s3;
 ceil1 
-------
    -0
    -0
    -0
    -1
    -2
    -3
(6 rows)

-- select ceil(*) (stub agg function, explain)
--Testcase 713:
EXPLAIN VERBOSE
SELECT ceil_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: ceil_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select ceil(*) (stub agg function, result)
--Testcase 714:
SELECT ceil_all() from s3;
ERROR:  stub ceil_all() is called
CONTEXT:  PL/pgSQL function ceil_all() line 3 at RAISE
-- select ceil(*) (stub agg function and group by tag only) (explain)
--Testcase 715:
EXPLAIN VERBOSE
SELECT ceil_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (ceil_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT ceil(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select ceil(*) (stub agg function and group by tag only) (result)
--Testcase 716:
SELECT ceil_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                    ceil_all                                                    
----------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1\",\"value2\" : \"100\",\"value3\" : \"-0\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"1\",\"value2\" : \"100\",\"value3\" : \"-0\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"1\",\"value2\" : \"100\",\"value3\" : \"-0\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"2\",\"value2\" : \"200\",\"value3\" : \"-1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"3\",\"value2\" : \"200\",\"value3\" : \"-2\",\"value4\" : \"-200\" }")
(5 rows)

-- select ceil(*) (stub agg function, expose data, explain)
--Testcase 717:
EXPLAIN VERBOSE
SELECT (ceil_all()::s3).* from s3;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((ceil_all())::s3)."time", ((ceil_all())::s3).tags, ((ceil_all())::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select ceil(*) (stub agg function, expose data, result)
--Testcase 718:
SELECT (ceil_all()::s3).* from s3;
ERROR:  stub ceil_all() is called
CONTEXT:  PL/pgSQL function ceil_all() line 3 at RAISE
-- select cos (builtin function, explain)
--Testcase 719:
EXPLAIN VERBOSE
SELECT cos((fields->>'value1')::float), cos((fields->>'value2')::bigint), cos((fields->>'value3')::float), cos((fields->>'value4')::bigint) FROM s3;
                                                                                                                      QUERY PLAN                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1527.79 rows=1462 width=32)
   Output: cos(((fields ->> 'value1'::text))::double precision), cos((((fields ->> 'value2'::text))::bigint)::double precision), cos(((fields ->> 'value3'::text))::double precision), cos((((fields ->> 'value4'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

-- select cos (builtin function, result)
--Testcase 720:
SELECT cos((fields->>'value1')::float), cos((fields->>'value2')::bigint), cos((fields->>'value3')::float), cos((fields->>'value4')::bigint) FROM s3;
         cos         |        cos         |         cos         |        cos         
---------------------+--------------------+---------------------+--------------------
  0.9950041652780258 | 0.8623188722876839 |  0.9950041652780258 | 0.8623188722876839
  0.9800665778412416 | 0.8623188722876839 |  0.9800665778412416 | 0.8623188722876839
   0.955336489125606 | 0.8623188722876839 |   0.955336489125606 | 0.8623188722876839
  0.4535961214255773 | 0.4871876750070059 |  0.4535961214255773 | 0.4871876750070059
 -0.5885011172553458 | 0.4871876750070059 | -0.5885011172553458 | 0.4871876750070059
 -0.9874797699088649 | 0.4871876750070059 | -0.9874797699088649 | 0.4871876750070059
(6 rows)

-- select cos (builtin function, not pushdown constraints, explain)
--Testcase 721:
EXPLAIN VERBOSE
SELECT cos((fields->>'value1')::float), cos((fields->>'value2')::bigint), cos((fields->>'value3')::float), cos((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
                                                                                                                      QUERY PLAN                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: cos(((fields ->> 'value1'::text))::double precision), cos((((fields ->> 'value2'::text))::bigint)::double precision), cos(((fields ->> 'value3'::text))::double precision), cos((((fields ->> 'value4'::text))::bigint)::double precision)
   Filter: (to_hex(((s3.fields ->> 'value2'::text))::bigint) <> '64'::text)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(4 rows)

-- select cos (builtin function, not pushdown constraints, result)
--Testcase 722:
SELECT cos((fields->>'value1')::float), cos((fields->>'value2')::bigint), cos((fields->>'value3')::float), cos((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
         cos         |        cos         |         cos         |        cos         
---------------------+--------------------+---------------------+--------------------
  0.4535961214255773 | 0.4871876750070059 |  0.4535961214255773 | 0.4871876750070059
 -0.5885011172553458 | 0.4871876750070059 | -0.5885011172553458 | 0.4871876750070059
 -0.9874797699088649 | 0.4871876750070059 | -0.9874797699088649 | 0.4871876750070059
(3 rows)

-- select cos (builtin function, pushdown constraints, explain)
--Testcase 723:
EXPLAIN VERBOSE
SELECT cos((fields->>'value1')::float), cos((fields->>'value2')::bigint), cos((fields->>'value3')::float), cos((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                                                                                      QUERY PLAN                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: cos(((fields ->> 'value1'::text))::double precision), cos((((fields ->> 'value2'::text))::bigint)::double precision), cos(((fields ->> 'value3'::text))::double precision), cos((((fields ->> 'value4'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select cos (builtin function, pushdown constraints, result)
--Testcase 724:
SELECT cos((fields->>'value1')::float), cos((fields->>'value2')::bigint), cos((fields->>'value3')::float), cos((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
        cos         |        cos         |        cos         |        cos         
--------------------+--------------------+--------------------+--------------------
 0.9950041652780258 | 0.8623188722876839 | 0.9950041652780258 | 0.8623188722876839
 0.9800665778412416 | 0.8623188722876839 | 0.9800665778412416 | 0.8623188722876839
  0.955336489125606 | 0.8623188722876839 |  0.955336489125606 | 0.8623188722876839
(3 rows)

-- select cos as nest function with agg (pushdown, explain)
--Testcase 725:
EXPLAIN VERBOSE
SELECT sum((fields->>'value3')::float),cos(sum((fields->>'value3')::float)) FROM s3;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=16)
   Output: (sum(((fields ->> 'value3'::text))::double precision)), (cos(sum(((fields ->> 'value3'::text))::double precision)))
   InfluxDB query: SELECT sum("value3"), cos(sum("value3")) FROM "s3"
(3 rows)

-- select cos as nest function with agg (pushdown, result)
--Testcase 726:
SELECT sum((fields->>'value3')::float),cos(sum((fields->>'value3')::float)) FROM s3;
        sum         |        cos         
--------------------+--------------------
 -7.199999999999999 | 0.6083513145322552
(1 row)

-- select cos as nest with log2 (pushdown, explain)
--Testcase 727:
EXPLAIN VERBOSE
SELECT cos(log2((fields->>'value1')::float)),cos(log2(1/(fields->>'value1')::float)) FROM s3;
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2225.89 rows=1462 width=16)
   Output: cos(log2(((fields ->> 'value1'::text))::double precision)), cos(log2(('1'::double precision / ((fields ->> 'value1'::text))::double precision)))
   InfluxDB query: SELECT "value1" FROM "s3"
(3 rows)

-- select cos as nest with log2 (pushdown, result)
--Testcase 728:
SELECT cos(log2((fields->>'value1')::float)),cos(log2(1/(fields->>'value1')::float)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select cos with non pushdown func and explicit constant (explain)
--Testcase 729:
EXPLAIN VERBOSE
SELECT cos((fields->>'value3')::float), pi(), 4.1 FROM s3;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1476.62 rows=1462 width=48)
   Output: cos(((fields ->> 'value3'::text))::double precision), '3.141592653589793'::double precision, 4.1
   InfluxDB query: SELECT "value3" FROM "s3"
(3 rows)

-- select cos with non pushdown func and explicit constant (result)
--Testcase 730:
SELECT cos((fields->>'value3')::float), pi(), 4.1 FROM s3;
         cos         |        pi         | ?column? 
---------------------+-------------------+----------
  0.9950041652780258 | 3.141592653589793 |      4.1
  0.9800665778412416 | 3.141592653589793 |      4.1
   0.955336489125606 | 3.141592653589793 |      4.1
  0.4535961214255773 | 3.141592653589793 |      4.1
 -0.5885011172553458 | 3.141592653589793 |      4.1
 -0.9874797699088649 | 3.141592653589793 |      4.1
(6 rows)

-- select cos with order by (explain)
--Testcase 731:
EXPLAIN VERBOSE
SELECT (fields->>'value1')::float value1, cos(1-(fields->>'value1')::float) FROM s3 order by cos(1-(fields->>'value1')::float);
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1568.10..1571.75 rows=1462 width=16)
   Output: (((fields ->> 'value1'::text))::double precision), (cos(('1'::double precision - ((fields ->> 'value1'::text))::double precision)))
   Sort Key: (cos(('1'::double precision - ((s3.fields ->> 'value1'::text))::double precision)))
   ->  Foreign Scan on public.s3  (cost=10.00..1491.24 rows=1462 width=16)
         Output: ((fields ->> 'value1'::text))::double precision, cos(('1'::double precision - ((fields ->> 'value1'::text))::double precision))
         InfluxDB query: SELECT "value1" FROM "s3"
(6 rows)

-- select cos with order by (result)
--Testcase 732:
SELECT (fields->>'value1')::float value1, cos(1-(fields->>'value1')::float) FROM s3 order by cos(1-(fields->>'value1')::float);
 value1 |         cos         
--------+---------------------
    3.3 | -0.6662760212798241
    2.2 |  0.3623577544766734
    0.1 |  0.6216099682706644
    0.2 |  0.6967067093471654
    0.3 |  0.7648421872844885
    1.1 |  0.9950041652780257
(6 rows)

-- select cos with order by index (result)
--Testcase 733:
SELECT (fields->>'value1')::float value1, cos(1-(fields->>'value1')::float) FROM s3 order by 2,1;
 value1 |         cos         
--------+---------------------
    3.3 | -0.6662760212798241
    2.2 |  0.3623577544766734
    0.1 |  0.6216099682706644
    0.2 |  0.6967067093471654
    0.3 |  0.7648421872844885
    1.1 |  0.9950041652780257
(6 rows)

-- select cos with order by index (result)
--Testcase 734:
SELECT (fields->>'value1')::float value1, cos(1-(fields->>'value1')::float) FROM s3 order by 1,2;
 value1 |         cos         
--------+---------------------
    0.1 |  0.6216099682706644
    0.2 |  0.6967067093471654
    0.3 |  0.7648421872844885
    1.1 |  0.9950041652780257
    2.2 |  0.3623577544766734
    3.3 | -0.6662760212798241
(6 rows)

-- select cos and as
--Testcase 735:
SELECT cos((fields->>'value3')::float) as cos1 FROM s3;
        cos1         
---------------------
  0.9950041652780258
  0.9800665778412416
   0.955336489125606
  0.4535961214255773
 -0.5885011172553458
 -0.9874797699088649
(6 rows)

-- select cos(*) (stub agg function, explain)
--Testcase 736:
EXPLAIN VERBOSE
SELECT cos_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: cos_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select cos(*) (stub agg function, result)
--Testcase 737:
SELECT cos_all() from s3;
ERROR:  stub cos_all() is called
CONTEXT:  PL/pgSQL function cos_all() line 3 at RAISE
-- select cos(*) (stub agg function and group by tag only) (explain)
--Testcase 738:
EXPLAIN VERBOSE
SELECT cos_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (cos_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT cos(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select cos(*) (stub agg function and group by tag only) (result)
--Testcase 739:
SELECT cos_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                     cos_all                                                                                      
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.9950041652780257\",\"value2\" : \"0.8623188722876839\",\"value3\" : \"0.9950041652780257\",\"value4\" : \"0.8623188722876839\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.9800665778412416\",\"value2\" : \"0.8623188722876839\",\"value3\" : \"0.9800665778412416\",\"value4\" : \"0.8623188722876839\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.955336489125606\",\"value2\" : \"0.8623188722876839\",\"value3\" : \"0.955336489125606\",\"value4\" : \"0.8623188722876839\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"0.4535961214255773\",\"value2\" : \"0.48718767500700594\",\"value3\" : \"0.4535961214255773\",\"value4\" : \"0.48718767500700594\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"-0.5885011172553458\",\"value2\" : \"0.48718767500700594\",\"value3\" : \"-0.5885011172553458\",\"value4\" : \"0.48718767500700594\" }")
(5 rows)

-- select exp (builtin function, explain)
--Testcase 740:
EXPLAIN VERBOSE
SELECT exp((fields->>'value1')::float), exp((fields->>'value2')::bigint), exp((fields->>'value3')::float), exp((fields->>'value4')::bigint) FROM s3;
                                                                                                                      QUERY PLAN                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1527.79 rows=1462 width=32)
   Output: exp(((fields ->> 'value1'::text))::double precision), exp((((fields ->> 'value2'::text))::bigint)::double precision), exp(((fields ->> 'value3'::text))::double precision), exp((((fields ->> 'value4'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

-- select exp (builtin function, result)
--Testcase 741:
SELECT exp((fields->>'value1')::float), exp((fields->>'value2')::bigint), exp((fields->>'value3')::float), exp((fields->>'value4')::bigint) FROM s3;
        exp         |          exp           |         exp          |          exp           
--------------------+------------------------+----------------------+------------------------
 1.1051709180756477 | 2.6881171418161356e+43 |   0.9048374180359595 |  3.720075976020836e-44
 1.2214027581601699 | 2.6881171418161356e+43 |   0.8187307530779818 |  3.720075976020836e-44
 1.3498588075760032 | 2.6881171418161356e+43 |   0.7408182206817179 |  3.720075976020836e-44
 3.0041660239464334 |  7.225973768125749e+86 |  0.33287108369807955 | 1.3838965267367376e-87
  9.025013499434122 |  7.225973768125749e+86 |  0.11080315836233387 | 1.3838965267367376e-87
 27.112638920657883 |  7.225973768125749e+86 | 0.036883167401240015 | 1.3838965267367376e-87
(6 rows)

-- select exp (builtin function, not pushdown constraints, explain)
--Testcase 742:
EXPLAIN VERBOSE
SELECT exp((fields->>'value1')::float), exp((fields->>'value2')::bigint), exp((fields->>'value3')::float), exp((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
                                                                                                                      QUERY PLAN                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: exp(((fields ->> 'value1'::text))::double precision), exp((((fields ->> 'value2'::text))::bigint)::double precision), exp(((fields ->> 'value3'::text))::double precision), exp((((fields ->> 'value4'::text))::bigint)::double precision)
   Filter: (to_hex(((s3.fields ->> 'value2'::text))::bigint) <> '64'::text)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(4 rows)

-- select exp (builtin function, not pushdown constraints, result)
--Testcase 743:
SELECT exp((fields->>'value1')::float), exp((fields->>'value2')::bigint), exp((fields->>'value3')::float), exp((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
        exp         |          exp          |         exp          |          exp           
--------------------+-----------------------+----------------------+------------------------
 3.0041660239464334 | 7.225973768125749e+86 |  0.33287108369807955 | 1.3838965267367376e-87
  9.025013499434122 | 7.225973768125749e+86 |  0.11080315836233387 | 1.3838965267367376e-87
 27.112638920657883 | 7.225973768125749e+86 | 0.036883167401240015 | 1.3838965267367376e-87
(3 rows)

-- select exp (builtin function, pushdown constraints, explain)
--Testcase 744:
EXPLAIN VERBOSE
SELECT exp((fields->>'value1')::float), exp((fields->>'value2')::bigint), exp((fields->>'value3')::float), exp((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                                                                                      QUERY PLAN                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: exp(((fields ->> 'value1'::text))::double precision), exp((((fields ->> 'value2'::text))::bigint)::double precision), exp(((fields ->> 'value3'::text))::double precision), exp((((fields ->> 'value4'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select exp (builtin function, pushdown constraints, result)
--Testcase 745:
SELECT exp((fields->>'value1')::float), exp((fields->>'value2')::bigint), exp((fields->>'value3')::float), exp((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
        exp         |          exp           |        exp         |          exp          
--------------------+------------------------+--------------------+-----------------------
 1.1051709180756477 | 2.6881171418161356e+43 | 0.9048374180359595 | 3.720075976020836e-44
 1.2214027581601699 | 2.6881171418161356e+43 | 0.8187307530779818 | 3.720075976020836e-44
 1.3498588075760032 | 2.6881171418161356e+43 | 0.7408182206817179 | 3.720075976020836e-44
(3 rows)

-- select exp as nest function with agg (pushdown, explain)
--Testcase 746:
EXPLAIN VERBOSE
SELECT sum((fields->>'value3')::float),exp(sum((fields->>'value3')::float)) FROM s3;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=16)
   Output: (sum(((fields ->> 'value3'::text))::double precision)), (exp(sum(((fields ->> 'value3'::text))::double precision)))
   InfluxDB query: SELECT sum("value3"), exp(sum("value3")) FROM "s3"
(3 rows)

-- select exp as nest function with agg (pushdown, result)
--Testcase 747:
SELECT sum((fields->>'value3')::float),exp(sum((fields->>'value3')::float)) FROM s3;
        sum         |          exp          
--------------------+-----------------------
 -7.199999999999999 | 0.0007465858083766799
(1 row)

-- select exp as nest with log2 (pushdown, explain)
--Testcase 748:
EXPLAIN VERBOSE
SELECT exp(log2((fields->>'value1')::float)),exp(log2(1/(fields->>'value1')::float)) FROM s3;
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2225.89 rows=1462 width=16)
   Output: exp(log2(((fields ->> 'value1'::text))::double precision)), exp(log2(('1'::double precision / ((fields ->> 'value1'::text))::double precision)))
   InfluxDB query: SELECT "value1" FROM "s3"
(3 rows)

-- select exp as nest with log2 (pushdown, result)
--Testcase 749:
SELECT exp(log2((fields->>'value1')::float)),exp(log2(1/(fields->>'value1')::float)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select exp with non pushdown func and explicit constant (explain)
--Testcase 750:
EXPLAIN VERBOSE
SELECT exp((fields->>'value3')::float), pi(), 4.1 FROM s3;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1476.62 rows=1462 width=48)
   Output: exp(((fields ->> 'value3'::text))::double precision), '3.141592653589793'::double precision, 4.1
   InfluxDB query: SELECT "value3" FROM "s3"
(3 rows)

-- select exp with non pushdown func and explicit constant (result)
--Testcase 751:
SELECT exp((fields->>'value3')::float), pi(), 4.1 FROM s3;
         exp          |        pi         | ?column? 
----------------------+-------------------+----------
   0.9048374180359595 | 3.141592653589793 |      4.1
   0.8187307530779818 | 3.141592653589793 |      4.1
   0.7408182206817179 | 3.141592653589793 |      4.1
  0.33287108369807955 | 3.141592653589793 |      4.1
  0.11080315836233387 | 3.141592653589793 |      4.1
 0.036883167401240015 | 3.141592653589793 |      4.1
(6 rows)

-- select exp with order by (explain)
--Testcase 752:
EXPLAIN VERBOSE
SELECT (fields->>'value1')::float value1, exp(1-(fields->>'value1')::float) FROM s3 order by exp(1-(fields->>'value1')::float);
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1568.10..1571.75 rows=1462 width=16)
   Output: (((fields ->> 'value1'::text))::double precision), (exp(('1'::double precision - ((fields ->> 'value1'::text))::double precision)))
   Sort Key: (exp(('1'::double precision - ((s3.fields ->> 'value1'::text))::double precision)))
   ->  Foreign Scan on public.s3  (cost=10.00..1491.24 rows=1462 width=16)
         Output: ((fields ->> 'value1'::text))::double precision, exp(('1'::double precision - ((fields ->> 'value1'::text))::double precision))
         InfluxDB query: SELECT "value1" FROM "s3"
(6 rows)

-- select exp with order by (result)
--Testcase 753:
SELECT (fields->>'value1')::float value1, exp(1-(fields->>'value1')::float) FROM s3 order by exp(1-(fields->>'value1')::float);
 value1 |         exp         
--------+---------------------
    3.3 | 0.10025884372280375
    2.2 |   0.301194211912202
    1.1 |  0.9048374180359595
    0.3 |  2.0137527074704766
    0.2 |   2.225540928492468
    0.1 |    2.45960311115695
(6 rows)

-- select exp with order by index (result)
--Testcase 754:
SELECT (fields->>'value1')::float value1, exp(1-(fields->>'value1')::float) FROM s3 order by 2,1;
 value1 |         exp         
--------+---------------------
    3.3 | 0.10025884372280375
    2.2 |   0.301194211912202
    1.1 |  0.9048374180359595
    0.3 |  2.0137527074704766
    0.2 |   2.225540928492468
    0.1 |    2.45960311115695
(6 rows)

-- select exp with order by index (result)
--Testcase 755:
SELECT (fields->>'value1')::float value1, exp(1-(fields->>'value1')::float) FROM s3 order by 1,2;
 value1 |         exp         
--------+---------------------
    0.1 |    2.45960311115695
    0.2 |   2.225540928492468
    0.3 |  2.0137527074704766
    1.1 |  0.9048374180359595
    2.2 |   0.301194211912202
    3.3 | 0.10025884372280375
(6 rows)

-- select exp and as
--Testcase 756:
SELECT exp((fields->>'value3')::float) as exp1 FROM s3;
         exp1         
----------------------
   0.9048374180359595
   0.8187307530779818
   0.7408182206817179
  0.33287108369807955
  0.11080315836233387
 0.036883167401240015
(6 rows)

-- select exp(*) (stub agg function, explain)
--Testcase 757:
EXPLAIN VERBOSE
SELECT exp_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: exp_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select exp(*) (stub agg function, result)
--Testcase 758:
SELECT exp_all() from s3;
ERROR:  stub exp_all() is called
CONTEXT:  PL/pgSQL function exp_all() line 3 at RAISE
-- select exp(*) (stub agg function and group by tag only) (explain)
--Testcase 759:
EXPLAIN VERBOSE
SELECT exp_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (exp_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT exp(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select exp(*) (stub agg function and group by tag only) (result)
--Testcase 760:
SELECT exp_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                       exp_all                                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1.1051709180756477\",\"value2\" : \"2.6881171418161356e+43\",\"value3\" : \"0.9048374180359595\",\"value4\" : \"3.720075976020836e-44\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"1.2214027581601699\",\"value2\" : \"2.6881171418161356e+43\",\"value3\" : \"0.8187307530779819\",\"value4\" : \"3.720075976020836e-44\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"1.3498588075760032\",\"value2\" : \"2.6881171418161356e+43\",\"value3\" : \"0.7408182206817179\",\"value4\" : \"3.720075976020836e-44\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"3.0041660239464334\",\"value2\" : \"7.22597376812575e+86\",\"value3\" : \"0.3328710836980795\",\"value4\" : \"1.3838965267367376e-87\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"9.025013499434122\",\"value2\" : \"7.22597376812575e+86\",\"value3\" : \"0.11080315836233386\",\"value4\" : \"1.3838965267367376e-87\" }")
(5 rows)

-- select multiple star functions (do not push down, raise warning and stub error) (result)
--Testcase 761:
SELECT ceil_all(), cos_all(), exp_all() FROM s3;
ERROR:  stub ceil_all() is called
CONTEXT:  PL/pgSQL function ceil_all() line 3 at RAISE
-- select floor (builtin function, explain)
--Testcase 762:
EXPLAIN VERBOSE
SELECT floor((fields->>'value1')::float), floor((fields->>'value2')::bigint), floor((fields->>'value3')::float), floor((fields->>'value4')::bigint) FROM s3;
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1527.79 rows=1462 width=32)
   Output: floor(((fields ->> 'value1'::text))::double precision), floor((((fields ->> 'value2'::text))::bigint)::double precision), floor(((fields ->> 'value3'::text))::double precision), floor((((fields ->> 'value4'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

-- select floor (builtin function, result)
--Testcase 763:
SELECT floor((fields->>'value1')::float), floor((fields->>'value2')::bigint), floor((fields->>'value3')::float), floor((fields->>'value4')::bigint) FROM s3;
 floor | floor | floor | floor 
-------+-------+-------+-------
     0 |   100 |    -1 |  -100
     0 |   100 |    -1 |  -100
     0 |   100 |    -1 |  -100
     1 |   200 |    -2 |  -200
     2 |   200 |    -3 |  -200
     3 |   200 |    -4 |  -200
(6 rows)

-- select floor (builtin function, not pushdown constraints, explain)
--Testcase 764:
EXPLAIN VERBOSE
SELECT floor((fields->>'value1')::float), floor((fields->>'value2')::bigint), floor((fields->>'value3')::float), floor((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: floor(((fields ->> 'value1'::text))::double precision), floor((((fields ->> 'value2'::text))::bigint)::double precision), floor(((fields ->> 'value3'::text))::double precision), floor((((fields ->> 'value4'::text))::bigint)::double precision)
   Filter: (to_hex(((s3.fields ->> 'value2'::text))::bigint) <> '64'::text)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(4 rows)

-- select floor (builtin function, not pushdown constraints, result)
--Testcase 765:
SELECT floor((fields->>'value1')::float), floor((fields->>'value2')::bigint), floor((fields->>'value3')::float), floor((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
 floor | floor | floor | floor 
-------+-------+-------+-------
     1 |   200 |    -2 |  -200
     2 |   200 |    -3 |  -200
     3 |   200 |    -4 |  -200
(3 rows)

-- select floor (builtin function, pushdown constraints, explain)
--Testcase 766:
EXPLAIN VERBOSE
SELECT floor((fields->>'value1')::float), floor((fields->>'value2')::bigint), floor((fields->>'value3')::float), floor((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: floor(((fields ->> 'value1'::text))::double precision), floor((((fields ->> 'value2'::text))::bigint)::double precision), floor(((fields ->> 'value3'::text))::double precision), floor((((fields ->> 'value4'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select floor (builtin function, pushdown constraints, result)
--Testcase 767:
SELECT floor((fields->>'value1')::float), floor((fields->>'value2')::bigint), floor((fields->>'value3')::float), floor((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
 floor | floor | floor | floor 
-------+-------+-------+-------
     0 |   100 |    -1 |  -100
     0 |   100 |    -1 |  -100
     0 |   100 |    -1 |  -100
(3 rows)

-- select floor as nest function with agg (pushdown, explain)
--Testcase 768:
EXPLAIN VERBOSE
SELECT sum((fields->>'value3')::float),floor(sum((fields->>'value3')::float)) FROM s3;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=16)
   Output: (sum(((fields ->> 'value3'::text))::double precision)), (floor(sum(((fields ->> 'value3'::text))::double precision)))
   InfluxDB query: SELECT sum("value3"), floor(sum("value3")) FROM "s3"
(3 rows)

-- select floor as nest function with agg (pushdown, result)
--Testcase 769:
SELECT sum((fields->>'value3')::float),floor(sum((fields->>'value3')::float)) FROM s3;
        sum         | floor 
--------------------+-------
 -7.199999999999999 |    -8
(1 row)

-- select floor as nest with log2 (pushdown, explain)
--Testcase 770:
EXPLAIN VERBOSE
SELECT floor(log2((fields->>'value1')::float)),floor(log2(1/(fields->>'value1')::float)) FROM s3;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2225.89 rows=1462 width=16)
   Output: floor(log2(((fields ->> 'value1'::text))::double precision)), floor(log2(('1'::double precision / ((fields ->> 'value1'::text))::double precision)))
   InfluxDB query: SELECT "value1" FROM "s3"
(3 rows)

-- select floor as nest with log2 (pushdown, result)
--Testcase 771:
SELECT floor(log2((fields->>'value1')::float)),floor(log2(1/(fields->>'value1')::float)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select floor with non pushdown func and explicit constant (explain)
--Testcase 772:
EXPLAIN VERBOSE
SELECT floor((fields->>'value3')::float), pi(), 4.1 FROM s3;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1476.62 rows=1462 width=48)
   Output: floor(((fields ->> 'value3'::text))::double precision), '3.141592653589793'::double precision, 4.1
   InfluxDB query: SELECT "value3" FROM "s3"
(3 rows)

-- select floor with non pushdown func and explicit constant (result)
--Testcase 773:
SELECT floor((fields->>'value3')::float), pi(), 4.1 FROM s3;
 floor |        pi         | ?column? 
-------+-------------------+----------
    -1 | 3.141592653589793 |      4.1
    -1 | 3.141592653589793 |      4.1
    -1 | 3.141592653589793 |      4.1
    -2 | 3.141592653589793 |      4.1
    -3 | 3.141592653589793 |      4.1
    -4 | 3.141592653589793 |      4.1
(6 rows)

-- select floor with order by (explain)
--Testcase 774:
EXPLAIN VERBOSE
SELECT (fields->>'value1')::float value1, floor(1-(fields->>'value1')::float) FROM s3 order by floor(1-(fields->>'value1')::float);
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1568.10..1571.75 rows=1462 width=16)
   Output: (((fields ->> 'value1'::text))::double precision), (floor(('1'::double precision - ((fields ->> 'value1'::text))::double precision)))
   Sort Key: (floor(('1'::double precision - ((s3.fields ->> 'value1'::text))::double precision)))
   ->  Foreign Scan on public.s3  (cost=10.00..1491.24 rows=1462 width=16)
         Output: ((fields ->> 'value1'::text))::double precision, floor(('1'::double precision - ((fields ->> 'value1'::text))::double precision))
         InfluxDB query: SELECT "value1" FROM "s3"
(6 rows)

-- select floor with order by (result)
--Testcase 775:
SELECT (fields->>'value1')::float value1, floor(1-(fields->>'value1')::float) FROM s3 order by floor(1-(fields->>'value1')::float);
 value1 | floor 
--------+-------
    3.3 |    -3
    2.2 |    -2
    1.1 |    -1
    0.1 |     0
    0.2 |     0
    0.3 |     0
(6 rows)

-- select floor with order by index (result)
--Testcase 776:
SELECT (fields->>'value1')::float value1, floor(1-(fields->>'value1')::float) FROM s3 order by 2,1;
 value1 | floor 
--------+-------
    3.3 |    -3
    2.2 |    -2
    1.1 |    -1
    0.1 |     0
    0.2 |     0
    0.3 |     0
(6 rows)

-- select floor with order by index (result)
--Testcase 777:
SELECT (fields->>'value1')::float value1, floor(1-(fields->>'value1')::float) FROM s3 order by 1,2;
 value1 | floor 
--------+-------
    0.1 |     0
    0.2 |     0
    0.3 |     0
    1.1 |    -1
    2.2 |    -2
    3.3 |    -3
(6 rows)

-- select floor and as
--Testcase 778:
SELECT floor((fields->>'value3')::float) as floor1 FROM s3;
 floor1 
--------
     -1
     -1
     -1
     -2
     -3
     -4
(6 rows)

-- select floor(*) (stub agg function, explain)
--Testcase 779:
EXPLAIN VERBOSE
SELECT floor_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: floor_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select floor(*) (stub agg function, result)
--Testcase 780:
SELECT floor_all() from s3;
ERROR:  stub floor_all() is called
CONTEXT:  PL/pgSQL function floor_all() line 3 at RAISE
-- select floor(*) (stub agg function and group by tag only) (explain)
--Testcase 781:
EXPLAIN VERBOSE
SELECT floor_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (floor_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT floor(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select floor(*) (stub agg function and group by tag only) (result)
--Testcase 782:
SELECT floor_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                   floor_all                                                    
----------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0\",\"value2\" : \"100\",\"value3\" : \"-1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0\",\"value2\" : \"100\",\"value3\" : \"-1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0\",\"value2\" : \"100\",\"value3\" : \"-1\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1\",\"value2\" : \"200\",\"value3\" : \"-2\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2\",\"value2\" : \"200\",\"value3\" : \"-3\",\"value4\" : \"-200\" }")
(5 rows)

-- select floor(*) (stub agg function, expose data, explain)
--Testcase 783:
EXPLAIN VERBOSE
SELECT (floor_all()::s3).* from s3;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((floor_all())::s3)."time", ((floor_all())::s3).tags, ((floor_all())::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select floor(*) (stub agg function, expose data, result)
--Testcase 784:
SELECT (floor_all()::s3).* from s3;
ERROR:  stub floor_all() is called
CONTEXT:  PL/pgSQL function floor_all() line 3 at RAISE
-- select ln (builtin function, explain)
--Testcase 785:
EXPLAIN VERBOSE
SELECT ln((fields->>'value1')::float), ln((fields->>'value2')::bigint) FROM s3;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1494.89 rows=1462 width=16)
   Output: ln(((fields ->> 'value1'::text))::double precision), ln((((fields ->> 'value2'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2" FROM "s3"
(3 rows)

-- select ln (builtin function, result)
--Testcase 786:
SELECT ln((fields->>'value1')::float), ln((fields->>'value2')::bigint) FROM s3;
         ln          |        ln         
---------------------+-------------------
 -2.3025850929940455 | 4.605170185988092
 -1.6094379124341003 | 4.605170185988092
 -1.2039728043259361 | 4.605170185988092
 0.09531017980432493 | 5.298317366548036
  0.7884573603642703 | 5.298317366548036
  1.1939224684724346 | 5.298317366548036
(6 rows)

-- select ln (builtin function, not pushdown constraints, explain)
--Testcase 787:
EXPLAIN VERBOSE
SELECT ln((fields->>'value1')::float), ln((fields->>'value2')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1487.74 rows=1455 width=16)
   Output: ln(((fields ->> 'value1'::text))::double precision), ln((((fields ->> 'value2'::text))::bigint)::double precision)
   Filter: (to_hex(((s3.fields ->> 'value2'::text))::bigint) <> '64'::text)
   InfluxDB query: SELECT "value1", "value2" FROM "s3"
(4 rows)

-- select ln (builtin function, not pushdown constraints, result)
--Testcase 788:
SELECT ln((fields->>'value1')::float), ln((fields->>'value2')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
         ln          |        ln         
---------------------+-------------------
 0.09531017980432493 | 5.298317366548036
  0.7884573603642703 | 5.298317366548036
  1.1939224684724346 | 5.298317366548036
(3 rows)

-- select ln (builtin function, pushdown constraints, explain)
--Testcase 789:
EXPLAIN VERBOSE
SELECT ln((fields->>'value1')::float), ln((fields->>'value2')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1487.74 rows=1455 width=16)
   Output: ln(((fields ->> 'value1'::text))::double precision), ln((((fields ->> 'value2'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2" FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select ln (builtin function, pushdown constraints, result)
--Testcase 790:
SELECT ln((fields->>'value1')::float), ln((fields->>'value2')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
         ln          |        ln         
---------------------+-------------------
 -2.3025850929940455 | 4.605170185988092
 -1.6094379124341003 | 4.605170185988092
 -1.2039728043259361 | 4.605170185988092
(3 rows)

-- select ln as nest function with agg (pushdown, explain)
--Testcase 791:
EXPLAIN VERBOSE
SELECT sum((fields->>'value3')::float),ln(sum((fields->>'value3')::float)) FROM s3;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=16)
   Output: (sum(((fields ->> 'value3'::text))::double precision)), (ln(sum(((fields ->> 'value3'::text))::double precision)))
   InfluxDB query: SELECT sum("value3"), ln(sum("value3")) FROM "s3"
(3 rows)

-- select ln as nest function with agg (pushdown, result)
--Testcase 792:
SELECT sum((fields->>'value3')::float),ln(sum((fields->>'value3')::float)) FROM s3;
        sum         | ln 
--------------------+----
 -7.199999999999999 |   
(1 row)

-- select ln as nest with log2 (pushdown, explain)
--Testcase 793:
EXPLAIN VERBOSE
SELECT ln(log2((fields->>'value1')::float)),ln(log2(1/(fields->>'value1')::float)) FROM s3;
                                                                        QUERY PLAN                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2225.89 rows=1462 width=16)
   Output: ln(log2(((fields ->> 'value1'::text))::double precision)), ln(log2(('1'::double precision / ((fields ->> 'value1'::text))::double precision)))
   InfluxDB query: SELECT "value1" FROM "s3"
(3 rows)

-- select ln as nest with log2 (pushdown, result)
--Testcase 794:
SELECT ln(log2((fields->>'value1')::float)),ln(log2(1/(fields->>'value1')::float)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select ln with non pushdown func and explicit constant (explain)
--Testcase 795:
EXPLAIN VERBOSE
SELECT ln((fields->>'value3')::float), pi(), 4.1 FROM s3;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1476.62 rows=1462 width=48)
   Output: ln(((fields ->> 'value3'::text))::double precision), '3.141592653589793'::double precision, 4.1
   InfluxDB query: SELECT "value3" FROM "s3"
(3 rows)

-- select ln with non pushdown func and explicit constant (result)
--Testcase 796:
SELECT ln((fields->>'value3')::float), pi(), 4.1 FROM s3;
ERROR:  cannot take logarithm of a negative number
-- select ln with order by (explain)
--Testcase 797:
EXPLAIN VERBOSE
SELECT (fields->>'value1')::float value1, ln(1-(fields->>'value1')::float) FROM s3 order by ln(1-(fields->>'value1')::float);
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1568.10..1571.75 rows=1462 width=16)
   Output: (((fields ->> 'value1'::text))::double precision), (ln(('1'::double precision - ((fields ->> 'value1'::text))::double precision)))
   Sort Key: (ln(('1'::double precision - ((s3.fields ->> 'value1'::text))::double precision)))
   ->  Foreign Scan on public.s3  (cost=10.00..1491.24 rows=1462 width=16)
         Output: ((fields ->> 'value1'::text))::double precision, ln(('1'::double precision - ((fields ->> 'value1'::text))::double precision))
         InfluxDB query: SELECT "value1" FROM "s3"
(6 rows)

-- select ln with order by (result)
--Testcase 798:
SELECT (fields->>'value1')::float value1, ln(1-(fields->>'value1')::float) FROM s3 order by ln(1-(fields->>'value1')::float);
ERROR:  cannot take logarithm of a negative number
-- select ln with order by index (result)
--Testcase 799:
SELECT (fields->>'value1')::float value1, ln(1-(fields->>'value1')::float) FROM s3 order by 2,1;
ERROR:  cannot take logarithm of a negative number
-- select ln with order by index (result)
--Testcase 800:
SELECT (fields->>'value1')::float value1, ln(1-(fields->>'value1')::float) FROM s3 order by 1,2;
ERROR:  cannot take logarithm of a negative number
-- select ln and as
--Testcase 801:
SELECT ln((fields->>'value1')::float) as ln1 FROM s3;
         ln1         
---------------------
 -2.3025850929940455
 -1.6094379124341003
 -1.2039728043259361
 0.09531017980432493
  0.7884573603642703
  1.1939224684724346
(6 rows)

-- select ln(*) (stub agg function, explain)
--Testcase 802:
EXPLAIN VERBOSE
SELECT ln_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: ln_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select ln(*) (stub agg function, result)
--Testcase 803:
SELECT ln_all() from s3;
ERROR:  stub ln_all() is called
CONTEXT:  PL/pgSQL function ln_all() line 3 at RAISE
-- select ln(*) (stub agg function and group by tag only) (explain)
--Testcase 804:
EXPLAIN VERBOSE
SELECT ln_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (ln_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT ln(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select ln(*) (stub agg function and group by tag only) (result)
--Testcase 805:
SELECT ln_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                  ln_all                                                                  
------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"-2.3025850929940455\",\"value2\" : \"4.605170185988092\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"-1.6094379124341003\",\"value2\" : \"4.605170185988092\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"-1.2039728043259361\",\"value2\" : \"4.605170185988092\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"0.09531017980432493\",\"value2\" : \"5.298317366548036\",\"value3\" : null,\"value4\" : null }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"0.7884573603642703\",\"value2\" : \"5.298317366548036\",\"value3\" : null,\"value4\" : null }")
(5 rows)

-- select multiple star functions (do not push down, raise warning and stub error) (result)
--Testcase 806:
SELECT ln_all(), floor_all() FROM s3;
ERROR:  stub ln_all() is called
CONTEXT:  PL/pgSQL function ln_all() line 3 at RAISE
-- select pow (builtin function, explain)
--Testcase 807:
EXPLAIN VERBOSE
SELECT pow((fields->>'value1')::float, 2), pow((fields->>'value2')::bigint, 2), pow((fields->>'value3')::float, 2), pow((fields->>'value4')::bigint, 2) FROM s3;
                                                                                                                                                                    QUERY PLAN                                                                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1527.79 rows=1462 width=32)
   Output: pow(((fields ->> 'value1'::text))::double precision, '2'::double precision), pow((((fields ->> 'value2'::text))::bigint)::double precision, '2'::double precision), pow(((fields ->> 'value3'::text))::double precision, '2'::double precision), pow((((fields ->> 'value4'::text))::bigint)::double precision, '2'::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

-- select pow (builtin function, result)
--Testcase 808:
SELECT pow((fields->>'value1')::float, 2), pow((fields->>'value2')::bigint, 2), pow((fields->>'value3')::float, 2), pow((fields->>'value4')::bigint, 2) FROM s3;
         pow          |  pow  |         pow          |  pow  
----------------------+-------+----------------------+-------
 0.010000000000000002 | 10000 | 0.010000000000000002 | 10000
  0.04000000000000001 | 10000 |  0.04000000000000001 | 10000
                 0.09 | 10000 |                 0.09 | 10000
   1.2100000000000002 | 40000 |   1.2100000000000002 | 40000
    4.840000000000001 | 40000 |    4.840000000000001 | 40000
   10.889999999999999 | 40000 |   10.889999999999999 | 40000
(6 rows)

-- select pow (builtin function, not pushdown constraints, explain)
--Testcase 809:
EXPLAIN VERBOSE
SELECT pow((fields->>'value1')::float, 2), pow((fields->>'value2')::bigint, 2), pow((fields->>'value3')::float, 2), pow((fields->>'value4')::bigint, 2) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
                                                                                                                                                                    QUERY PLAN                                                                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: pow(((fields ->> 'value1'::text))::double precision, '2'::double precision), pow((((fields ->> 'value2'::text))::bigint)::double precision, '2'::double precision), pow(((fields ->> 'value3'::text))::double precision, '2'::double precision), pow((((fields ->> 'value4'::text))::bigint)::double precision, '2'::double precision)
   Filter: (to_hex(((s3.fields ->> 'value2'::text))::bigint) <> '64'::text)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(4 rows)

-- select pow (builtin function, not pushdown constraints, result)
--Testcase 810:
SELECT pow((fields->>'value1')::float, 2), pow((fields->>'value2')::bigint, 2), pow((fields->>'value3')::float, 2), pow((fields->>'value4')::bigint, 2) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
        pow         |  pow  |        pow         |  pow  
--------------------+-------+--------------------+-------
 1.2100000000000002 | 40000 | 1.2100000000000002 | 40000
  4.840000000000001 | 40000 |  4.840000000000001 | 40000
 10.889999999999999 | 40000 | 10.889999999999999 | 40000
(3 rows)

-- select pow (builtin function, pushdown constraints, explain)
--Testcase 811:
EXPLAIN VERBOSE
SELECT pow((fields->>'value1')::float, 2), pow((fields->>'value2')::bigint, 2), pow((fields->>'value3')::float, 2), pow((fields->>'value4')::bigint, 2) FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                                                                                                                                    QUERY PLAN                                                                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: pow(((fields ->> 'value1'::text))::double precision, '2'::double precision), pow((((fields ->> 'value2'::text))::bigint)::double precision, '2'::double precision), pow(((fields ->> 'value3'::text))::double precision, '2'::double precision), pow((((fields ->> 'value4'::text))::bigint)::double precision, '2'::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select pow (builtin function, pushdown constraints, result)
--Testcase 812:
SELECT pow((fields->>'value1')::float, 2), pow((fields->>'value2')::bigint, 2), pow((fields->>'value3')::float, 2), pow((fields->>'value4')::bigint, 2) FROM s3 WHERE (fields->>'value2')::bigint != 200;
         pow          |  pow  |         pow          |  pow  
----------------------+-------+----------------------+-------
 0.010000000000000002 | 10000 | 0.010000000000000002 | 10000
  0.04000000000000001 | 10000 |  0.04000000000000001 | 10000
                 0.09 | 10000 |                 0.09 | 10000
(3 rows)

-- select pow as nest function with agg (pushdown, explain)
--Testcase 813:
EXPLAIN VERBOSE
SELECT sum((fields->>'value3')::float),pow(sum((fields->>'value3')::float), 2) FROM s3;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=16)
   Output: (sum(((fields ->> 'value3'::text))::double precision)), (pow(sum(((fields ->> 'value3'::text))::double precision), '2'::double precision))
   InfluxDB query: SELECT sum("value3"), pow(sum("value3"), 2) FROM "s3"
(3 rows)

-- select pow as nest function with agg (pushdown, result)
--Testcase 814:
SELECT sum((fields->>'value3')::float),pow(sum((fields->>'value3')::float), 2) FROM s3;
        sum         |        pow        
--------------------+-------------------
 -7.199999999999999 | 51.83999999999999
(1 row)

-- select pow as nest with log2 (pushdown, explain)
--Testcase 815:
EXPLAIN VERBOSE
SELECT pow(log2((fields->>'value1')::float), 2),pow(log2(1/(fields->>'value1')::float), 2) FROM s3;
                                                                                                QUERY PLAN                                                                                                
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2225.89 rows=1462 width=16)
   Output: pow(log2(((fields ->> 'value1'::text))::double precision), '2'::double precision), pow(log2(('1'::double precision / ((fields ->> 'value1'::text))::double precision)), '2'::double precision)
   InfluxDB query: SELECT "value1" FROM "s3"
(3 rows)

-- select pow as nest with log2 (pushdown, result)
--Testcase 816:
SELECT pow(log2((fields->>'value1')::float), 2),pow(log2(1/(fields->>'value1')::float), 2) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select pow with non pushdown func and explicit constant (explain)
--Testcase 817:
EXPLAIN VERBOSE
SELECT pow((fields->>'value3')::float, 2), pi(), 4.1 FROM s3;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1476.62 rows=1462 width=48)
   Output: pow(((fields ->> 'value3'::text))::double precision, '2'::double precision), '3.141592653589793'::double precision, 4.1
   InfluxDB query: SELECT "value3" FROM "s3"
(3 rows)

-- select pow with non pushdown func and explicit constant (result)
--Testcase 818:
SELECT pow((fields->>'value3')::float, 2), pi(), 4.1 FROM s3;
         pow          |        pi         | ?column? 
----------------------+-------------------+----------
 0.010000000000000002 | 3.141592653589793 |      4.1
  0.04000000000000001 | 3.141592653589793 |      4.1
                 0.09 | 3.141592653589793 |      4.1
   1.2100000000000002 | 3.141592653589793 |      4.1
    4.840000000000001 | 3.141592653589793 |      4.1
   10.889999999999999 | 3.141592653589793 |      4.1
(6 rows)

-- select pow with order by (explain)
--Testcase 819:
EXPLAIN VERBOSE
SELECT (fields->>'value1')::float value1, pow(1-(fields->>'value1')::float, 2) FROM s3 order by pow(1-(fields->>'value1')::float, 2);
                                                                               QUERY PLAN                                                                               
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1568.10..1571.75 rows=1462 width=16)
   Output: (((fields ->> 'value1'::text))::double precision), (pow(('1'::double precision - ((fields ->> 'value1'::text))::double precision), '2'::double precision))
   Sort Key: (pow(('1'::double precision - ((s3.fields ->> 'value1'::text))::double precision), '2'::double precision))
   ->  Foreign Scan on public.s3  (cost=10.00..1491.24 rows=1462 width=16)
         Output: ((fields ->> 'value1'::text))::double precision, pow(('1'::double precision - ((fields ->> 'value1'::text))::double precision), '2'::double precision)
         InfluxDB query: SELECT "value1" FROM "s3"
(6 rows)

-- select pow with order by (result)
--Testcase 820:
SELECT (fields->>'value1')::float value1, pow(1-(fields->>'value1')::float, 2) FROM s3 order by pow(1-(fields->>'value1')::float, 2);
 value1 |         pow          
--------+----------------------
    1.1 | 0.010000000000000018
    0.3 |  0.48999999999999994
    0.2 |   0.6400000000000001
    0.1 |                 0.81
    2.2 |   1.4400000000000004
    3.3 |    5.289999999999999
(6 rows)

-- select pow with order by index (result)
--Testcase 821:
SELECT (fields->>'value1')::float value1, pow(1-(fields->>'value1')::float, 2) FROM s3 order by 2,1;
 value1 |         pow          
--------+----------------------
    1.1 | 0.010000000000000018
    0.3 |  0.48999999999999994
    0.2 |   0.6400000000000001
    0.1 |                 0.81
    2.2 |   1.4400000000000004
    3.3 |    5.289999999999999
(6 rows)

-- select pow with order by index (result)
--Testcase 822:
SELECT (fields->>'value1')::float value1, pow(1-(fields->>'value1')::float, 2) FROM s3 order by 1,2;
 value1 |         pow          
--------+----------------------
    0.1 |                 0.81
    0.2 |   0.6400000000000001
    0.3 |  0.48999999999999994
    1.1 | 0.010000000000000018
    2.2 |   1.4400000000000004
    3.3 |    5.289999999999999
(6 rows)

-- select pow and as
--Testcase 823:
SELECT pow((fields->>'value3')::float, 2) as pow1 FROM s3;
         pow1         
----------------------
 0.010000000000000002
  0.04000000000000001
                 0.09
   1.2100000000000002
    4.840000000000001
   10.889999999999999
(6 rows)

-- select pow_all(2) (stub agg function, explain)
--Testcase 824:
EXPLAIN VERBOSE
SELECT pow_all(2) from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: pow_all(2)
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select pow_all(2) (stub agg function, result)
--Testcase 825:
SELECT pow_all(2) from s3;
ERROR:  stub pow_all(int) is called
CONTEXT:  PL/pgSQL function pow_all(integer) line 3 at RAISE
-- select pow_all(2) (stub agg function and group by tag only) (explain)
--Testcase 826:
EXPLAIN VERBOSE
SELECT pow_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (pow_all(2)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT pow(*, 2) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select pow_all(2) (stub agg function and group by tag only) (result)
--Testcase 827:
SELECT pow_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                        pow_all                                                                         
--------------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.010000000000000002\",\"value2\" : \"10000\",\"value3\" : \"0.010000000000000002\",\"value4\" : \"10000\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.04000000000000001\",\"value2\" : \"10000\",\"value3\" : \"0.04000000000000001\",\"value4\" : \"10000\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.09\",\"value2\" : \"10000\",\"value3\" : \"0.09\",\"value4\" : \"10000\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.2100000000000002\",\"value2\" : \"40000\",\"value3\" : \"1.2100000000000002\",\"value4\" : \"40000\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"4.840000000000001\",\"value2\" : \"40000\",\"value3\" : \"4.840000000000001\",\"value4\" : \"40000\" }")
(5 rows)

-- select pow_all(2) (stub agg function, expose data, explain)
--Testcase 828:
EXPLAIN VERBOSE
SELECT (pow_all(2)::s3).* from s3;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((pow_all(2))::s3)."time", ((pow_all(2))::s3).tags, ((pow_all(2))::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select pow_all(2) (stub agg function, expose data, result)
--Testcase 829:
SELECT (pow_all(2)::s3).* from s3;
ERROR:  stub pow_all(int) is called
CONTEXT:  PL/pgSQL function pow_all(integer) line 3 at RAISE
-- select round (builtin function, explain)
--Testcase 830:
EXPLAIN VERBOSE
SELECT round((fields->>'value1')::float), round((fields->>'value2')::bigint), round((fields->>'value3')::float), round((fields->>'value4')::bigint) FROM s3;
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1527.79 rows=1462 width=32)
   Output: round(((fields ->> 'value1'::text))::double precision), round((((fields ->> 'value2'::text))::bigint)::double precision), round(((fields ->> 'value3'::text))::double precision), round((((fields ->> 'value4'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

-- select round (builtin function, result)
--Testcase 831:
SELECT round((fields->>'value1')::float), round((fields->>'value2')::bigint), round((fields->>'value3')::float), round((fields->>'value4')::bigint) FROM s3;
 round | round | round | round 
-------+-------+-------+-------
     0 |   100 |    -0 |  -100
     0 |   100 |    -0 |  -100
     0 |   100 |    -0 |  -100
     1 |   200 |    -1 |  -200
     2 |   200 |    -2 |  -200
     3 |   200 |    -3 |  -200
(6 rows)

-- select round (builtin function, not pushdown constraints, explain)
--Testcase 832:
EXPLAIN VERBOSE
SELECT round((fields->>'value1')::float), round((fields->>'value2')::bigint), round((fields->>'value3')::float), round((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: round(((fields ->> 'value1'::text))::double precision), round((((fields ->> 'value2'::text))::bigint)::double precision), round(((fields ->> 'value3'::text))::double precision), round((((fields ->> 'value4'::text))::bigint)::double precision)
   Filter: (to_hex(((s3.fields ->> 'value2'::text))::bigint) <> '64'::text)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(4 rows)

-- select round (builtin function, not pushdown constraints, result)
--Testcase 833:
SELECT round((fields->>'value1')::float), round((fields->>'value2')::bigint), round((fields->>'value3')::float), round((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
 round | round | round | round 
-------+-------+-------+-------
     1 |   200 |    -1 |  -200
     2 |   200 |    -2 |  -200
     3 |   200 |    -3 |  -200
(3 rows)

-- select round (builtin function, pushdown constraints, explain)
--Testcase 834:
EXPLAIN VERBOSE
SELECT round((fields->>'value1')::float), round((fields->>'value2')::bigint), round((fields->>'value3')::float), round((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: round(((fields ->> 'value1'::text))::double precision), round((((fields ->> 'value2'::text))::bigint)::double precision), round(((fields ->> 'value3'::text))::double precision), round((((fields ->> 'value4'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select round (builtin function, pushdown constraints, result)
--Testcase 835:
SELECT round((fields->>'value1')::float), round((fields->>'value2')::bigint), round((fields->>'value3')::float), round((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
 round | round | round | round 
-------+-------+-------+-------
     0 |   100 |    -0 |  -100
     0 |   100 |    -0 |  -100
     0 |   100 |    -0 |  -100
(3 rows)

-- select round as nest function with agg (pushdown, explain)
--Testcase 836:
EXPLAIN VERBOSE
SELECT sum((fields->>'value3')::float),round(sum((fields->>'value3')::float)) FROM s3;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=16)
   Output: (sum(((fields ->> 'value3'::text))::double precision)), (round(sum(((fields ->> 'value3'::text))::double precision)))
   InfluxDB query: SELECT sum("value3"), round(sum("value3")) FROM "s3"
(3 rows)

-- select round as nest function with agg (pushdown, result)
--Testcase 837:
SELECT sum((fields->>'value3')::float),round(sum((fields->>'value3')::float)) FROM s3;
        sum         | round 
--------------------+-------
 -7.199999999999999 |    -7
(1 row)

-- select round as nest with log2 (pushdown, explain)
--Testcase 838:
EXPLAIN VERBOSE
SELECT round(log2((fields->>'value1')::float)),round(log2(1/(fields->>'value1')::float)) FROM s3;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2225.89 rows=1462 width=16)
   Output: round(log2(((fields ->> 'value1'::text))::double precision)), round(log2(('1'::double precision / ((fields ->> 'value1'::text))::double precision)))
   InfluxDB query: SELECT "value1" FROM "s3"
(3 rows)

-- select round as nest with log2 (pushdown, result)
--Testcase 839:
SELECT round(log2((fields->>'value1')::float)),round(log2(1/(fields->>'value1')::float)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select round with non pushdown func and roundlicit constant (explain)
--Testcase 840:
EXPLAIN VERBOSE
SELECT round((fields->>'value3')::float), pi(), 4.1 FROM s3;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1476.62 rows=1462 width=48)
   Output: round(((fields ->> 'value3'::text))::double precision), '3.141592653589793'::double precision, 4.1
   InfluxDB query: SELECT "value3" FROM "s3"
(3 rows)

-- select round with non pushdown func and roundlicit constant (result)
--Testcase 841:
SELECT round((fields->>'value3')::float), pi(), 4.1 FROM s3;
 round |        pi         | ?column? 
-------+-------------------+----------
    -0 | 3.141592653589793 |      4.1
    -0 | 3.141592653589793 |      4.1
    -0 | 3.141592653589793 |      4.1
    -1 | 3.141592653589793 |      4.1
    -2 | 3.141592653589793 |      4.1
    -3 | 3.141592653589793 |      4.1
(6 rows)

-- select round with order by (explain)
--Testcase 842:
EXPLAIN VERBOSE
SELECT (fields->>'value1')::float value1, round(1-(fields->>'value1')::float) FROM s3 order by round(1-(fields->>'value1')::float);
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1568.10..1571.75 rows=1462 width=16)
   Output: (((fields ->> 'value1'::text))::double precision), (round(('1'::double precision - ((fields ->> 'value1'::text))::double precision)))
   Sort Key: (round(('1'::double precision - ((s3.fields ->> 'value1'::text))::double precision)))
   ->  Foreign Scan on public.s3  (cost=10.00..1491.24 rows=1462 width=16)
         Output: ((fields ->> 'value1'::text))::double precision, round(('1'::double precision - ((fields ->> 'value1'::text))::double precision))
         InfluxDB query: SELECT "value1" FROM "s3"
(6 rows)

-- select round with order by (result)
--Testcase 843:
SELECT (fields->>'value1')::float value1, round(1-(fields->>'value1')::float) FROM s3 order by round(1-(fields->>'value1')::float);
 value1 | round 
--------+-------
    3.3 |    -2
    2.2 |    -1
    1.1 |    -0
    0.1 |     1
    0.2 |     1
    0.3 |     1
(6 rows)

-- select round with order by index (result)
--Testcase 844:
SELECT (fields->>'value1')::float value1, round(1-(fields->>'value1')::float) FROM s3 order by 2,1;
 value1 | round 
--------+-------
    3.3 |    -2
    2.2 |    -1
    1.1 |    -0
    0.1 |     1
    0.2 |     1
    0.3 |     1
(6 rows)

-- select round with order by index (result)
--Testcase 845:
SELECT (fields->>'value1')::float value1, round(1-(fields->>'value1')::float) FROM s3 order by 1,2;
 value1 | round 
--------+-------
    0.1 |     1
    0.2 |     1
    0.3 |     1
    1.1 |    -0
    2.2 |    -1
    3.3 |    -2
(6 rows)

-- select round and as
--Testcase 846:
SELECT round((fields->>'value3')::float) as round1 FROM s3;
 round1 
--------
     -0
     -0
     -0
     -1
     -2
     -3
(6 rows)

-- select round(*) (stub agg function, explain)
--Testcase 847:
EXPLAIN VERBOSE
SELECT round_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: round_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select round(*) (stub agg function, result)
--Testcase 848:
SELECT round_all() from s3;
ERROR:  stub round_all() is called
CONTEXT:  PL/pgSQL function round_all() line 3 at RAISE
-- select round(*) (stub agg function and group by tag only) (explain)
--Testcase 849:
EXPLAIN VERBOSE
SELECT round_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (round_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT round(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select round(*) (stub agg function and group by tag only) (result)
--Testcase 850:
SELECT round_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                   round_all                                                    
----------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0\",\"value2\" : \"100\",\"value3\" : \"-0\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0\",\"value2\" : \"100\",\"value3\" : \"-0\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0\",\"value2\" : \"100\",\"value3\" : \"-0\",\"value4\" : \"-100\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1\",\"value2\" : \"200\",\"value3\" : \"-1\",\"value4\" : \"-200\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"2\",\"value2\" : \"200\",\"value3\" : \"-2\",\"value4\" : \"-200\" }")
(5 rows)

-- select round(*) (stub agg function, expose data, explain)
--Testcase 851:
EXPLAIN VERBOSE
SELECT (round_all()::s3).* from s3;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..6023.94 rows=3413 width=72)
   Output: ((round_all())::s3)."time", ((round_all())::s3).tags, ((round_all())::s3).fields
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select round(*) (stub agg function, expose data, result)
--Testcase 852:
SELECT (round_all()::s3).* from s3;
ERROR:  stub round_all() is called
CONTEXT:  PL/pgSQL function round_all() line 3 at RAISE
-- select sin (builtin function, explain)
--Testcase 853:
EXPLAIN VERBOSE
SELECT sin((fields->>'value1')::float), sin((fields->>'value2')::bigint), sin((fields->>'value3')::float), sin((fields->>'value4')::bigint) FROM s3;
                                                                                                                      QUERY PLAN                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1527.79 rows=1462 width=32)
   Output: sin(((fields ->> 'value1'::text))::double precision), sin((((fields ->> 'value2'::text))::bigint)::double precision), sin(((fields ->> 'value3'::text))::double precision), sin((((fields ->> 'value4'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

-- select sin (builtin function, result)
--Testcase 854:
SELECT sin((fields->>'value1')::float), sin((fields->>'value2')::bigint), sin((fields->>'value3')::float), sin((fields->>'value4')::bigint) FROM s3;
         sin         |         sin         |         sin          |        sin         
---------------------+---------------------+----------------------+--------------------
 0.09983341664682815 | -0.5063656411097588 | -0.09983341664682815 | 0.5063656411097588
 0.19866933079506122 | -0.5063656411097588 | -0.19866933079506122 | 0.5063656411097588
 0.29552020666133955 | -0.5063656411097588 | -0.29552020666133955 | 0.5063656411097588
  0.8912073600614354 | -0.8732972972139946 |  -0.8912073600614354 | 0.8732972972139946
  0.8084964038195901 | -0.8732972972139946 |  -0.8084964038195901 | 0.8732972972139946
 -0.1577456941432482 | -0.8732972972139946 |   0.1577456941432482 | 0.8732972972139946
(6 rows)

-- select sin (builtin function, not pushdown constraints, explain)
--Testcase 855:
EXPLAIN VERBOSE
SELECT sin((fields->>'value1')::float), sin((fields->>'value2')::bigint), sin((fields->>'value3')::float), sin((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
                                                                                                                      QUERY PLAN                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: sin(((fields ->> 'value1'::text))::double precision), sin((((fields ->> 'value2'::text))::bigint)::double precision), sin(((fields ->> 'value3'::text))::double precision), sin((((fields ->> 'value4'::text))::bigint)::double precision)
   Filter: (to_hex(((s3.fields ->> 'value2'::text))::bigint) <> '64'::text)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(4 rows)

-- select sin (builtin function, not pushdown constraints, result)
--Testcase 856:
SELECT sin((fields->>'value1')::float), sin((fields->>'value2')::bigint), sin((fields->>'value3')::float), sin((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
         sin         |         sin         |         sin         |        sin         
---------------------+---------------------+---------------------+--------------------
  0.8912073600614354 | -0.8732972972139946 | -0.8912073600614354 | 0.8732972972139946
  0.8084964038195901 | -0.8732972972139946 | -0.8084964038195901 | 0.8732972972139946
 -0.1577456941432482 | -0.8732972972139946 |  0.1577456941432482 | 0.8732972972139946
(3 rows)

-- select sin (builtin function, pushdown constraints, explain)
--Testcase 857:
EXPLAIN VERBOSE
SELECT sin((fields->>'value1')::float), sin((fields->>'value2')::bigint), sin((fields->>'value3')::float), sin((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                                                                                      QUERY PLAN                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: sin(((fields ->> 'value1'::text))::double precision), sin((((fields ->> 'value2'::text))::bigint)::double precision), sin(((fields ->> 'value3'::text))::double precision), sin((((fields ->> 'value4'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select sin (builtin function, pushdown constraints, result)
--Testcase 858:
SELECT sin((fields->>'value1')::float), sin((fields->>'value2')::bigint), sin((fields->>'value3')::float), sin((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
         sin         |         sin         |         sin          |        sin         
---------------------+---------------------+----------------------+--------------------
 0.09983341664682815 | -0.5063656411097588 | -0.09983341664682815 | 0.5063656411097588
 0.19866933079506122 | -0.5063656411097588 | -0.19866933079506122 | 0.5063656411097588
 0.29552020666133955 | -0.5063656411097588 | -0.29552020666133955 | 0.5063656411097588
(3 rows)

-- select sin as nest function with agg (pushdown, explain)
--Testcase 859:
EXPLAIN VERBOSE
SELECT sum((fields->>'value3')::float),sin(sum((fields->>'value3')::float)) FROM s3;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=16)
   Output: (sum(((fields ->> 'value3'::text))::double precision)), (sin(sum(((fields ->> 'value3'::text))::double precision)))
   InfluxDB query: SELECT sum("value3"), sin(sum("value3")) FROM "s3"
(3 rows)

-- select sin as nest function with agg (pushdown, result)
--Testcase 860:
SELECT sum((fields->>'value3')::float),sin(sum((fields->>'value3')::float)) FROM s3;
        sum         |         sin         
--------------------+---------------------
 -7.199999999999999 | -0.7936678638491526
(1 row)

-- select sin as nest with log2 (pushdown, explain)
--Testcase 861:
EXPLAIN VERBOSE
SELECT sin(log2((fields->>'value1')::float)),sin(log2(1/(fields->>'value1')::float)) FROM s3;
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2225.89 rows=1462 width=16)
   Output: sin(log2(((fields ->> 'value1'::text))::double precision)), sin(log2(('1'::double precision / ((fields ->> 'value1'::text))::double precision)))
   InfluxDB query: SELECT "value1" FROM "s3"
(3 rows)

-- select sin as nest with log2 (pushdown, result)
--Testcase 862:
SELECT sin(log2((fields->>'value1')::float)),sin(log2(1/(fields->>'value1')::float)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select sin with non pushdown func and explicit constant (explain)
--Testcase 863:
EXPLAIN VERBOSE
SELECT sin((fields->>'value3')::float), pi(), 4.1 FROM s3;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1476.62 rows=1462 width=48)
   Output: sin(((fields ->> 'value3'::text))::double precision), '3.141592653589793'::double precision, 4.1
   InfluxDB query: SELECT "value3" FROM "s3"
(3 rows)

-- select sin with non pushdown func and explicit constant (result)
--Testcase 864:
SELECT sin((fields->>'value3')::float), pi(), 4.1 FROM s3;
         sin          |        pi         | ?column? 
----------------------+-------------------+----------
 -0.09983341664682815 | 3.141592653589793 |      4.1
 -0.19866933079506122 | 3.141592653589793 |      4.1
 -0.29552020666133955 | 3.141592653589793 |      4.1
  -0.8912073600614354 | 3.141592653589793 |      4.1
  -0.8084964038195901 | 3.141592653589793 |      4.1
   0.1577456941432482 | 3.141592653589793 |      4.1
(6 rows)

-- select sin with order by (explain)
--Testcase 865:
EXPLAIN VERBOSE
SELECT (fields->>'value1')::float value1, sin(1-(fields->>'value1')::float) FROM s3 order by sin(1-(fields->>'value1')::float);
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1568.10..1571.75 rows=1462 width=16)
   Output: (((fields ->> 'value1'::text))::double precision), (sin(('1'::double precision - ((fields ->> 'value1'::text))::double precision)))
   Sort Key: (sin(('1'::double precision - ((s3.fields ->> 'value1'::text))::double precision)))
   ->  Foreign Scan on public.s3  (cost=10.00..1491.24 rows=1462 width=16)
         Output: ((fields ->> 'value1'::text))::double precision, sin(('1'::double precision - ((fields ->> 'value1'::text))::double precision))
         InfluxDB query: SELECT "value1" FROM "s3"
(6 rows)

-- select sin with order by (result)
--Testcase 866:
SELECT (fields->>'value1')::float value1, sin(1-(fields->>'value1')::float) FROM s3 order by sin(1-(fields->>'value1')::float);
 value1 |         sin          
--------+----------------------
    2.2 |  -0.9320390859672264
    3.3 |  -0.7457052121767203
    1.1 | -0.09983341664682824
    0.3 |    0.644217687237691
    0.2 |   0.7173560908995228
    0.1 |   0.7833269096274834
(6 rows)

-- select sin with order by index (result)
--Testcase 867:
SELECT (fields->>'value1')::float value1, sin(1-(fields->>'value1')::float) FROM s3 order by 2,1;
 value1 |         sin          
--------+----------------------
    2.2 |  -0.9320390859672264
    3.3 |  -0.7457052121767203
    1.1 | -0.09983341664682824
    0.3 |    0.644217687237691
    0.2 |   0.7173560908995228
    0.1 |   0.7833269096274834
(6 rows)

-- select sin with order by index (result)
--Testcase 868:
SELECT (fields->>'value1')::float value1, sin(1-(fields->>'value1')::float) FROM s3 order by 1,2;
 value1 |         sin          
--------+----------------------
    0.1 |   0.7833269096274834
    0.2 |   0.7173560908995228
    0.3 |    0.644217687237691
    1.1 | -0.09983341664682824
    2.2 |  -0.9320390859672264
    3.3 |  -0.7457052121767203
(6 rows)

-- select sin and as
--Testcase 869:
SELECT sin((fields->>'value3')::float) as sin1 FROM s3;
         sin1         
----------------------
 -0.09983341664682815
 -0.19866933079506122
 -0.29552020666133955
  -0.8912073600614354
  -0.8084964038195901
   0.1577456941432482
(6 rows)

-- select sin(*) (stub agg function, explain)
--Testcase 870:
EXPLAIN VERBOSE
SELECT sin_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: sin_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select sin(*) (stub agg function, result)
--Testcase 871:
SELECT sin_all() from s3;
ERROR:  stub sin_all() is called
CONTEXT:  PL/pgSQL function sin_all() line 3 at RAISE
-- select sin(*) (stub agg function and group by tag only) (explain)
--Testcase 872:
EXPLAIN VERBOSE
SELECT sin_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (sin_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT sin(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select sin(*) (stub agg function and group by tag only) (result)
--Testcase 873:
SELECT sin_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                     sin_all                                                                                      
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.09983341664682815\",\"value2\" : \"-0.5063656411097588\",\"value3\" : \"-0.09983341664682815\",\"value4\" : \"0.5063656411097588\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.19866933079506122\",\"value2\" : \"-0.5063656411097588\",\"value3\" : \"-0.19866933079506122\",\"value4\" : \"0.5063656411097588\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.29552020666133955\",\"value2\" : \"-0.5063656411097588\",\"value3\" : \"-0.29552020666133955\",\"value4\" : \"0.5063656411097588\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"0.8912073600614354\",\"value2\" : \"-0.8732972972139945\",\"value3\" : \"-0.8912073600614354\",\"value4\" : \"0.8732972972139945\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"0.8084964038195901\",\"value2\" : \"-0.8732972972139945\",\"value3\" : \"-0.8084964038195901\",\"value4\" : \"0.8732972972139945\" }")
(5 rows)

-- select tan (builtin function, explain)
--Testcase 874:
EXPLAIN VERBOSE
SELECT tan((fields->>'value1')::float), tan((fields->>'value2')::bigint), tan((fields->>'value3')::float), tan((fields->>'value4')::bigint) FROM s3;
                                                                                                                      QUERY PLAN                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1527.79 rows=1462 width=32)
   Output: tan(((fields ->> 'value1'::text))::double precision), tan((((fields ->> 'value2'::text))::bigint)::double precision), tan(((fields ->> 'value3'::text))::double precision), tan((((fields ->> 'value4'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(3 rows)

-- select tan (builtin function, result)
--Testcase 875:
SELECT tan((fields->>'value1')::float), tan((fields->>'value2')::bigint), tan((fields->>'value3')::float), tan((fields->>'value4')::bigint) FROM s3;
         tan         |         tan         |         tan          |        tan         
---------------------+---------------------+----------------------+--------------------
 0.10033467208545055 | -0.5872139151569291 | -0.10033467208545055 | 0.5872139151569291
  0.2027100355086725 | -0.5872139151569291 |  -0.2027100355086725 | 0.5872139151569291
 0.30933624960962325 | -0.5872139151569291 | -0.30933624960962325 | 0.5872139151569291
  1.9647596572486523 | -1.7925274837903817 |  -1.9647596572486523 | 1.7925274837903817
 -1.3738230567687946 | -1.7925274837903817 |   1.3738230567687946 | 1.7925274837903817
 0.15974574766003222 | -1.7925274837903817 | -0.15974574766003222 | 1.7925274837903817
(6 rows)

-- select tan (builtin function, not pushdown constraints, explain)
--Testcase 876:
EXPLAIN VERBOSE
SELECT tan((fields->>'value1')::float), tan((fields->>'value2')::bigint), tan((fields->>'value3')::float), tan((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
                                                                                                                      QUERY PLAN                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: tan(((fields ->> 'value1'::text))::double precision), tan((((fields ->> 'value2'::text))::bigint)::double precision), tan(((fields ->> 'value3'::text))::double precision), tan((((fields ->> 'value4'::text))::bigint)::double precision)
   Filter: (to_hex(((s3.fields ->> 'value2'::text))::bigint) <> '64'::text)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3"
(4 rows)

-- select tan (builtin function, not pushdown constraints, result)
--Testcase 877:
SELECT tan((fields->>'value1')::float), tan((fields->>'value2')::bigint), tan((fields->>'value3')::float), tan((fields->>'value4')::bigint) FROM s3 WHERE to_hex((fields->>'value2')::bigint) != '64';
         tan         |         tan         |         tan          |        tan         
---------------------+---------------------+----------------------+--------------------
  1.9647596572486523 | -1.7925274837903817 |  -1.9647596572486523 | 1.7925274837903817
 -1.3738230567687946 | -1.7925274837903817 |   1.3738230567687946 | 1.7925274837903817
 0.15974574766003222 | -1.7925274837903817 | -0.15974574766003222 | 1.7925274837903817
(3 rows)

-- select tan (builtin function, pushdown constraints, explain)
--Testcase 878:
EXPLAIN VERBOSE
SELECT tan((fields->>'value1')::float), tan((fields->>'value2')::bigint), tan((fields->>'value3')::float), tan((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
                                                                                                                      QUERY PLAN                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1520.47 rows=1455 width=32)
   Output: tan(((fields ->> 'value1'::text))::double precision), tan((((fields ->> 'value2'::text))::bigint)::double precision), tan(((fields ->> 'value3'::text))::double precision), tan((((fields ->> 'value4'::text))::bigint)::double precision)
   InfluxDB query: SELECT "value1", "value2", "value3", "value4" FROM "s3" WHERE (("value2" <> 200))
(3 rows)

-- select tan (builtin function, pushdown constraints, result)
--Testcase 879:
SELECT tan((fields->>'value1')::float), tan((fields->>'value2')::bigint), tan((fields->>'value3')::float), tan((fields->>'value4')::bigint) FROM s3 WHERE (fields->>'value2')::bigint != 200;
         tan         |         tan         |         tan          |        tan         
---------------------+---------------------+----------------------+--------------------
 0.10033467208545055 | -0.5872139151569291 | -0.10033467208545055 | 0.5872139151569291
  0.2027100355086725 | -0.5872139151569291 |  -0.2027100355086725 | 0.5872139151569291
 0.30933624960962325 | -0.5872139151569291 | -0.30933624960962325 | 0.5872139151569291
(3 rows)

-- select tan as nest function with agg (pushdown, explain)
--Testcase 880:
EXPLAIN VERBOSE
SELECT sum((fields->>'value3')::float),tan(sum((fields->>'value3')::float)) FROM s3;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=16)
   Output: (sum(((fields ->> 'value3'::text))::double precision)), (tan(sum(((fields ->> 'value3'::text))::double precision)))
   InfluxDB query: SELECT sum("value3"), tan(sum("value3")) FROM "s3"
(3 rows)

-- select tan as nest function with agg (pushdown, result)
--Testcase 881:
SELECT sum((fields->>'value3')::float),tan(sum((fields->>'value3')::float)) FROM s3;
        sum         |         tan         
--------------------+---------------------
 -7.199999999999999 | -1.3046209400556357
(1 row)

-- select tan as nest with log2 (pushdown, explain)
--Testcase 882:
EXPLAIN VERBOSE
SELECT tan(log2((fields->>'value1')::float)),tan(log2(1/(fields->>'value1')::float)) FROM s3;
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..2225.89 rows=1462 width=16)
   Output: tan(log2(((fields ->> 'value1'::text))::double precision)), tan(log2(('1'::double precision / ((fields ->> 'value1'::text))::double precision)))
   InfluxDB query: SELECT "value1" FROM "s3"
(3 rows)

-- select tan as nest with log2 (pushdown, result)
--Testcase 883:
SELECT tan(log2((fields->>'value1')::float)),tan(log2(1/(fields->>'value1')::float)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select tan with non pushdown func and tanlicit constant (explain)
--Testcase 884:
EXPLAIN VERBOSE
SELECT tan((fields->>'value3')::float), pi(), 4.1 FROM s3;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..1476.62 rows=1462 width=48)
   Output: tan(((fields ->> 'value3'::text))::double precision), '3.141592653589793'::double precision, 4.1
   InfluxDB query: SELECT "value3" FROM "s3"
(3 rows)

-- select tan with non pushdown func and tanlicit constant (result)
--Testcase 885:
SELECT tan((fields->>'value3')::float), pi(), 4.1 FROM s3;
         tan          |        pi         | ?column? 
----------------------+-------------------+----------
 -0.10033467208545055 | 3.141592653589793 |      4.1
  -0.2027100355086725 | 3.141592653589793 |      4.1
 -0.30933624960962325 | 3.141592653589793 |      4.1
  -1.9647596572486523 | 3.141592653589793 |      4.1
   1.3738230567687946 | 3.141592653589793 |      4.1
 -0.15974574766003222 | 3.141592653589793 |      4.1
(6 rows)

-- select tan with order by (explain)
--Testcase 886:
EXPLAIN VERBOSE
SELECT (fields->>'value1')::float value1, tan(1-(fields->>'value1')::float) FROM s3 order by tan(1-(fields->>'value1')::float);
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1568.10..1571.75 rows=1462 width=16)
   Output: (((fields ->> 'value1'::text))::double precision), (tan(('1'::double precision - ((fields ->> 'value1'::text))::double precision)))
   Sort Key: (tan(('1'::double precision - ((s3.fields ->> 'value1'::text))::double precision)))
   ->  Foreign Scan on public.s3  (cost=10.00..1491.24 rows=1462 width=16)
         Output: ((fields ->> 'value1'::text))::double precision, tan(('1'::double precision - ((fields ->> 'value1'::text))::double precision))
         InfluxDB query: SELECT "value1" FROM "s3"
(6 rows)

-- select tan with order by (result)
--Testcase 887:
SELECT (fields->>'value1')::float value1, tan(1-(fields->>'value1')::float) FROM s3 order by tan(1-(fields->>'value1')::float);
 value1 |         tan          
--------+----------------------
    2.2 |    -2.57215162212632
    1.1 | -0.10033467208545063
    0.3 |   0.8422883804630794
    0.2 |   1.0296385570503641
    3.3 |   1.1192136417341325
    0.1 |   1.2601582175503392
(6 rows)

-- select tan with order by index (result)
--Testcase 888:
SELECT (fields->>'value1')::float value1, tan(1-(fields->>'value1')::float) FROM s3 order by 2,1;
 value1 |         tan          
--------+----------------------
    2.2 |    -2.57215162212632
    1.1 | -0.10033467208545063
    0.3 |   0.8422883804630794
    0.2 |   1.0296385570503641
    3.3 |   1.1192136417341325
    0.1 |   1.2601582175503392
(6 rows)

-- select tan with order by index (result)
--Testcase 889:
SELECT (fields->>'value1')::float value1, tan(1-(fields->>'value1')::float) FROM s3 order by 1,2;
 value1 |         tan          
--------+----------------------
    0.1 |   1.2601582175503392
    0.2 |   1.0296385570503641
    0.3 |   0.8422883804630794
    1.1 | -0.10033467208545063
    2.2 |    -2.57215162212632
    3.3 |   1.1192136417341325
(6 rows)

-- select tan and as
--Testcase 890:
SELECT tan((fields->>'value3')::float) as tan1 FROM s3;
         tan1         
----------------------
 -0.10033467208545055
  -0.2027100355086725
 -0.30933624960962325
  -1.9647596572486523
   1.3738230567687946
 -0.15974574766003222
(6 rows)

-- select tan(*) (stub agg function, explain)
--Testcase 891:
EXPLAIN VERBOSE
SELECT tan_all() from s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=10.00..4266.25 rows=3413 width=32)
   Output: tan_all()
   InfluxDB query: SELECT * FROM "s3"
(3 rows)

-- select tan(*) (stub agg function, result)
--Testcase 892:
SELECT tan_all() from s3;
ERROR:  stub tan_all() is called
CONTEXT:  PL/pgSQL function tan_all() line 3 at RAISE
-- select tan(*) (stub agg function and group by tag only) (explain)
--Testcase 893:
EXPLAIN VERBOSE
SELECT tan_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (tan_all()), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT tan(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select tan(*) (stub agg function and group by tag only) (result)
--Testcase 894:
SELECT tan_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                                    tan_all                                                                                     
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0.10033467208545055\",\"value2\" : \"-0.587213915156929\",\"value3\" : \"-0.10033467208545055\",\"value4\" : \"0.587213915156929\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0.2027100355086725\",\"value2\" : \"-0.587213915156929\",\"value3\" : \"-0.2027100355086725\",\"value4\" : \"0.587213915156929\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0.30933624960962325\",\"value2\" : \"-0.587213915156929\",\"value3\" : \"-0.30933624960962325\",\"value4\" : \"0.587213915156929\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1.9647596572486523\",\"value2\" : \"-1.7925274837903817\",\"value3\" : \"-1.9647596572486523\",\"value4\" : \"1.7925274837903817\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"-1.3738230567687948\",\"value2\" : \"-1.7925274837903817\",\"value3\" : \"1.3738230567687948\",\"value4\" : \"1.7925274837903817\" }")
(5 rows)

-- select multiple star functions (do not push down, raise warning and stub error) (result)
--Testcase 895:
SELECT sin_all(), round_all(), tan_all() FROM s3;
ERROR:  stub sin_all() is called
CONTEXT:  PL/pgSQL function sin_all() line 3 at RAISE
-- select predictors function holt_winters() (explain)
--Testcase 896:
EXPLAIN VERBOSE
SELECT holt_winters(min((fields->>'value1')::float), 5, 1) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s');
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=16)
   Output: (holt_winters(min(((fields ->> 'value1'::text))::double precision), 5, 1)), (influx_time("time", '@ 1 sec'::interval))
   InfluxDB query: SELECT holt_winters(min("value1"), 5, 1) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u))
(3 rows)

-- select predictors function holt_winters() (result)
--Testcase 897:
SELECT holt_winters(min((fields->>'value1')::float), 5, 1) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s');
    holt_winters    
--------------------
  5.187460065608529
 13.293330784570104
 37.584774262501654
 116.55752059657874
 392.43117130749647
(5 rows)

-- select predictors function holt_winters_with_fit() (explain)
--Testcase 898:
EXPLAIN VERBOSE
SELECT holt_winters_with_fit(min((fields->>'value1')::float), 5, 1) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s');
                                                                                       QUERY PLAN                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=16)
   Output: (holt_winters_with_fit(min(((fields ->> 'value1'::text))::double precision), 5, 1)), (influx_time("time", '@ 1 sec'::interval))
   InfluxDB query: SELECT holt_winters_with_fit(min("value1"), 5, 1) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u))
(3 rows)

-- select predictors function holt_winters_with_fit() (result)
--Testcase 899:
SELECT holt_winters_with_fit(min((fields->>'value1')::float), 5, 1) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s');
 holt_winters_with_fit 
-----------------------
                   0.1
   0.14656936198258175
   0.44929718992786366
    1.0087607138536199
     2.218941363096379
     5.187460065608529
    13.293330784570104
    37.584774262501654
    116.55752059657874
    392.43117130749647
(10 rows)

-- select count(*) function of InfluxDB (stub agg function, explain)
--Testcase 900:
EXPLAIN VERBOSE
SELECT influx_count_all(*) FROM s3;
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=32)
   Output: (influx_count_all(*))
   InfluxDB query: SELECT count(*) FROM "s3"
(3 rows)

-- select count(*) function of InfluxDB (stub agg function, result)
--Testcase 901:
SELECT influx_count_all(*) FROM s3;
                                             influx_count_all                                             
----------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"6\",\"value2\" : \"6\",\"value3\" : \"6\",\"value4\" : \"6\" }")
(1 row)

-- select count(*) function of InfluxDB (stub agg function and group by influx_time() and tag) (explain)
--Testcase 902:
EXPLAIN VERBOSE
SELECT influx_count_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                           QUERY PLAN                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=72)
   Output: (influx_count_all(*)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT count(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select count(*) function of InfluxDB (stub agg function and group by influx_time() and tag) (result)
--Testcase 903:
SELECT influx_count_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                             influx_count_all                                             
----------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"1\",\"value2\" : \"1\",\"value3\" : \"1\",\"value4\" : \"1\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"1\",\"value2\" : \"1\",\"value3\" : \"1\",\"value4\" : \"1\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"1\",\"value2\" : \"1\",\"value3\" : \"1\",\"value4\" : \"1\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"0\",\"value2\" : \"0\",\"value3\" : \"0\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"0\",\"value2\" : \"0\",\"value3\" : \"0\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"0\",\"value2\" : \"0\",\"value3\" : \"0\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:01Z,,"{\"value1\" : \"0\",\"value2\" : \"0\",\"value3\" : \"0\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:02Z,,"{\"value1\" : \"0\",\"value2\" : \"0\",\"value3\" : \"0\",\"value4\" : \"0\" }")
 (1970-01-01T00:00:03Z,,"{\"value1\" : \"1\",\"value2\" : \"1\",\"value3\" : \"1\",\"value4\" : \"1\" }")
 (1970-01-01T00:00:04Z,,"{\"value1\" : \"1\",\"value2\" : \"1\",\"value3\" : \"1\",\"value4\" : \"1\" }")
(10 rows)

-- select count(*) function of InfluxDB (stub agg function and group by tag only) (explain)
--Testcase 904:
EXPLAIN VERBOSE
SELECT influx_count_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=64)
   Output: (influx_count_all(*)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT count(*) FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select count(*) function of InfluxDB (stub agg function and group by tag only) (result)
--Testcase 905:
SELECT influx_count_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                             influx_count_all                                             
----------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"3\",\"value2\" : \"3\",\"value3\" : \"3\",\"value4\" : \"3\" }")
 (1970-01-01T00:00:00Z,,"{\"value1\" : \"2\",\"value2\" : \"2\",\"value3\" : \"2\",\"value4\" : \"2\" }")
(2 rows)

-- select count(*) function of InfluxDB over join query (explain)
--Testcase 906:
EXPLAIN VERBOSE
SELECT influx_count_all(*) FROM s3 t1 INNER JOIN s3 t2 ON ((t1.fields->>'value1')::float = (t2.fields->>'value1')::float) where (t1.fields->>'value1')::float = 0.1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Aggregate  (cost=26.88..26.89 rows=1 width=32)
   Output: influx_count_all(*)
   ->  Nested Loop  (cost=20.00..14.63 rows=49 width=0)
         ->  Foreign Scan on public.s3 t1  (cost=10.00..7.00 rows=7 width=32)
               Output: t1."time", t1.tags, t1.fields
               InfluxDB query: SELECT * FROM "s3" WHERE (("value1" = 0.1))
         ->  Materialize  (cost=10.00..7.04 rows=7 width=32)
               Output: t2.fields
               ->  Foreign Scan on public.s3 t2  (cost=10.00..7.00 rows=7 width=32)
                     Output: t2.fields
                     InfluxDB query: SELECT * FROM "s3" WHERE (("value1" = 0.1))
(11 rows)

-- select count(*) function of InfluxDB over join query (result, stub call error)
--Testcase 907:
SELECT influx_count_all(*) FROM s3 t1 INNER JOIN s3 t2 ON ((t1.fields->>'value1')::float = (t2.fields->>'value1')::float) where (t1.fields->>'value1')::float = 0.1;
ERROR:  stub influx_count_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function influx_count_all_sfunc(text) line 3 at RAISE
-- select distinct (stub agg function, explain)
--Testcase 908:
EXPLAIN VERBOSE
SELECT influx_distinct((fields->>'value1')::float) FROM s3;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=8)
   Output: (influx_distinct(((fields ->> 'value1'::text))::double precision))
   InfluxDB query: SELECT distinct("value1") FROM "s3"
(3 rows)

-- select distinct (stub agg function, result)
--Testcase 909:
SELECT influx_distinct((fields->>'value1')::float) FROM s3;
 influx_distinct 
-----------------
             0.1
             0.2
             0.3
             1.1
             2.2
             3.3
(6 rows)

-- select distinct (stub agg function and group by influx_time() and tag) (explain)
--Testcase 910:
EXPLAIN VERBOSE
SELECT influx_distinct((fields->>'value1')::float), influx_time(time, interval '1s'),tags->>'tag1' tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=48)
   Output: (influx_distinct(((fields ->> 'value1'::text))::double precision)), (influx_time("time", '@ 1 sec'::interval)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT distinct("value1") FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY (time(0d0h0m1s0u)), ("tag1")
(3 rows)

-- select distinct (stub agg function and group by influx_time() and tag) (result)
--Testcase 911:
SELECT influx_distinct((fields->>'value1')::float), influx_time(time, interval '1s'),tags->>'tag1' tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tags->>'tag1';
 influx_distinct |      influx_time       | tag1 
-----------------+------------------------+------
             0.1 | 1970-01-01 09:00:00+09 | a
             0.2 | 1970-01-01 09:00:01+09 | a
             0.3 | 1970-01-01 09:00:02+09 | a
             1.1 | 1970-01-01 09:00:03+09 | b
             2.2 | 1970-01-01 09:00:04+09 | b
(5 rows)

-- select distinct (stub agg function and group by tag only) (explain)
--Testcase 912:
EXPLAIN VERBOSE
SELECT influx_distinct((fields->>'value2')::bigint) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=1.00..1.00 rows=1 width=40)
   Output: (influx_distinct(((fields ->> 'value2'::text))::bigint)), ((tags ->> 'tag1'::text))
   InfluxDB query: SELECT distinct("value2") FROM "s3" WHERE ((time >= '1970-01-01 00:00:00')) AND ((time <= '1970-01-01 00:00:04')) GROUP BY ("tag1")
(3 rows)

-- select distinct (stub agg function and group by tag only) (result)
--Testcase 913:
SELECT influx_distinct((fields->>'value2')::bigint) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tags->>'tag1';
 influx_distinct 
-----------------
             100
             200
(2 rows)

-- select distinct over join query (explain)
--Testcase 914:
EXPLAIN VERBOSE
SELECT influx_distinct((t1.fields->>'value2')::bigint) FROM s3 t1 INNER JOIN s3 t2 ON ((t1.fields->>'value1')::float = (t2.fields->>'value1')::float) where (t1.fields->>'value1')::float = 0.1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Aggregate  (cost=27.25..27.26 rows=1 width=8)
   Output: influx_distinct(((t1.fields ->> 'value2'::text))::bigint)
   ->  Nested Loop  (cost=20.00..14.63 rows=49 width=32)
         Output: t1.fields
         ->  Foreign Scan on public.s3 t1  (cost=10.00..7.00 rows=7 width=32)
               Output: t1."time", t1.tags, t1.fields
               InfluxDB query: SELECT * FROM "s3" WHERE (("value1" = 0.1))
         ->  Materialize  (cost=10.00..7.04 rows=7 width=32)
               Output: t2.fields
               ->  Foreign Scan on public.s3 t2  (cost=10.00..7.00 rows=7 width=32)
                     Output: t2.fields
                     InfluxDB query: SELECT * FROM "s3" WHERE (("value1" = 0.1))
(12 rows)

-- select distinct over join query (result, stub call error)
--Testcase 915:
SELECT influx_distinct((t1.fields->>'value2')::bigint) FROM s3 t1 INNER JOIN s3 t2 ON ((t1.fields->>'value1')::float = (t2.fields->>'value1')::float) where (t1.fields->>'value1')::float = 0.1;
ERROR:  stub influx_distinct_sfunc(anyelement, anyelement) is called
CONTEXT:  PL/pgSQL function influx_distinct_sfunc(anyelement,anyelement) line 3 at RAISE
-- select distinct with having (explain)
--Testcase 916:
EXPLAIN VERBOSE
SELECT influx_distinct((fields->>'value2')::bigint) FROM s3 HAVING influx_distinct((fields->>'value2')::bigint) > 100;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Aggregate  (cost=2214.93..2214.94 rows=1 width=8)
   Output: influx_distinct(((fields ->> 'value2'::text))::bigint)
   Filter: (influx_distinct(((s3.fields ->> 'value2'::text))::bigint) > 100)
   ->  Foreign Scan on public.s3  (cost=10.00..1462.00 rows=1462 width=32)
         Output: "time", tags, fields
         InfluxDB query: SELECT * FROM "s3"
(6 rows)

-- select distinct with having (result, not pushdown, stub call error)
--Testcase 917:
SELECT influx_distinct((fields->>'value2')::bigint) FROM s3 HAVING influx_distinct((fields->>'value2')::bigint) > 100;
ERROR:  stub influx_distinct_sfunc(anyelement, anyelement) is called
CONTEXT:  PL/pgSQL function influx_distinct_sfunc(anyelement,anyelement) line 3 at RAISE
--Testcase 918:
DROP FOREIGN TABLE s3;
--Testcase 919:
CREATE FOREIGN TABLE b3(time timestamp with time zone, tags jsonb OPTIONS (tags 'true'), fields jsonb OPTIONS (fields 'true')) SERVER server1 OPTIONS(table 'b3', tags 'tag1', schemaless 'true');
-- bool type var in where clause (result)
--Testcase 920:
EXPLAIN VERBOSE
SELECT sqrt(abs((fields->>'value1')::float)) FROM b3 WHERE (fields->>'value3')::boolean != true ORDER BY 1;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Sort  (cost=774.91..776.74 rows=731 width=8)
   Output: (sqrt(abs(((fields ->> 'value1'::text))::double precision)))
   Sort Key: (sqrt(abs(((b3.fields ->> 'value1'::text))::double precision)))
   ->  Foreign Scan on public.b3  (cost=10.00..740.14 rows=731 width=8)
         Output: sqrt(abs(((fields ->> 'value1'::text))::double precision))
         Filter: (NOT ((b3.fields ->> 'value3'::text))::boolean)
         InfluxDB query: SELECT "value1", "value3" FROM "b3"
(7 rows)

-- bool type var in where clause (result)
--Testcase 921:
SELECT sqrt(abs((fields->>'value1')::float)) FROM b3 WHERE (fields->>'value3')::boolean != true ORDER BY 1;
        sqrt        
--------------------
 0.4472135954999579
 1.0488088481701516
  1.816590212458495
(3 rows)

--Testcase 922:
DROP FOREIGN TABLE b3;
--Testcase 923:
DROP USER MAPPING FOR CURRENT_USER SERVER server1;
--Testcase 924:
DROP SERVER server1;
--Testcase 925:
DROP EXTENSION influxdb_fdw;
